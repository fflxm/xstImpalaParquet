/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CatalogObjects_TYPES_H
#define CatalogObjects_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "Data_types.h"
#include "Exprs_types.h"
#include "Status_types.h"
#include "Types_types.h"
#include "hive_metastore_types.h"
#include "SqlConstraints_types.h"


namespace impala {

struct TCatalogObjectType {
  enum type {
    UNKNOWN = 0,
    CATALOG = 1,
    DATABASE = 2,
    TABLE = 3,
    VIEW = 4,
    FUNCTION = 5,
    DATA_SOURCE = 6,
    PRINCIPAL = 7,
    PRIVILEGE = 8,
    HDFS_CACHE_POOL = 9,
    AUTHZ_CACHE_INVALIDATION = 10,
    HDFS_PARTITION = 11
  };
};

extern const std::map<int, const char*> _TCatalogObjectType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TCatalogObjectType::type& val);

struct TTableType {
  enum type {
    HDFS_TABLE = 0,
    HBASE_TABLE = 1,
    VIEW = 2,
    DATA_SOURCE_TABLE = 3,
    KUDU_TABLE = 4,
    ICEBERG_TABLE = 5
  };
};

extern const std::map<int, const char*> _TTableType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TTableType::type& val);

struct THdfsFileFormat {
  enum type {
    TEXT = 0,
    RC_FILE = 1,
    SEQUENCE_FILE = 2,
    AVRO = 3,
    PARQUET = 4,
    KUDU = 5,
    ORC = 6,
    HUDI_PARQUET = 7,
    ICEBERG = 8,
    JSON = 9
  };
};

extern const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const THdfsFileFormat::type& val);

struct THdfsCompression {
  enum type {
    NONE = 0,
    DEFAULT = 1,
    GZIP = 2,
    DEFLATE = 3,
    BZIP2 = 4,
    SNAPPY = 5,
    SNAPPY_BLOCKED = 6,
    LZO = 7,
    LZ4 = 8,
    ZLIB = 9,
    ZSTD = 10,
    BROTLI = 11,
    LZ4_BLOCKED = 12
  };
};

extern const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const THdfsCompression::type& val);

struct TIcebergFileFormat {
  enum type {
    PARQUET = 0,
    ORC = 1
  };
};

extern const std::map<int, const char*> _TIcebergFileFormat_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TIcebergFileFormat::type& val);

struct TIcebergCatalog {
  enum type {
    HADOOP_TABLES = 0,
    HADOOP_CATALOG = 1,
    HIVE_CATALOG = 2,
    CATALOGS = 3
  };
};

extern const std::map<int, const char*> _TIcebergCatalog_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TIcebergCatalog::type& val);

struct TColumnEncoding {
  enum type {
    AUTO = 0,
    PLAIN = 1,
    PREFIX = 2,
    GROUP_VARINT = 3,
    RLE = 4,
    DICTIONARY = 5,
    BIT_SHUFFLE = 6
  };
};

extern const std::map<int, const char*> _TColumnEncoding_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TColumnEncoding::type& val);

struct THdfsSeqCompressionMode {
  enum type {
    RECORD = 0,
    BLOCK = 1
  };
};

extern const std::map<int, const char*> _THdfsSeqCompressionMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const THdfsSeqCompressionMode::type& val);

struct TTablePropertyType {
  enum type {
    TBL_PROPERTY = 0,
    SERDE_PROPERTY = 1
  };
};

extern const std::map<int, const char*> _TTablePropertyType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TTablePropertyType::type& val);

struct TAccessLevel {
  enum type {
    NONE = 0,
    READ_WRITE = 1,
    READ_ONLY = 2,
    WRITE_ONLY = 3
  };
};

extern const std::map<int, const char*> _TAccessLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAccessLevel::type& val);

struct TIcebergPartitionTransformType {
  enum type {
    IDENTITY = 0,
    HOUR = 1,
    DAY = 2,
    MONTH = 3,
    YEAR = 4,
    BUCKET = 5,
    TRUNCATE = 6
  };
};

extern const std::map<int, const char*> _TIcebergPartitionTransformType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TIcebergPartitionTransformType::type& val);

struct TPrincipalType {
  enum type {
    ROLE = 0,
    USER = 1,
    GROUP = 2
  };
};

extern const std::map<int, const char*> _TPrincipalType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrincipalType::type& val);

struct TPrivilegeScope {
  enum type {
    SERVER = 0,
    URI = 1,
    DATABASE = 2,
    TABLE = 3,
    COLUMN = 4
  };
};

extern const std::map<int, const char*> _TPrivilegeScope_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrivilegeScope::type& val);

struct TPrivilegeLevel {
  enum type {
    ALL = 0,
    INSERT = 1,
    SELECT = 2,
    REFRESH = 3,
    CREATE = 4,
    ALTER = 5,
    DROP = 6,
    OWNER = 7
  };
};

extern const std::map<int, const char*> _TPrivilegeLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrivilegeLevel::type& val);

class TCompressionCodec;

class TPartitionKeyValue;

class TTableName;

class TTableStats;

class TColumnStats;

class TIntermediateColumnStats;

class TPartitionStats;

class TColumn;

class THdfsFileDesc;

class THdfsPartitionLocation;

class THdfsStorageDescriptor;

class THdfsPartition;

class TValidWriteIdList;

class THdfsTable;

class THBaseTable;

class TDataSource;

class TDataSourceTable;

class TKuduPartitionByHashParam;

class TRangePartition;

class TKuduPartitionByRangeParam;

class TKuduPartitionParam;

class TKuduTable;

class TIcebergPartitionTransform;

class TIcebergPartitionField;

class TIcebergPartitionSpec;

class TIcebergTable;

class TTable;

class TDatabase;

class TPrincipal;

class TPrivilege;

class THdfsCachePool;

class TAuthzCacheInvalidation;

class TCatalog;

class TCatalogObject;

typedef struct _TCompressionCodec__isset {
  _TCompressionCodec__isset() : compression_level(false) {}
  bool compression_level :1;
} _TCompressionCodec__isset;

class TCompressionCodec {
 public:

  TCompressionCodec(const TCompressionCodec&);
  TCompressionCodec(TCompressionCodec&&);
  TCompressionCodec& operator=(const TCompressionCodec&);
  TCompressionCodec& operator=(TCompressionCodec&&);
  TCompressionCodec() : codec((THdfsCompression::type)0), compression_level(0) {
  }

  virtual ~TCompressionCodec() throw();
  THdfsCompression::type codec;
  int32_t compression_level;

  _TCompressionCodec__isset __isset;

  void __set_codec(const THdfsCompression::type val);

  void __set_compression_level(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCompressionCodec &a, TCompressionCodec &b);

std::ostream& operator<<(std::ostream& out, const TCompressionCodec& obj);


class TPartitionKeyValue {
 public:

  TPartitionKeyValue(const TPartitionKeyValue&);
  TPartitionKeyValue(TPartitionKeyValue&&);
  TPartitionKeyValue& operator=(const TPartitionKeyValue&);
  TPartitionKeyValue& operator=(TPartitionKeyValue&&);
  TPartitionKeyValue() : name(), value() {
  }

  virtual ~TPartitionKeyValue() throw();
  std::string name;
  std::string value;

  void __set_name(const std::string& val);

  void __set_value(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b);

std::ostream& operator<<(std::ostream& out, const TPartitionKeyValue& obj);


class TTableName {
 public:

  TTableName(const TTableName&);
  TTableName(TTableName&&);
  TTableName& operator=(const TTableName&);
  TTableName& operator=(TTableName&&);
  TTableName() : db_name(), table_name() {
  }

  virtual ~TTableName() throw();
  std::string db_name;
  std::string table_name;

  void __set_db_name(const std::string& val);

  void __set_table_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableName &a, TTableName &b);

std::ostream& operator<<(std::ostream& out, const TTableName& obj);

typedef struct _TTableStats__isset {
  _TTableStats__isset() : total_file_bytes(false) {}
  bool total_file_bytes :1;
} _TTableStats__isset;

class TTableStats {
 public:

  TTableStats(const TTableStats&);
  TTableStats(TTableStats&&);
  TTableStats& operator=(const TTableStats&);
  TTableStats& operator=(TTableStats&&);
  TTableStats() : num_rows(0), total_file_bytes(0) {
  }

  virtual ~TTableStats() throw();
  int64_t num_rows;
  int64_t total_file_bytes;

  _TTableStats__isset __isset;

  void __set_num_rows(const int64_t val);

  void __set_total_file_bytes(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableStats &a, TTableStats &b);

std::ostream& operator<<(std::ostream& out, const TTableStats& obj);

typedef struct _TColumnStats__isset {
  _TColumnStats__isset() : low_value(false), high_value(false) {}
  bool low_value :1;
  bool high_value :1;
} _TColumnStats__isset;

class TColumnStats {
 public:

  TColumnStats(const TColumnStats&);
  TColumnStats(TColumnStats&&);
  TColumnStats& operator=(const TColumnStats&);
  TColumnStats& operator=(TColumnStats&&);
  TColumnStats() : avg_size(0), max_size(0), num_distinct_values(0), num_nulls(0), num_trues(0), num_falses(0) {
  }

  virtual ~TColumnStats() throw();
  double avg_size;
  int64_t max_size;
  int64_t num_distinct_values;
  int64_t num_nulls;
  int64_t num_trues;
  int64_t num_falses;
   ::impala::TColumnValue low_value;
   ::impala::TColumnValue high_value;

  _TColumnStats__isset __isset;

  void __set_avg_size(const double val);

  void __set_max_size(const int64_t val);

  void __set_num_distinct_values(const int64_t val);

  void __set_num_nulls(const int64_t val);

  void __set_num_trues(const int64_t val);

  void __set_num_falses(const int64_t val);

  void __set_low_value(const  ::impala::TColumnValue& val);

  void __set_high_value(const  ::impala::TColumnValue& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnStats &a, TColumnStats &b);

std::ostream& operator<<(std::ostream& out, const TColumnStats& obj);

typedef struct _TIntermediateColumnStats__isset {
  _TIntermediateColumnStats__isset() : intermediate_ndv(false), is_ndv_encoded(false), num_nulls(false), max_width(false), avg_width(false), num_rows(false), low_value(false), high_value(false) {}
  bool intermediate_ndv :1;
  bool is_ndv_encoded :1;
  bool num_nulls :1;
  bool max_width :1;
  bool avg_width :1;
  bool num_rows :1;
  bool low_value :1;
  bool high_value :1;
} _TIntermediateColumnStats__isset;

class TIntermediateColumnStats {
 public:

  TIntermediateColumnStats(const TIntermediateColumnStats&);
  TIntermediateColumnStats(TIntermediateColumnStats&&);
  TIntermediateColumnStats& operator=(const TIntermediateColumnStats&);
  TIntermediateColumnStats& operator=(TIntermediateColumnStats&&);
  TIntermediateColumnStats() : intermediate_ndv(), is_ndv_encoded(0), num_nulls(0), max_width(0), avg_width(0), num_rows(0), num_trues(0), num_falses(0) {
  }

  virtual ~TIntermediateColumnStats() throw();
  std::string intermediate_ndv;
  bool is_ndv_encoded;
  int64_t num_nulls;
  int32_t max_width;
  double avg_width;
  int64_t num_rows;
  int64_t num_trues;
  int64_t num_falses;
   ::impala::TColumnValue low_value;
   ::impala::TColumnValue high_value;

  _TIntermediateColumnStats__isset __isset;

  void __set_intermediate_ndv(const std::string& val);

  void __set_is_ndv_encoded(const bool val);

  void __set_num_nulls(const int64_t val);

  void __set_max_width(const int32_t val);

  void __set_avg_width(const double val);

  void __set_num_rows(const int64_t val);

  void __set_num_trues(const int64_t val);

  void __set_num_falses(const int64_t val);

  void __set_low_value(const  ::impala::TColumnValue& val);

  void __set_high_value(const  ::impala::TColumnValue& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIntermediateColumnStats &a, TIntermediateColumnStats &b);

std::ostream& operator<<(std::ostream& out, const TIntermediateColumnStats& obj);

typedef struct _TPartitionStats__isset {
  _TPartitionStats__isset() : intermediate_col_stats(false) {}
  bool intermediate_col_stats :1;
} _TPartitionStats__isset;

class TPartitionStats {
 public:

  TPartitionStats(const TPartitionStats&);
  TPartitionStats(TPartitionStats&&);
  TPartitionStats& operator=(const TPartitionStats&);
  TPartitionStats& operator=(TPartitionStats&&);
  TPartitionStats() {
  }

  virtual ~TPartitionStats() throw();
  TTableStats stats;
  std::map<std::string, TIntermediateColumnStats>  intermediate_col_stats;

  _TPartitionStats__isset __isset;

  void __set_stats(const TTableStats& val);

  void __set_intermediate_col_stats(const std::map<std::string, TIntermediateColumnStats> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartitionStats &a, TPartitionStats &b);

std::ostream& operator<<(std::ostream& out, const TPartitionStats& obj);

typedef struct _TColumn__isset {
  _TColumn__isset() : comment(false), col_stats(false), position(false), is_hbase_column(false), column_family(false), column_qualifier(false), is_binary(false), is_kudu_column(false), is_key(false), is_nullable(false), encoding(false), compression(false), default_value(false), block_size(false), kudu_column_name(false), is_iceberg_column(false), iceberg_field_id(false), iceberg_field_map_key_id(false), iceberg_field_map_value_id(false) {}
  bool comment :1;
  bool col_stats :1;
  bool position :1;
  bool is_hbase_column :1;
  bool column_family :1;
  bool column_qualifier :1;
  bool is_binary :1;
  bool is_kudu_column :1;
  bool is_key :1;
  bool is_nullable :1;
  bool encoding :1;
  bool compression :1;
  bool default_value :1;
  bool block_size :1;
  bool kudu_column_name :1;
  bool is_iceberg_column :1;
  bool iceberg_field_id :1;
  bool iceberg_field_map_key_id :1;
  bool iceberg_field_map_value_id :1;
} _TColumn__isset;

class TColumn {
 public:

  TColumn(const TColumn&);
  TColumn(TColumn&&);
  TColumn& operator=(const TColumn&);
  TColumn& operator=(TColumn&&);
  TColumn() : columnName(), comment(), position(0), is_hbase_column(0), column_family(), column_qualifier(), is_binary(0), is_kudu_column(0), is_key(0), is_nullable(0), encoding((TColumnEncoding::type)0), compression((THdfsCompression::type)0), block_size(0), kudu_column_name(), is_iceberg_column(0), iceberg_field_id(0), iceberg_field_map_key_id(0), iceberg_field_map_value_id(0) {
  }

  virtual ~TColumn() throw();
  std::string columnName;
   ::impala::TColumnType columnType;
  std::string comment;
  TColumnStats col_stats;
  int32_t position;
  bool is_hbase_column;
  std::string column_family;
  std::string column_qualifier;
  bool is_binary;
  bool is_kudu_column;
  bool is_key;
  bool is_nullable;
  TColumnEncoding::type encoding;
  THdfsCompression::type compression;
   ::impala::TExpr default_value;
  int32_t block_size;
  std::string kudu_column_name;
  bool is_iceberg_column;
  int32_t iceberg_field_id;
  int32_t iceberg_field_map_key_id;
  int32_t iceberg_field_map_value_id;

  _TColumn__isset __isset;

  void __set_columnName(const std::string& val);

  void __set_columnType(const  ::impala::TColumnType& val);

  void __set_comment(const std::string& val);

  void __set_col_stats(const TColumnStats& val);

  void __set_position(const int32_t val);

  void __set_is_hbase_column(const bool val);

  void __set_column_family(const std::string& val);

  void __set_column_qualifier(const std::string& val);

  void __set_is_binary(const bool val);

  void __set_is_kudu_column(const bool val);

  void __set_is_key(const bool val);

  void __set_is_nullable(const bool val);

  void __set_encoding(const TColumnEncoding::type val);

  void __set_compression(const THdfsCompression::type val);

  void __set_default_value(const  ::impala::TExpr& val);

  void __set_block_size(const int32_t val);

  void __set_kudu_column_name(const std::string& val);

  void __set_is_iceberg_column(const bool val);

  void __set_iceberg_field_id(const int32_t val);

  void __set_iceberg_field_map_key_id(const int32_t val);

  void __set_iceberg_field_map_value_id(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumn &a, TColumn &b);

std::ostream& operator<<(std::ostream& out, const TColumn& obj);


class THdfsFileDesc {
 public:

  THdfsFileDesc(const THdfsFileDesc&);
  THdfsFileDesc(THdfsFileDesc&&);
  THdfsFileDesc& operator=(const THdfsFileDesc&);
  THdfsFileDesc& operator=(THdfsFileDesc&&);
  THdfsFileDesc() : file_desc_data() {
  }

  virtual ~THdfsFileDesc() throw();
  std::string file_desc_data;

  void __set_file_desc_data(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsFileDesc &a, THdfsFileDesc &b);

std::ostream& operator<<(std::ostream& out, const THdfsFileDesc& obj);


class THdfsPartitionLocation {
 public:

  THdfsPartitionLocation(const THdfsPartitionLocation&);
  THdfsPartitionLocation(THdfsPartitionLocation&&);
  THdfsPartitionLocation& operator=(const THdfsPartitionLocation&);
  THdfsPartitionLocation& operator=(THdfsPartitionLocation&&);
  THdfsPartitionLocation() : prefix_index(-1), suffix() {
  }

  virtual ~THdfsPartitionLocation() throw();
  int32_t prefix_index;
  std::string suffix;

  void __set_prefix_index(const int32_t val);

  void __set_suffix(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsPartitionLocation &a, THdfsPartitionLocation &b);

std::ostream& operator<<(std::ostream& out, const THdfsPartitionLocation& obj);


class THdfsStorageDescriptor {
 public:

  THdfsStorageDescriptor(const THdfsStorageDescriptor&);
  THdfsStorageDescriptor(THdfsStorageDescriptor&&);
  THdfsStorageDescriptor& operator=(const THdfsStorageDescriptor&);
  THdfsStorageDescriptor& operator=(THdfsStorageDescriptor&&);
  THdfsStorageDescriptor() : lineDelim(0), fieldDelim(0), collectionDelim(0), mapKeyDelim(0), escapeChar(0), quoteChar(0), fileFormat((THdfsFileFormat::type)0), blockSize(0) {
  }

  virtual ~THdfsStorageDescriptor() throw();
  int8_t lineDelim;
  int8_t fieldDelim;
  int8_t collectionDelim;
  int8_t mapKeyDelim;
  int8_t escapeChar;
  int8_t quoteChar;
  THdfsFileFormat::type fileFormat;
  int32_t blockSize;

  void __set_lineDelim(const int8_t val);

  void __set_fieldDelim(const int8_t val);

  void __set_collectionDelim(const int8_t val);

  void __set_mapKeyDelim(const int8_t val);

  void __set_escapeChar(const int8_t val);

  void __set_quoteChar(const int8_t val);

  void __set_fileFormat(const THdfsFileFormat::type val);

  void __set_blockSize(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsStorageDescriptor &a, THdfsStorageDescriptor &b);

std::ostream& operator<<(std::ostream& out, const THdfsStorageDescriptor& obj);

typedef struct _THdfsPartition__isset {
  _THdfsPartition__isset() : partitionKeyExprs(false), location(false), id(false), prev_id(true), file_desc(false), insert_file_desc(false), delete_file_desc(false), access_level(false), stats(false), is_marked_cached(false), hms_parameters(false), num_blocks(false), total_file_size_bytes(false), partition_stats(false), has_incremental_stats(false), write_id(false), db_name(false), tbl_name(false), partition_name(false), hdfs_storage_descriptor(false) {}
  bool partitionKeyExprs :1;
  bool location :1;
  bool id :1;
  bool prev_id :1;
  bool file_desc :1;
  bool insert_file_desc :1;
  bool delete_file_desc :1;
  bool access_level :1;
  bool stats :1;
  bool is_marked_cached :1;
  bool hms_parameters :1;
  bool num_blocks :1;
  bool total_file_size_bytes :1;
  bool partition_stats :1;
  bool has_incremental_stats :1;
  bool write_id :1;
  bool db_name :1;
  bool tbl_name :1;
  bool partition_name :1;
  bool hdfs_storage_descriptor :1;
} _THdfsPartition__isset;

class THdfsPartition {
 public:

  THdfsPartition(const THdfsPartition&);
  THdfsPartition(THdfsPartition&&);
  THdfsPartition& operator=(const THdfsPartition&);
  THdfsPartition& operator=(THdfsPartition&&);
  THdfsPartition() : id(0), prev_id(-1LL), access_level((TAccessLevel::type)0), is_marked_cached(0), num_blocks(0), total_file_size_bytes(0), partition_stats(), has_incremental_stats(0), write_id(0), db_name(), tbl_name(), partition_name() {
  }

  virtual ~THdfsPartition() throw();
  std::vector< ::impala::TExpr>  partitionKeyExprs;
  THdfsPartitionLocation location;
  int64_t id;
  int64_t prev_id;
  std::vector<THdfsFileDesc>  file_desc;
  std::vector<THdfsFileDesc>  insert_file_desc;
  std::vector<THdfsFileDesc>  delete_file_desc;
  TAccessLevel::type access_level;
  TTableStats stats;
  bool is_marked_cached;
  std::map<std::string, std::string>  hms_parameters;
  int64_t num_blocks;
  int64_t total_file_size_bytes;
  std::string partition_stats;
  bool has_incremental_stats;
  int64_t write_id;
  std::string db_name;
  std::string tbl_name;
  std::string partition_name;
  THdfsStorageDescriptor hdfs_storage_descriptor;

  _THdfsPartition__isset __isset;

  void __set_partitionKeyExprs(const std::vector< ::impala::TExpr> & val);

  void __set_location(const THdfsPartitionLocation& val);

  void __set_id(const int64_t val);

  void __set_prev_id(const int64_t val);

  void __set_file_desc(const std::vector<THdfsFileDesc> & val);

  void __set_insert_file_desc(const std::vector<THdfsFileDesc> & val);

  void __set_delete_file_desc(const std::vector<THdfsFileDesc> & val);

  void __set_access_level(const TAccessLevel::type val);

  void __set_stats(const TTableStats& val);

  void __set_is_marked_cached(const bool val);

  void __set_hms_parameters(const std::map<std::string, std::string> & val);

  void __set_num_blocks(const int64_t val);

  void __set_total_file_size_bytes(const int64_t val);

  void __set_partition_stats(const std::string& val);

  void __set_has_incremental_stats(const bool val);

  void __set_write_id(const int64_t val);

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_partition_name(const std::string& val);

  void __set_hdfs_storage_descriptor(const THdfsStorageDescriptor& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsPartition &a, THdfsPartition &b);

std::ostream& operator<<(std::ostream& out, const THdfsPartition& obj);

typedef struct _TValidWriteIdList__isset {
  _TValidWriteIdList__isset() : high_watermark(false), min_open_write_id(false), invalid_write_ids(false), aborted_indexes(false) {}
  bool high_watermark :1;
  bool min_open_write_id :1;
  bool invalid_write_ids :1;
  bool aborted_indexes :1;
} _TValidWriteIdList__isset;

class TValidWriteIdList {
 public:

  TValidWriteIdList(const TValidWriteIdList&);
  TValidWriteIdList(TValidWriteIdList&&);
  TValidWriteIdList& operator=(const TValidWriteIdList&);
  TValidWriteIdList& operator=(TValidWriteIdList&&);
  TValidWriteIdList() : high_watermark(0), min_open_write_id(0) {
  }

  virtual ~TValidWriteIdList() throw();
  int64_t high_watermark;
  int64_t min_open_write_id;
  std::vector<int64_t>  invalid_write_ids;
  std::vector<int32_t>  aborted_indexes;

  _TValidWriteIdList__isset __isset;

  void __set_high_watermark(const int64_t val);

  void __set_min_open_write_id(const int64_t val);

  void __set_invalid_write_ids(const std::vector<int64_t> & val);

  void __set_aborted_indexes(const std::vector<int32_t> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TValidWriteIdList &a, TValidWriteIdList &b);

std::ostream& operator<<(std::ostream& out, const TValidWriteIdList& obj);

typedef struct _THdfsTable__isset {
  _THdfsTable__isset() : avroSchema(false), has_full_partitions(false), has_partition_names(false), partition_prefixes(false), network_addresses(false), sql_constraints(false), is_full_acid(true), valid_write_ids(false) {}
  bool avroSchema :1;
  bool has_full_partitions :1;
  bool has_partition_names :1;
  bool partition_prefixes :1;
  bool network_addresses :1;
  bool sql_constraints :1;
  bool is_full_acid :1;
  bool valid_write_ids :1;
} _THdfsTable__isset;

class THdfsTable {
 public:

  THdfsTable(const THdfsTable&);
  THdfsTable(THdfsTable&&);
  THdfsTable& operator=(const THdfsTable&);
  THdfsTable& operator=(THdfsTable&&);
  THdfsTable() : hdfsBaseDir(), nullPartitionKeyValue(), nullColumnValue(), avroSchema(), has_full_partitions(0), has_partition_names(0), is_full_acid(false) {
  }

  virtual ~THdfsTable() throw();
  std::string hdfsBaseDir;
  std::vector<std::string>  colNames;
  std::string nullPartitionKeyValue;
  std::string nullColumnValue;
  std::string avroSchema;
  std::map<int64_t, THdfsPartition>  partitions;
  bool has_full_partitions;
  bool has_partition_names;
  THdfsPartition prototype_partition;
  std::vector<std::string>  partition_prefixes;
  std::vector< ::impala::TNetworkAddress>  network_addresses;
   ::impala::TSqlConstraints sql_constraints;
  bool is_full_acid;
  TValidWriteIdList valid_write_ids;

  _THdfsTable__isset __isset;

  void __set_hdfsBaseDir(const std::string& val);

  void __set_colNames(const std::vector<std::string> & val);

  void __set_nullPartitionKeyValue(const std::string& val);

  void __set_nullColumnValue(const std::string& val);

  void __set_avroSchema(const std::string& val);

  void __set_partitions(const std::map<int64_t, THdfsPartition> & val);

  void __set_has_full_partitions(const bool val);

  void __set_has_partition_names(const bool val);

  void __set_prototype_partition(const THdfsPartition& val);

  void __set_partition_prefixes(const std::vector<std::string> & val);

  void __set_network_addresses(const std::vector< ::impala::TNetworkAddress> & val);

  void __set_sql_constraints(const  ::impala::TSqlConstraints& val);

  void __set_is_full_acid(const bool val);

  void __set_valid_write_ids(const TValidWriteIdList& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsTable &a, THdfsTable &b);

std::ostream& operator<<(std::ostream& out, const THdfsTable& obj);

typedef struct _THBaseTable__isset {
  _THBaseTable__isset() : binary_encoded(false) {}
  bool binary_encoded :1;
} _THBaseTable__isset;

class THBaseTable {
 public:

  THBaseTable(const THBaseTable&);
  THBaseTable(THBaseTable&&);
  THBaseTable& operator=(const THBaseTable&);
  THBaseTable& operator=(THBaseTable&&);
  THBaseTable() : tableName() {
  }

  virtual ~THBaseTable() throw();
  std::string tableName;
  std::vector<std::string>  families;
  std::vector<std::string>  qualifiers;
  std::vector<bool>  binary_encoded;

  _THBaseTable__isset __isset;

  void __set_tableName(const std::string& val);

  void __set_families(const std::vector<std::string> & val);

  void __set_qualifiers(const std::vector<std::string> & val);

  void __set_binary_encoded(const std::vector<bool> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THBaseTable &a, THBaseTable &b);

std::ostream& operator<<(std::ostream& out, const THBaseTable& obj);


class TDataSource {
 public:

  TDataSource(const TDataSource&);
  TDataSource(TDataSource&&);
  TDataSource& operator=(const TDataSource&);
  TDataSource& operator=(TDataSource&&);
  TDataSource() : name(), hdfs_location(), class_name(), api_version() {
  }

  virtual ~TDataSource() throw();
  std::string name;
  std::string hdfs_location;
  std::string class_name;
  std::string api_version;

  void __set_name(const std::string& val);

  void __set_hdfs_location(const std::string& val);

  void __set_class_name(const std::string& val);

  void __set_api_version(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataSource &a, TDataSource &b);

std::ostream& operator<<(std::ostream& out, const TDataSource& obj);


class TDataSourceTable {
 public:

  TDataSourceTable(const TDataSourceTable&);
  TDataSourceTable(TDataSourceTable&&);
  TDataSourceTable& operator=(const TDataSourceTable&);
  TDataSourceTable& operator=(TDataSourceTable&&);
  TDataSourceTable() : init_string() {
  }

  virtual ~TDataSourceTable() throw();
  TDataSource data_source;
  std::string init_string;

  void __set_data_source(const TDataSource& val);

  void __set_init_string(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataSourceTable &a, TDataSourceTable &b);

std::ostream& operator<<(std::ostream& out, const TDataSourceTable& obj);


class TKuduPartitionByHashParam {
 public:

  TKuduPartitionByHashParam(const TKuduPartitionByHashParam&);
  TKuduPartitionByHashParam(TKuduPartitionByHashParam&&);
  TKuduPartitionByHashParam& operator=(const TKuduPartitionByHashParam&);
  TKuduPartitionByHashParam& operator=(TKuduPartitionByHashParam&&);
  TKuduPartitionByHashParam() : num_partitions(0) {
  }

  virtual ~TKuduPartitionByHashParam() throw();
  std::vector<std::string>  columns;
  int32_t num_partitions;

  void __set_columns(const std::vector<std::string> & val);

  void __set_num_partitions(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduPartitionByHashParam &a, TKuduPartitionByHashParam &b);

std::ostream& operator<<(std::ostream& out, const TKuduPartitionByHashParam& obj);

typedef struct _TRangePartition__isset {
  _TRangePartition__isset() : lower_bound_values(false), is_lower_bound_inclusive(false), upper_bound_values(false), is_upper_bound_inclusive(false) {}
  bool lower_bound_values :1;
  bool is_lower_bound_inclusive :1;
  bool upper_bound_values :1;
  bool is_upper_bound_inclusive :1;
} _TRangePartition__isset;

class TRangePartition {
 public:

  TRangePartition(const TRangePartition&);
  TRangePartition(TRangePartition&&);
  TRangePartition& operator=(const TRangePartition&);
  TRangePartition& operator=(TRangePartition&&);
  TRangePartition() : is_lower_bound_inclusive(0), is_upper_bound_inclusive(0) {
  }

  virtual ~TRangePartition() throw();
  std::vector< ::impala::TExpr>  lower_bound_values;
  bool is_lower_bound_inclusive;
  std::vector< ::impala::TExpr>  upper_bound_values;
  bool is_upper_bound_inclusive;

  _TRangePartition__isset __isset;

  void __set_lower_bound_values(const std::vector< ::impala::TExpr> & val);

  void __set_is_lower_bound_inclusive(const bool val);

  void __set_upper_bound_values(const std::vector< ::impala::TExpr> & val);

  void __set_is_upper_bound_inclusive(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRangePartition &a, TRangePartition &b);

std::ostream& operator<<(std::ostream& out, const TRangePartition& obj);

typedef struct _TKuduPartitionByRangeParam__isset {
  _TKuduPartitionByRangeParam__isset() : range_partitions(false) {}
  bool range_partitions :1;
} _TKuduPartitionByRangeParam__isset;

class TKuduPartitionByRangeParam {
 public:

  TKuduPartitionByRangeParam(const TKuduPartitionByRangeParam&);
  TKuduPartitionByRangeParam(TKuduPartitionByRangeParam&&);
  TKuduPartitionByRangeParam& operator=(const TKuduPartitionByRangeParam&);
  TKuduPartitionByRangeParam& operator=(TKuduPartitionByRangeParam&&);
  TKuduPartitionByRangeParam() {
  }

  virtual ~TKuduPartitionByRangeParam() throw();
  std::vector<std::string>  columns;
  std::vector<TRangePartition>  range_partitions;

  _TKuduPartitionByRangeParam__isset __isset;

  void __set_columns(const std::vector<std::string> & val);

  void __set_range_partitions(const std::vector<TRangePartition> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduPartitionByRangeParam &a, TKuduPartitionByRangeParam &b);

std::ostream& operator<<(std::ostream& out, const TKuduPartitionByRangeParam& obj);

typedef struct _TKuduPartitionParam__isset {
  _TKuduPartitionParam__isset() : by_hash_param(false), by_range_param(false) {}
  bool by_hash_param :1;
  bool by_range_param :1;
} _TKuduPartitionParam__isset;

class TKuduPartitionParam {
 public:

  TKuduPartitionParam(const TKuduPartitionParam&);
  TKuduPartitionParam(TKuduPartitionParam&&);
  TKuduPartitionParam& operator=(const TKuduPartitionParam&);
  TKuduPartitionParam& operator=(TKuduPartitionParam&&);
  TKuduPartitionParam() {
  }

  virtual ~TKuduPartitionParam() throw();
  TKuduPartitionByHashParam by_hash_param;
  TKuduPartitionByRangeParam by_range_param;

  _TKuduPartitionParam__isset __isset;

  void __set_by_hash_param(const TKuduPartitionByHashParam& val);

  void __set_by_range_param(const TKuduPartitionByRangeParam& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduPartitionParam &a, TKuduPartitionParam &b);

std::ostream& operator<<(std::ostream& out, const TKuduPartitionParam& obj);


class TKuduTable {
 public:

  TKuduTable(const TKuduTable&);
  TKuduTable(TKuduTable&&);
  TKuduTable& operator=(const TKuduTable&);
  TKuduTable& operator=(TKuduTable&&);
  TKuduTable() : table_name() {
  }

  virtual ~TKuduTable() throw();
  std::string table_name;
  std::vector<std::string>  master_addresses;
  std::vector<std::string>  key_columns;
  std::vector<TKuduPartitionParam>  partition_by;

  void __set_table_name(const std::string& val);

  void __set_master_addresses(const std::vector<std::string> & val);

  void __set_key_columns(const std::vector<std::string> & val);

  void __set_partition_by(const std::vector<TKuduPartitionParam> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduTable &a, TKuduTable &b);

std::ostream& operator<<(std::ostream& out, const TKuduTable& obj);

typedef struct _TIcebergPartitionTransform__isset {
  _TIcebergPartitionTransform__isset() : transform_param(false) {}
  bool transform_param :1;
} _TIcebergPartitionTransform__isset;

class TIcebergPartitionTransform {
 public:

  TIcebergPartitionTransform(const TIcebergPartitionTransform&);
  TIcebergPartitionTransform(TIcebergPartitionTransform&&);
  TIcebergPartitionTransform& operator=(const TIcebergPartitionTransform&);
  TIcebergPartitionTransform& operator=(TIcebergPartitionTransform&&);
  TIcebergPartitionTransform() : transform_type((TIcebergPartitionTransformType::type)0), transform_param(0) {
  }

  virtual ~TIcebergPartitionTransform() throw();
  TIcebergPartitionTransformType::type transform_type;
  int32_t transform_param;

  _TIcebergPartitionTransform__isset __isset;

  void __set_transform_type(const TIcebergPartitionTransformType::type val);

  void __set_transform_param(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIcebergPartitionTransform &a, TIcebergPartitionTransform &b);

std::ostream& operator<<(std::ostream& out, const TIcebergPartitionTransform& obj);


class TIcebergPartitionField {
 public:

  TIcebergPartitionField(const TIcebergPartitionField&);
  TIcebergPartitionField(TIcebergPartitionField&&);
  TIcebergPartitionField& operator=(const TIcebergPartitionField&);
  TIcebergPartitionField& operator=(TIcebergPartitionField&&);
  TIcebergPartitionField() : source_id(0), field_id(0), orig_field_name(), field_name() {
  }

  virtual ~TIcebergPartitionField() throw();
  int32_t source_id;
  int32_t field_id;
  std::string orig_field_name;
  std::string field_name;
  TIcebergPartitionTransform transform;

  void __set_source_id(const int32_t val);

  void __set_field_id(const int32_t val);

  void __set_orig_field_name(const std::string& val);

  void __set_field_name(const std::string& val);

  void __set_transform(const TIcebergPartitionTransform& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIcebergPartitionField &a, TIcebergPartitionField &b);

std::ostream& operator<<(std::ostream& out, const TIcebergPartitionField& obj);

typedef struct _TIcebergPartitionSpec__isset {
  _TIcebergPartitionSpec__isset() : partition_fields(false) {}
  bool partition_fields :1;
} _TIcebergPartitionSpec__isset;

class TIcebergPartitionSpec {
 public:

  TIcebergPartitionSpec(const TIcebergPartitionSpec&);
  TIcebergPartitionSpec(TIcebergPartitionSpec&&);
  TIcebergPartitionSpec& operator=(const TIcebergPartitionSpec&);
  TIcebergPartitionSpec& operator=(TIcebergPartitionSpec&&);
  TIcebergPartitionSpec() : partition_id(0) {
  }

  virtual ~TIcebergPartitionSpec() throw();
  int32_t partition_id;
  std::vector<TIcebergPartitionField>  partition_fields;

  _TIcebergPartitionSpec__isset __isset;

  void __set_partition_id(const int32_t val);

  void __set_partition_fields(const std::vector<TIcebergPartitionField> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIcebergPartitionSpec &a, TIcebergPartitionSpec &b);

std::ostream& operator<<(std::ostream& out, const TIcebergPartitionSpec& obj);

typedef struct _TIcebergTable__isset {
  _TIcebergTable__isset() : path_hash_to_file_descriptor(false), snapshot_id(false), parquet_compression_codec(false), parquet_row_group_size(false), parquet_plain_page_size(false), parquet_dict_page_size(false) {}
  bool path_hash_to_file_descriptor :1;
  bool snapshot_id :1;
  bool parquet_compression_codec :1;
  bool parquet_row_group_size :1;
  bool parquet_plain_page_size :1;
  bool parquet_dict_page_size :1;
} _TIcebergTable__isset;

class TIcebergTable {
 public:

  TIcebergTable(const TIcebergTable&);
  TIcebergTable(TIcebergTable&&);
  TIcebergTable& operator=(const TIcebergTable&);
  TIcebergTable& operator=(TIcebergTable&&);
  TIcebergTable() : table_location(), default_partition_spec_id(0), snapshot_id(0), parquet_row_group_size(0), parquet_plain_page_size(0), parquet_dict_page_size(0) {
  }

  virtual ~TIcebergTable() throw();
  std::string table_location;
  std::vector<TIcebergPartitionSpec>  partition_spec;
  int32_t default_partition_spec_id;
  std::map<std::string, THdfsFileDesc>  path_hash_to_file_descriptor;
  int64_t snapshot_id;
  TCompressionCodec parquet_compression_codec;
  int64_t parquet_row_group_size;
  int64_t parquet_plain_page_size;
  int64_t parquet_dict_page_size;

  _TIcebergTable__isset __isset;

  void __set_table_location(const std::string& val);

  void __set_partition_spec(const std::vector<TIcebergPartitionSpec> & val);

  void __set_default_partition_spec_id(const int32_t val);

  void __set_path_hash_to_file_descriptor(const std::map<std::string, THdfsFileDesc> & val);

  void __set_snapshot_id(const int64_t val);

  void __set_parquet_compression_codec(const TCompressionCodec& val);

  void __set_parquet_row_group_size(const int64_t val);

  void __set_parquet_plain_page_size(const int64_t val);

  void __set_parquet_dict_page_size(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIcebergTable &a, TIcebergTable &b);

std::ostream& operator<<(std::ostream& out, const TIcebergTable& obj);

typedef struct _TTable__isset {
  _TTable__isset() : load_status(false), access_level(false), columns(false), clustering_columns(false), table_stats(false), table_type(false), hdfs_table(false), hbase_table(false), metastore_table(false), data_source_table(false), kudu_table(false), storage_metadata_load_time_ns(false), iceberg_table(false) {}
  bool load_status :1;
  bool access_level :1;
  bool columns :1;
  bool clustering_columns :1;
  bool table_stats :1;
  bool table_type :1;
  bool hdfs_table :1;
  bool hbase_table :1;
  bool metastore_table :1;
  bool data_source_table :1;
  bool kudu_table :1;
  bool storage_metadata_load_time_ns :1;
  bool iceberg_table :1;
} _TTable__isset;

class TTable {
 public:

  TTable(const TTable&);
  TTable(TTable&&);
  TTable& operator=(const TTable&);
  TTable& operator=(TTable&&);
  TTable() : db_name(), tbl_name(), access_level((TAccessLevel::type)0), table_type((TTableType::type)0), storage_metadata_load_time_ns(0) {
  }

  virtual ~TTable() throw();
  std::string db_name;
  std::string tbl_name;
   ::impala::TStatus load_status;
  TAccessLevel::type access_level;
  std::vector<TColumn>  columns;
  std::vector<TColumn>  clustering_columns;
  TTableStats table_stats;
  TTableType::type table_type;
  THdfsTable hdfs_table;
  THBaseTable hbase_table;
   ::Apache::Hadoop::Hive::Table metastore_table;
  TDataSourceTable data_source_table;
  TKuduTable kudu_table;
  int64_t storage_metadata_load_time_ns;
  TIcebergTable iceberg_table;

  _TTable__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_tbl_name(const std::string& val);

  void __set_load_status(const  ::impala::TStatus& val);

  void __set_access_level(const TAccessLevel::type val);

  void __set_columns(const std::vector<TColumn> & val);

  void __set_clustering_columns(const std::vector<TColumn> & val);

  void __set_table_stats(const TTableStats& val);

  void __set_table_type(const TTableType::type val);

  void __set_hdfs_table(const THdfsTable& val);

  void __set_hbase_table(const THBaseTable& val);

  void __set_metastore_table(const  ::Apache::Hadoop::Hive::Table& val);

  void __set_data_source_table(const TDataSourceTable& val);

  void __set_kudu_table(const TKuduTable& val);

  void __set_storage_metadata_load_time_ns(const int64_t val);

  void __set_iceberg_table(const TIcebergTable& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTable &a, TTable &b);

std::ostream& operator<<(std::ostream& out, const TTable& obj);

typedef struct _TDatabase__isset {
  _TDatabase__isset() : metastore_db(false) {}
  bool metastore_db :1;
} _TDatabase__isset;

class TDatabase {
 public:

  TDatabase(const TDatabase&);
  TDatabase(TDatabase&&);
  TDatabase& operator=(const TDatabase&);
  TDatabase& operator=(TDatabase&&);
  TDatabase() : db_name() {
  }

  virtual ~TDatabase() throw();
  std::string db_name;
   ::Apache::Hadoop::Hive::Database metastore_db;

  _TDatabase__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_metastore_db(const  ::Apache::Hadoop::Hive::Database& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDatabase &a, TDatabase &b);

std::ostream& operator<<(std::ostream& out, const TDatabase& obj);


class TPrincipal {
 public:

  TPrincipal(const TPrincipal&);
  TPrincipal(TPrincipal&&);
  TPrincipal& operator=(const TPrincipal&);
  TPrincipal& operator=(TPrincipal&&);
  TPrincipal() : principal_name(), principal_id(0), principal_type((TPrincipalType::type)0) {
  }

  virtual ~TPrincipal() throw();
  std::string principal_name;
  int32_t principal_id;
  TPrincipalType::type principal_type;
  std::vector<std::string>  grant_groups;

  void __set_principal_name(const std::string& val);

  void __set_principal_id(const int32_t val);

  void __set_principal_type(const TPrincipalType::type val);

  void __set_grant_groups(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPrincipal &a, TPrincipal &b);

std::ostream& operator<<(std::ostream& out, const TPrincipal& obj);

typedef struct _TPrivilege__isset {
  _TPrivilege__isset() : principal_id(false), principal_type(false), server_name(false), db_name(false), table_name(false), uri(false), create_time_ms(false), column_name(false) {}
  bool principal_id :1;
  bool principal_type :1;
  bool server_name :1;
  bool db_name :1;
  bool table_name :1;
  bool uri :1;
  bool create_time_ms :1;
  bool column_name :1;
} _TPrivilege__isset;

class TPrivilege {
 public:

  TPrivilege(const TPrivilege&);
  TPrivilege(TPrivilege&&);
  TPrivilege& operator=(const TPrivilege&);
  TPrivilege& operator=(TPrivilege&&);
  TPrivilege() : privilege_level((TPrivilegeLevel::type)0), scope((TPrivilegeScope::type)0), has_grant_opt(0), principal_id(0), principal_type((TPrincipalType::type)0), server_name(), db_name(), table_name(), uri(), create_time_ms(0), column_name() {
  }

  virtual ~TPrivilege() throw();
  TPrivilegeLevel::type privilege_level;
  TPrivilegeScope::type scope;
  bool has_grant_opt;
  int32_t principal_id;
  TPrincipalType::type principal_type;
  std::string server_name;
  std::string db_name;
  std::string table_name;
  std::string uri;
  int64_t create_time_ms;
  std::string column_name;

  _TPrivilege__isset __isset;

  void __set_privilege_level(const TPrivilegeLevel::type val);

  void __set_scope(const TPrivilegeScope::type val);

  void __set_has_grant_opt(const bool val);

  void __set_principal_id(const int32_t val);

  void __set_principal_type(const TPrincipalType::type val);

  void __set_server_name(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_uri(const std::string& val);

  void __set_create_time_ms(const int64_t val);

  void __set_column_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPrivilege &a, TPrivilege &b);

std::ostream& operator<<(std::ostream& out, const TPrivilege& obj);


class THdfsCachePool {
 public:

  THdfsCachePool(const THdfsCachePool&);
  THdfsCachePool(THdfsCachePool&&);
  THdfsCachePool& operator=(const THdfsCachePool&);
  THdfsCachePool& operator=(THdfsCachePool&&);
  THdfsCachePool() : pool_name() {
  }

  virtual ~THdfsCachePool() throw();
  std::string pool_name;

  void __set_pool_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsCachePool &a, THdfsCachePool &b);

std::ostream& operator<<(std::ostream& out, const THdfsCachePool& obj);


class TAuthzCacheInvalidation {
 public:

  TAuthzCacheInvalidation(const TAuthzCacheInvalidation&);
  TAuthzCacheInvalidation(TAuthzCacheInvalidation&&);
  TAuthzCacheInvalidation& operator=(const TAuthzCacheInvalidation&);
  TAuthzCacheInvalidation& operator=(TAuthzCacheInvalidation&&);
  TAuthzCacheInvalidation() : marker_name() {
  }

  virtual ~TAuthzCacheInvalidation() throw();
  std::string marker_name;

  void __set_marker_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAuthzCacheInvalidation &a, TAuthzCacheInvalidation &b);

std::ostream& operator<<(std::ostream& out, const TAuthzCacheInvalidation& obj);


class TCatalog {
 public:

  TCatalog(const TCatalog&);
  TCatalog(TCatalog&&);
  TCatalog& operator=(const TCatalog&);
  TCatalog& operator=(TCatalog&&);
  TCatalog() : last_reset_catalog_version(0) {
  }

  virtual ~TCatalog() throw();
   ::impala::TUniqueId catalog_service_id;
  int64_t last_reset_catalog_version;

  void __set_catalog_service_id(const  ::impala::TUniqueId& val);

  void __set_last_reset_catalog_version(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalog &a, TCatalog &b);

std::ostream& operator<<(std::ostream& out, const TCatalog& obj);

typedef struct _TCatalogObject__isset {
  _TCatalogObject__isset() : catalog(false), db(false), table(false), fn(false), data_source(false), principal(false), privilege(false), cache_pool(false), authz_cache_invalidation(false), hdfs_partition(false) {}
  bool catalog :1;
  bool db :1;
  bool table :1;
  bool fn :1;
  bool data_source :1;
  bool principal :1;
  bool privilege :1;
  bool cache_pool :1;
  bool authz_cache_invalidation :1;
  bool hdfs_partition :1;
} _TCatalogObject__isset;

class TCatalogObject {
 public:

  TCatalogObject(const TCatalogObject&);
  TCatalogObject(TCatalogObject&&);
  TCatalogObject& operator=(const TCatalogObject&);
  TCatalogObject& operator=(TCatalogObject&&);
  TCatalogObject() : type((TCatalogObjectType::type)0), catalog_version(0) {
  }

  virtual ~TCatalogObject() throw();
  TCatalogObjectType::type type;
  int64_t catalog_version;
  TCatalog catalog;
  TDatabase db;
  TTable table;
   ::impala::TFunction fn;
  TDataSource data_source;
  TPrincipal principal;
  TPrivilege privilege;
  THdfsCachePool cache_pool;
  TAuthzCacheInvalidation authz_cache_invalidation;
  THdfsPartition hdfs_partition;

  _TCatalogObject__isset __isset;

  void __set_type(const TCatalogObjectType::type val);

  void __set_catalog_version(const int64_t val);

  void __set_catalog(const TCatalog& val);

  void __set_db(const TDatabase& val);

  void __set_table(const TTable& val);

  void __set_fn(const  ::impala::TFunction& val);

  void __set_data_source(const TDataSource& val);

  void __set_principal(const TPrincipal& val);

  void __set_privilege(const TPrivilege& val);

  void __set_cache_pool(const THdfsCachePool& val);

  void __set_authz_cache_invalidation(const TAuthzCacheInvalidation& val);

  void __set_hdfs_partition(const THdfsPartition& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogObject &a, TCatalogObject &b);

std::ostream& operator<<(std::ostream& out, const TCatalogObject& obj);

} // namespace

#include "CatalogObjects_types.tcc"

#endif
