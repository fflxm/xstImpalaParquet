/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Descriptors_TYPES_H
#define Descriptors_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "CatalogObjects_types.h"
#include "Types_types.h"
#include "Exprs_types.h"


namespace impala {

class TSlotDescriptor;

class TColumnDescriptor;

class TTableDescriptor;

class TTupleDescriptor;

class TDescriptorTable;

class TDescriptorTableSerialized;

typedef struct _TSlotDescriptor__isset {
  _TSlotDescriptor__isset() : itemTupleId(false) {}
  bool itemTupleId :1;
} _TSlotDescriptor__isset;

class TSlotDescriptor {
 public:

  TSlotDescriptor(const TSlotDescriptor&);
  TSlotDescriptor(TSlotDescriptor&&);
  TSlotDescriptor& operator=(const TSlotDescriptor&);
  TSlotDescriptor& operator=(TSlotDescriptor&&);
  TSlotDescriptor() : id(0), parent(0), itemTupleId(0), byteOffset(0), nullIndicatorByte(0), nullIndicatorBit(0), slotIdx(0) {
  }

  virtual ~TSlotDescriptor() throw();
   ::impala::TSlotId id;
   ::impala::TTupleId parent;
   ::impala::TTupleId itemTupleId;
   ::impala::TColumnType slotType;
  std::vector<int32_t>  materializedPath;
  int32_t byteOffset;
  int32_t nullIndicatorByte;
  int32_t nullIndicatorBit;
  int32_t slotIdx;

  _TSlotDescriptor__isset __isset;

  void __set_id(const  ::impala::TSlotId val);

  void __set_parent(const  ::impala::TTupleId val);

  void __set_itemTupleId(const  ::impala::TTupleId val);

  void __set_slotType(const  ::impala::TColumnType& val);

  void __set_materializedPath(const std::vector<int32_t> & val);

  void __set_byteOffset(const int32_t val);

  void __set_nullIndicatorByte(const int32_t val);

  void __set_nullIndicatorBit(const int32_t val);

  void __set_slotIdx(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSlotDescriptor &a, TSlotDescriptor &b);

std::ostream& operator<<(std::ostream& out, const TSlotDescriptor& obj);

typedef struct _TColumnDescriptor__isset {
  _TColumnDescriptor__isset() : icebergFieldId(false), icebergFieldMapKeyId(false), icebergFieldMapValueId(false) {}
  bool icebergFieldId :1;
  bool icebergFieldMapKeyId :1;
  bool icebergFieldMapValueId :1;
} _TColumnDescriptor__isset;

class TColumnDescriptor {
 public:

  TColumnDescriptor(const TColumnDescriptor&);
  TColumnDescriptor(TColumnDescriptor&&);
  TColumnDescriptor& operator=(const TColumnDescriptor&);
  TColumnDescriptor& operator=(TColumnDescriptor&&);
  TColumnDescriptor() : name(), icebergFieldId(0), icebergFieldMapKeyId(0), icebergFieldMapValueId(0) {
  }

  virtual ~TColumnDescriptor() throw();
  std::string name;
   ::impala::TColumnType type;
  int32_t icebergFieldId;
  int32_t icebergFieldMapKeyId;
  int32_t icebergFieldMapValueId;

  _TColumnDescriptor__isset __isset;

  void __set_name(const std::string& val);

  void __set_type(const  ::impala::TColumnType& val);

  void __set_icebergFieldId(const int32_t val);

  void __set_icebergFieldMapKeyId(const int32_t val);

  void __set_icebergFieldMapValueId(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnDescriptor &a, TColumnDescriptor &b);

std::ostream& operator<<(std::ostream& out, const TColumnDescriptor& obj);

typedef struct _TTableDescriptor__isset {
  _TTableDescriptor__isset() : hdfsTable(false), hbaseTable(false), dataSourceTable(false), kuduTable(false), icebergTable(false) {}
  bool hdfsTable :1;
  bool hbaseTable :1;
  bool dataSourceTable :1;
  bool kuduTable :1;
  bool icebergTable :1;
} _TTableDescriptor__isset;

class TTableDescriptor {
 public:

  TTableDescriptor(const TTableDescriptor&);
  TTableDescriptor(TTableDescriptor&&);
  TTableDescriptor& operator=(const TTableDescriptor&);
  TTableDescriptor& operator=(TTableDescriptor&&);
  TTableDescriptor() : id(0), tableType(( ::impala::TTableType::type)0), numClusteringCols(0), tableName(), dbName() {
  }

  virtual ~TTableDescriptor() throw();
   ::impala::TTableId id;
   ::impala::TTableType::type tableType;
  std::vector<TColumnDescriptor>  columnDescriptors;
  int32_t numClusteringCols;
   ::impala::THdfsTable hdfsTable;
   ::impala::THBaseTable hbaseTable;
   ::impala::TDataSourceTable dataSourceTable;
   ::impala::TKuduTable kuduTable;
   ::impala::TIcebergTable icebergTable;
  std::string tableName;
  std::string dbName;

  _TTableDescriptor__isset __isset;

  void __set_id(const  ::impala::TTableId val);

  void __set_tableType(const  ::impala::TTableType::type val);

  void __set_columnDescriptors(const std::vector<TColumnDescriptor> & val);

  void __set_numClusteringCols(const int32_t val);

  void __set_hdfsTable(const  ::impala::THdfsTable& val);

  void __set_hbaseTable(const  ::impala::THBaseTable& val);

  void __set_dataSourceTable(const  ::impala::TDataSourceTable& val);

  void __set_kuduTable(const  ::impala::TKuduTable& val);

  void __set_icebergTable(const  ::impala::TIcebergTable& val);

  void __set_tableName(const std::string& val);

  void __set_dbName(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableDescriptor &a, TTableDescriptor &b);

std::ostream& operator<<(std::ostream& out, const TTableDescriptor& obj);

typedef struct _TTupleDescriptor__isset {
  _TTupleDescriptor__isset() : tableId(false), tuplePath(false) {}
  bool tableId :1;
  bool tuplePath :1;
} _TTupleDescriptor__isset;

class TTupleDescriptor {
 public:

  TTupleDescriptor(const TTupleDescriptor&);
  TTupleDescriptor(TTupleDescriptor&&);
  TTupleDescriptor& operator=(const TTupleDescriptor&);
  TTupleDescriptor& operator=(TTupleDescriptor&&);
  TTupleDescriptor() : id(0), byteSize(0), numNullBytes(0), tableId(0) {
  }

  virtual ~TTupleDescriptor() throw();
   ::impala::TTupleId id;
  int32_t byteSize;
  int32_t numNullBytes;
   ::impala::TTableId tableId;
  std::vector<int32_t>  tuplePath;

  _TTupleDescriptor__isset __isset;

  void __set_id(const  ::impala::TTupleId val);

  void __set_byteSize(const int32_t val);

  void __set_numNullBytes(const int32_t val);

  void __set_tableId(const  ::impala::TTableId val);

  void __set_tuplePath(const std::vector<int32_t> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTupleDescriptor &a, TTupleDescriptor &b);

std::ostream& operator<<(std::ostream& out, const TTupleDescriptor& obj);

typedef struct _TDescriptorTable__isset {
  _TDescriptorTable__isset() : slotDescriptors(false), tableDescriptors(false) {}
  bool slotDescriptors :1;
  bool tableDescriptors :1;
} _TDescriptorTable__isset;

class TDescriptorTable {
 public:

  TDescriptorTable(const TDescriptorTable&);
  TDescriptorTable(TDescriptorTable&&);
  TDescriptorTable& operator=(const TDescriptorTable&);
  TDescriptorTable& operator=(TDescriptorTable&&);
  TDescriptorTable() {
  }

  virtual ~TDescriptorTable() throw();
  std::vector<TSlotDescriptor>  slotDescriptors;
  std::vector<TTupleDescriptor>  tupleDescriptors;
  std::vector<TTableDescriptor>  tableDescriptors;

  _TDescriptorTable__isset __isset;

  void __set_slotDescriptors(const std::vector<TSlotDescriptor> & val);

  void __set_tupleDescriptors(const std::vector<TTupleDescriptor> & val);

  void __set_tableDescriptors(const std::vector<TTableDescriptor> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescriptorTable &a, TDescriptorTable &b);

std::ostream& operator<<(std::ostream& out, const TDescriptorTable& obj);


class TDescriptorTableSerialized {
 public:

  TDescriptorTableSerialized(const TDescriptorTableSerialized&);
  TDescriptorTableSerialized(TDescriptorTableSerialized&&);
  TDescriptorTableSerialized& operator=(const TDescriptorTableSerialized&);
  TDescriptorTableSerialized& operator=(TDescriptorTableSerialized&&);
  TDescriptorTableSerialized() : thrift_desc_tbl() {
  }

  virtual ~TDescriptorTableSerialized() throw();
  std::string thrift_desc_tbl;

  void __set_thrift_desc_tbl(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescriptorTableSerialized &a, TDescriptorTableSerialized &b);

std::ostream& operator<<(std::ostream& out, const TDescriptorTableSerialized& obj);

} // namespace

#include "Descriptors_types.tcc"

#endif
