/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef JniCatalog_TYPES_H
#define JniCatalog_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "CatalogObjects_types.h"
#include "Types_types.h"
#include "Status_types.h"
#include "TCLIService_types.h"
#include "hive_metastore_types.h"


namespace impala {

struct TDdlType {
  enum type {
    ALTER_TABLE = 0,
    ALTER_VIEW = 1,
    CREATE_DATABASE = 2,
    CREATE_TABLE = 3,
    CREATE_TABLE_AS_SELECT = 4,
    CREATE_TABLE_LIKE = 5,
    CREATE_VIEW = 6,
    CREATE_FUNCTION = 7,
    COMPUTE_STATS = 8,
    DROP_DATABASE = 9,
    DROP_TABLE = 10,
    DROP_VIEW = 11,
    DROP_FUNCTION = 12,
    CREATE_DATA_SOURCE = 13,
    DROP_DATA_SOURCE = 14,
    DROP_STATS = 15,
    CREATE_ROLE = 16,
    DROP_ROLE = 17,
    GRANT_ROLE = 18,
    REVOKE_ROLE = 19,
    GRANT_PRIVILEGE = 20,
    REVOKE_PRIVILEGE = 21,
    TRUNCATE_TABLE = 22,
    COMMENT_ON = 23,
    ALTER_DATABASE = 24,
    COPY_TESTCASE = 25
  };
};

extern const std::map<int, const char*> _TDdlType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TDdlType::type& val);

struct TOwnerType {
  enum type {
    USER = 0,
    ROLE = 1
  };
};

extern const std::map<int, const char*> _TOwnerType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TOwnerType::type& val);

struct TAlterDbType {
  enum type {
    SET_OWNER = 0
  };
};

extern const std::map<int, const char*> _TAlterDbType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAlterDbType::type& val);

struct TAlterTableType {
  enum type {
    ADD_COLUMNS = 0,
    REPLACE_COLUMNS = 1,
    ADD_PARTITION = 2,
    ADD_DROP_RANGE_PARTITION = 3,
    ALTER_COLUMN = 4,
    DROP_COLUMN = 5,
    DROP_PARTITION = 6,
    RENAME_TABLE = 7,
    RENAME_VIEW = 8,
    SET_FILE_FORMAT = 9,
    SET_LOCATION = 10,
    SET_TBL_PROPERTIES = 11,
    UPDATE_STATS = 12,
    SET_CACHED = 13,
    RECOVER_PARTITIONS = 14,
    SET_ROW_FORMAT = 15,
    SET_OWNER = 16,
    UNSET_TBL_PROPERTIES = 17,
    SET_PARTITION_SPEC = 18
  };
};

extern const std::map<int, const char*> _TAlterTableType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAlterTableType::type& val);

struct TRangePartitionOperationType {
  enum type {
    ADD = 0,
    DROP = 1
  };
};

extern const std::map<int, const char*> _TRangePartitionOperationType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRangePartitionOperationType::type& val);

class TAlterDbSetOwnerParams;

class TAlterDbParams;

class TCreateDbParams;

class TCreateDataSourceParams;

class TDropDataSourceParams;

class TDropStatsParams;

class TCreateFunctionParams;

class TTableRowFormat;

class THdfsCachingOp;

class TAlterTableOrViewRenameParams;

class TAlterTableAddColsParams;

class TAlterTableReplaceColsParams;

class TPartitionDef;

class TAlterTableAddPartitionParams;

class TAlterTableAddDropRangePartitionParams;

class TAlterTableDropColParams;

class TAlterTableDropPartitionParams;

class TAlterTableAlterColParams;

class TAlterTableSetTblPropertiesParams;

class TAlterTableSetFileFormatParams;

class TAlterTableSetRowFormatParams;

class TAlterTableSetLocationParams;

class TAlterTableOrViewSetOwnerParams;

class TAlterTableUpdateStatsParams;

class TAlterTableSetCachedParams;

class TAlterTableUnSetTblPropertiesParams;

class TAlterTableSetPartitionSpecParams;

class TAlterTableParams;

class TCreateTableLikeParams;

class TCreateTableParams;

class TCreateOrAlterViewParams;

class TComputeStatsParams;

class TCreateDropRoleParams;

class TGrantRevokeRoleParams;

class TGrantRevokePrivParams;

class TDropDbParams;

class TDropTableOrViewParams;

class TTruncateParams;

class TDropFunctionParams;

class TTableUsageMetrics;

class TGetCatalogUsageResponse;

class TOperationUsageCounter;

class TGetOperationUsageResponse;

class TColumnName;

class TCommentOnParams;

class TEventProcessorMetrics;

class TCatalogHmsCacheApiMetrics;

class TCatalogdHmsCacheMetrics;

class TGetCatalogServerMetricsResponse;

class TCopyTestCaseReq;

class TEventProcessorMetricsSummaryResponse;

typedef struct _TAlterDbSetOwnerParams__isset {
  _TAlterDbSetOwnerParams__isset() : server_name(false) {}
  bool server_name :1;
} _TAlterDbSetOwnerParams__isset;

class TAlterDbSetOwnerParams {
 public:

  TAlterDbSetOwnerParams(const TAlterDbSetOwnerParams&);
  TAlterDbSetOwnerParams(TAlterDbSetOwnerParams&&);
  TAlterDbSetOwnerParams& operator=(const TAlterDbSetOwnerParams&);
  TAlterDbSetOwnerParams& operator=(TAlterDbSetOwnerParams&&);
  TAlterDbSetOwnerParams() : owner_type((TOwnerType::type)0), owner_name(), server_name() {
  }

  virtual ~TAlterDbSetOwnerParams() throw();
  TOwnerType::type owner_type;
  std::string owner_name;
  std::string server_name;

  _TAlterDbSetOwnerParams__isset __isset;

  void __set_owner_type(const TOwnerType::type val);

  void __set_owner_name(const std::string& val);

  void __set_server_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterDbSetOwnerParams &a, TAlterDbSetOwnerParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterDbSetOwnerParams& obj);

typedef struct _TAlterDbParams__isset {
  _TAlterDbParams__isset() : set_owner_params(false) {}
  bool set_owner_params :1;
} _TAlterDbParams__isset;

class TAlterDbParams {
 public:

  TAlterDbParams(const TAlterDbParams&);
  TAlterDbParams(TAlterDbParams&&);
  TAlterDbParams& operator=(const TAlterDbParams&);
  TAlterDbParams& operator=(TAlterDbParams&&);
  TAlterDbParams() : alter_type((TAlterDbType::type)0), db() {
  }

  virtual ~TAlterDbParams() throw();
  TAlterDbType::type alter_type;
  std::string db;
  TAlterDbSetOwnerParams set_owner_params;

  _TAlterDbParams__isset __isset;

  void __set_alter_type(const TAlterDbType::type val);

  void __set_db(const std::string& val);

  void __set_set_owner_params(const TAlterDbSetOwnerParams& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterDbParams &a, TAlterDbParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterDbParams& obj);

typedef struct _TCreateDbParams__isset {
  _TCreateDbParams__isset() : comment(false), location(false), if_not_exists(false), server_name(false), managed_location(false) {}
  bool comment :1;
  bool location :1;
  bool if_not_exists :1;
  bool server_name :1;
  bool managed_location :1;
} _TCreateDbParams__isset;

class TCreateDbParams {
 public:

  TCreateDbParams(const TCreateDbParams&);
  TCreateDbParams(TCreateDbParams&&);
  TCreateDbParams& operator=(const TCreateDbParams&);
  TCreateDbParams& operator=(TCreateDbParams&&);
  TCreateDbParams() : db(), comment(), location(), if_not_exists(0), owner(), server_name(), managed_location() {
  }

  virtual ~TCreateDbParams() throw();
  std::string db;
  std::string comment;
  std::string location;
  bool if_not_exists;
  std::string owner;
  std::string server_name;
  std::string managed_location;

  _TCreateDbParams__isset __isset;

  void __set_db(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_location(const std::string& val);

  void __set_if_not_exists(const bool val);

  void __set_owner(const std::string& val);

  void __set_server_name(const std::string& val);

  void __set_managed_location(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateDbParams &a, TCreateDbParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateDbParams& obj);

typedef struct _TCreateDataSourceParams__isset {
  _TCreateDataSourceParams__isset() : if_not_exists(false) {}
  bool if_not_exists :1;
} _TCreateDataSourceParams__isset;

class TCreateDataSourceParams {
 public:

  TCreateDataSourceParams(const TCreateDataSourceParams&);
  TCreateDataSourceParams(TCreateDataSourceParams&&);
  TCreateDataSourceParams& operator=(const TCreateDataSourceParams&);
  TCreateDataSourceParams& operator=(TCreateDataSourceParams&&);
  TCreateDataSourceParams() : if_not_exists(0) {
  }

  virtual ~TCreateDataSourceParams() throw();
   ::impala::TDataSource data_source;
  bool if_not_exists;

  _TCreateDataSourceParams__isset __isset;

  void __set_data_source(const  ::impala::TDataSource& val);

  void __set_if_not_exists(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateDataSourceParams &a, TCreateDataSourceParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateDataSourceParams& obj);

typedef struct _TDropDataSourceParams__isset {
  _TDropDataSourceParams__isset() : if_exists(false) {}
  bool if_exists :1;
} _TDropDataSourceParams__isset;

class TDropDataSourceParams {
 public:

  TDropDataSourceParams(const TDropDataSourceParams&);
  TDropDataSourceParams(TDropDataSourceParams&&);
  TDropDataSourceParams& operator=(const TDropDataSourceParams&);
  TDropDataSourceParams& operator=(TDropDataSourceParams&&);
  TDropDataSourceParams() : data_source(), if_exists(0) {
  }

  virtual ~TDropDataSourceParams() throw();
  std::string data_source;
  bool if_exists;

  _TDropDataSourceParams__isset __isset;

  void __set_data_source(const std::string& val);

  void __set_if_exists(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropDataSourceParams &a, TDropDataSourceParams &b);

std::ostream& operator<<(std::ostream& out, const TDropDataSourceParams& obj);

typedef struct _TDropStatsParams__isset {
  _TDropStatsParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TDropStatsParams__isset;

class TDropStatsParams {
 public:

  TDropStatsParams(const TDropStatsParams&);
  TDropStatsParams(TDropStatsParams&&);
  TDropStatsParams& operator=(const TDropStatsParams&);
  TDropStatsParams& operator=(TDropStatsParams&&);
  TDropStatsParams() {
  }

  virtual ~TDropStatsParams() throw();
   ::impala::TTableName table_name;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TDropStatsParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropStatsParams &a, TDropStatsParams &b);

std::ostream& operator<<(std::ostream& out, const TDropStatsParams& obj);

typedef struct _TCreateFunctionParams__isset {
  _TCreateFunctionParams__isset() : if_not_exists(false) {}
  bool if_not_exists :1;
} _TCreateFunctionParams__isset;

class TCreateFunctionParams {
 public:

  TCreateFunctionParams(const TCreateFunctionParams&);
  TCreateFunctionParams(TCreateFunctionParams&&);
  TCreateFunctionParams& operator=(const TCreateFunctionParams&);
  TCreateFunctionParams& operator=(TCreateFunctionParams&&);
  TCreateFunctionParams() : if_not_exists(0) {
  }

  virtual ~TCreateFunctionParams() throw();
   ::impala::TFunction fn;
  bool if_not_exists;

  _TCreateFunctionParams__isset __isset;

  void __set_fn(const  ::impala::TFunction& val);

  void __set_if_not_exists(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateFunctionParams &a, TCreateFunctionParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateFunctionParams& obj);

typedef struct _TTableRowFormat__isset {
  _TTableRowFormat__isset() : field_terminator(false), line_terminator(false), escaped_by(false) {}
  bool field_terminator :1;
  bool line_terminator :1;
  bool escaped_by :1;
} _TTableRowFormat__isset;

class TTableRowFormat {
 public:

  TTableRowFormat(const TTableRowFormat&);
  TTableRowFormat(TTableRowFormat&&);
  TTableRowFormat& operator=(const TTableRowFormat&);
  TTableRowFormat& operator=(TTableRowFormat&&);
  TTableRowFormat() : field_terminator(), line_terminator(), escaped_by() {
  }

  virtual ~TTableRowFormat() throw();
  std::string field_terminator;
  std::string line_terminator;
  std::string escaped_by;

  _TTableRowFormat__isset __isset;

  void __set_field_terminator(const std::string& val);

  void __set_line_terminator(const std::string& val);

  void __set_escaped_by(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableRowFormat &a, TTableRowFormat &b);

std::ostream& operator<<(std::ostream& out, const TTableRowFormat& obj);

typedef struct _THdfsCachingOp__isset {
  _THdfsCachingOp__isset() : cache_pool_name(false), replication(false) {}
  bool cache_pool_name :1;
  bool replication :1;
} _THdfsCachingOp__isset;

class THdfsCachingOp {
 public:

  THdfsCachingOp(const THdfsCachingOp&);
  THdfsCachingOp(THdfsCachingOp&&);
  THdfsCachingOp& operator=(const THdfsCachingOp&);
  THdfsCachingOp& operator=(THdfsCachingOp&&);
  THdfsCachingOp() : set_cached(0), cache_pool_name(), replication(0) {
  }

  virtual ~THdfsCachingOp() throw();
  bool set_cached;
  std::string cache_pool_name;
  int16_t replication;

  _THdfsCachingOp__isset __isset;

  void __set_set_cached(const bool val);

  void __set_cache_pool_name(const std::string& val);

  void __set_replication(const int16_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsCachingOp &a, THdfsCachingOp &b);

std::ostream& operator<<(std::ostream& out, const THdfsCachingOp& obj);


class TAlterTableOrViewRenameParams {
 public:

  TAlterTableOrViewRenameParams(const TAlterTableOrViewRenameParams&);
  TAlterTableOrViewRenameParams(TAlterTableOrViewRenameParams&&);
  TAlterTableOrViewRenameParams& operator=(const TAlterTableOrViewRenameParams&);
  TAlterTableOrViewRenameParams& operator=(TAlterTableOrViewRenameParams&&);
  TAlterTableOrViewRenameParams() {
  }

  virtual ~TAlterTableOrViewRenameParams() throw();
   ::impala::TTableName new_table_name;

  void __set_new_table_name(const  ::impala::TTableName& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableOrViewRenameParams &a, TAlterTableOrViewRenameParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableOrViewRenameParams& obj);


class TAlterTableAddColsParams {
 public:

  TAlterTableAddColsParams(const TAlterTableAddColsParams&);
  TAlterTableAddColsParams(TAlterTableAddColsParams&&);
  TAlterTableAddColsParams& operator=(const TAlterTableAddColsParams&);
  TAlterTableAddColsParams& operator=(TAlterTableAddColsParams&&);
  TAlterTableAddColsParams() : if_not_exists(0) {
  }

  virtual ~TAlterTableAddColsParams() throw();
  std::vector< ::impala::TColumn>  columns;
  bool if_not_exists;

  void __set_columns(const std::vector< ::impala::TColumn> & val);

  void __set_if_not_exists(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableAddColsParams &a, TAlterTableAddColsParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableAddColsParams& obj);


class TAlterTableReplaceColsParams {
 public:

  TAlterTableReplaceColsParams(const TAlterTableReplaceColsParams&);
  TAlterTableReplaceColsParams(TAlterTableReplaceColsParams&&);
  TAlterTableReplaceColsParams& operator=(const TAlterTableReplaceColsParams&);
  TAlterTableReplaceColsParams& operator=(TAlterTableReplaceColsParams&&);
  TAlterTableReplaceColsParams() {
  }

  virtual ~TAlterTableReplaceColsParams() throw();
  std::vector< ::impala::TColumn>  columns;

  void __set_columns(const std::vector< ::impala::TColumn> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableReplaceColsParams &a, TAlterTableReplaceColsParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableReplaceColsParams& obj);

typedef struct _TPartitionDef__isset {
  _TPartitionDef__isset() : location(false), cache_op(false) {}
  bool location :1;
  bool cache_op :1;
} _TPartitionDef__isset;

class TPartitionDef {
 public:

  TPartitionDef(const TPartitionDef&);
  TPartitionDef(TPartitionDef&&);
  TPartitionDef& operator=(const TPartitionDef&);
  TPartitionDef& operator=(TPartitionDef&&);
  TPartitionDef() : location() {
  }

  virtual ~TPartitionDef() throw();
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;
  std::string location;
  THdfsCachingOp cache_op;

  _TPartitionDef__isset __isset;

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val);

  void __set_location(const std::string& val);

  void __set_cache_op(const THdfsCachingOp& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartitionDef &a, TPartitionDef &b);

std::ostream& operator<<(std::ostream& out, const TPartitionDef& obj);


class TAlterTableAddPartitionParams {
 public:

  TAlterTableAddPartitionParams(const TAlterTableAddPartitionParams&);
  TAlterTableAddPartitionParams(TAlterTableAddPartitionParams&&);
  TAlterTableAddPartitionParams& operator=(const TAlterTableAddPartitionParams&);
  TAlterTableAddPartitionParams& operator=(TAlterTableAddPartitionParams&&);
  TAlterTableAddPartitionParams() : if_not_exists(0) {
  }

  virtual ~TAlterTableAddPartitionParams() throw();
  bool if_not_exists;
  std::vector<TPartitionDef>  partitions;

  void __set_if_not_exists(const bool val);

  void __set_partitions(const std::vector<TPartitionDef> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableAddPartitionParams &a, TAlterTableAddPartitionParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableAddPartitionParams& obj);


class TAlterTableAddDropRangePartitionParams {
 public:

  TAlterTableAddDropRangePartitionParams(const TAlterTableAddDropRangePartitionParams&);
  TAlterTableAddDropRangePartitionParams(TAlterTableAddDropRangePartitionParams&&);
  TAlterTableAddDropRangePartitionParams& operator=(const TAlterTableAddDropRangePartitionParams&);
  TAlterTableAddDropRangePartitionParams& operator=(TAlterTableAddDropRangePartitionParams&&);
  TAlterTableAddDropRangePartitionParams() : ignore_errors(0), type((TRangePartitionOperationType::type)0) {
  }

  virtual ~TAlterTableAddDropRangePartitionParams() throw();
   ::impala::TRangePartition range_partition_spec;
  bool ignore_errors;
  TRangePartitionOperationType::type type;

  void __set_range_partition_spec(const  ::impala::TRangePartition& val);

  void __set_ignore_errors(const bool val);

  void __set_type(const TRangePartitionOperationType::type val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableAddDropRangePartitionParams &a, TAlterTableAddDropRangePartitionParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableAddDropRangePartitionParams& obj);


class TAlterTableDropColParams {
 public:

  TAlterTableDropColParams(const TAlterTableDropColParams&);
  TAlterTableDropColParams(TAlterTableDropColParams&&);
  TAlterTableDropColParams& operator=(const TAlterTableDropColParams&);
  TAlterTableDropColParams& operator=(TAlterTableDropColParams&&);
  TAlterTableDropColParams() : col_name() {
  }

  virtual ~TAlterTableDropColParams() throw();
  std::string col_name;

  void __set_col_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableDropColParams &a, TAlterTableDropColParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableDropColParams& obj);


class TAlterTableDropPartitionParams {
 public:

  TAlterTableDropPartitionParams(const TAlterTableDropPartitionParams&);
  TAlterTableDropPartitionParams(TAlterTableDropPartitionParams&&);
  TAlterTableDropPartitionParams& operator=(const TAlterTableDropPartitionParams&);
  TAlterTableDropPartitionParams& operator=(TAlterTableDropPartitionParams&&);
  TAlterTableDropPartitionParams() : if_exists(0), purge(0) {
  }

  virtual ~TAlterTableDropPartitionParams() throw();
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;
  bool if_exists;
  bool purge;

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  void __set_if_exists(const bool val);

  void __set_purge(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableDropPartitionParams &a, TAlterTableDropPartitionParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableDropPartitionParams& obj);


class TAlterTableAlterColParams {
 public:

  TAlterTableAlterColParams(const TAlterTableAlterColParams&);
  TAlterTableAlterColParams(TAlterTableAlterColParams&&);
  TAlterTableAlterColParams& operator=(const TAlterTableAlterColParams&);
  TAlterTableAlterColParams& operator=(TAlterTableAlterColParams&&);
  TAlterTableAlterColParams() : col_name() {
  }

  virtual ~TAlterTableAlterColParams() throw();
  std::string col_name;
   ::impala::TColumn new_col_def;

  void __set_col_name(const std::string& val);

  void __set_new_col_def(const  ::impala::TColumn& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableAlterColParams &a, TAlterTableAlterColParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableAlterColParams& obj);

typedef struct _TAlterTableSetTblPropertiesParams__isset {
  _TAlterTableSetTblPropertiesParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TAlterTableSetTblPropertiesParams__isset;

class TAlterTableSetTblPropertiesParams {
 public:

  TAlterTableSetTblPropertiesParams(const TAlterTableSetTblPropertiesParams&);
  TAlterTableSetTblPropertiesParams(TAlterTableSetTblPropertiesParams&&);
  TAlterTableSetTblPropertiesParams& operator=(const TAlterTableSetTblPropertiesParams&);
  TAlterTableSetTblPropertiesParams& operator=(TAlterTableSetTblPropertiesParams&&);
  TAlterTableSetTblPropertiesParams() : target(( ::impala::TTablePropertyType::type)0) {
  }

  virtual ~TAlterTableSetTblPropertiesParams() throw();
   ::impala::TTablePropertyType::type target;
  std::map<std::string, std::string>  properties;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TAlterTableSetTblPropertiesParams__isset __isset;

  void __set_target(const  ::impala::TTablePropertyType::type val);

  void __set_properties(const std::map<std::string, std::string> & val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableSetTblPropertiesParams &a, TAlterTableSetTblPropertiesParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableSetTblPropertiesParams& obj);

typedef struct _TAlterTableSetFileFormatParams__isset {
  _TAlterTableSetFileFormatParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TAlterTableSetFileFormatParams__isset;

class TAlterTableSetFileFormatParams {
 public:

  TAlterTableSetFileFormatParams(const TAlterTableSetFileFormatParams&);
  TAlterTableSetFileFormatParams(TAlterTableSetFileFormatParams&&);
  TAlterTableSetFileFormatParams& operator=(const TAlterTableSetFileFormatParams&);
  TAlterTableSetFileFormatParams& operator=(TAlterTableSetFileFormatParams&&);
  TAlterTableSetFileFormatParams() : file_format(( ::impala::THdfsFileFormat::type)0) {
  }

  virtual ~TAlterTableSetFileFormatParams() throw();
   ::impala::THdfsFileFormat::type file_format;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TAlterTableSetFileFormatParams__isset __isset;

  void __set_file_format(const  ::impala::THdfsFileFormat::type val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableSetFileFormatParams &a, TAlterTableSetFileFormatParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableSetFileFormatParams& obj);

typedef struct _TAlterTableSetRowFormatParams__isset {
  _TAlterTableSetRowFormatParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TAlterTableSetRowFormatParams__isset;

class TAlterTableSetRowFormatParams {
 public:

  TAlterTableSetRowFormatParams(const TAlterTableSetRowFormatParams&);
  TAlterTableSetRowFormatParams(TAlterTableSetRowFormatParams&&);
  TAlterTableSetRowFormatParams& operator=(const TAlterTableSetRowFormatParams&);
  TAlterTableSetRowFormatParams& operator=(TAlterTableSetRowFormatParams&&);
  TAlterTableSetRowFormatParams() {
  }

  virtual ~TAlterTableSetRowFormatParams() throw();
  TTableRowFormat row_format;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TAlterTableSetRowFormatParams__isset __isset;

  void __set_row_format(const TTableRowFormat& val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableSetRowFormatParams &a, TAlterTableSetRowFormatParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableSetRowFormatParams& obj);

typedef struct _TAlterTableSetLocationParams__isset {
  _TAlterTableSetLocationParams__isset() : partition_spec(false) {}
  bool partition_spec :1;
} _TAlterTableSetLocationParams__isset;

class TAlterTableSetLocationParams {
 public:

  TAlterTableSetLocationParams(const TAlterTableSetLocationParams&);
  TAlterTableSetLocationParams(TAlterTableSetLocationParams&&);
  TAlterTableSetLocationParams& operator=(const TAlterTableSetLocationParams&);
  TAlterTableSetLocationParams& operator=(TAlterTableSetLocationParams&&);
  TAlterTableSetLocationParams() : location() {
  }

  virtual ~TAlterTableSetLocationParams() throw();
  std::string location;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TAlterTableSetLocationParams__isset __isset;

  void __set_location(const std::string& val);

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableSetLocationParams &a, TAlterTableSetLocationParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableSetLocationParams& obj);

typedef struct _TAlterTableOrViewSetOwnerParams__isset {
  _TAlterTableOrViewSetOwnerParams__isset() : server_name(false) {}
  bool server_name :1;
} _TAlterTableOrViewSetOwnerParams__isset;

class TAlterTableOrViewSetOwnerParams {
 public:

  TAlterTableOrViewSetOwnerParams(const TAlterTableOrViewSetOwnerParams&);
  TAlterTableOrViewSetOwnerParams(TAlterTableOrViewSetOwnerParams&&);
  TAlterTableOrViewSetOwnerParams& operator=(const TAlterTableOrViewSetOwnerParams&);
  TAlterTableOrViewSetOwnerParams& operator=(TAlterTableOrViewSetOwnerParams&&);
  TAlterTableOrViewSetOwnerParams() : owner_type((TOwnerType::type)0), owner_name(), server_name() {
  }

  virtual ~TAlterTableOrViewSetOwnerParams() throw();
  TOwnerType::type owner_type;
  std::string owner_name;
  std::string server_name;

  _TAlterTableOrViewSetOwnerParams__isset __isset;

  void __set_owner_type(const TOwnerType::type val);

  void __set_owner_name(const std::string& val);

  void __set_server_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableOrViewSetOwnerParams &a, TAlterTableOrViewSetOwnerParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableOrViewSetOwnerParams& obj);

typedef struct _TAlterTableUpdateStatsParams__isset {
  _TAlterTableUpdateStatsParams__isset() : table_stats(false), partition_stats(false), column_stats(false), expect_all_partitions(false), is_incremental(false) {}
  bool table_stats :1;
  bool partition_stats :1;
  bool column_stats :1;
  bool expect_all_partitions :1;
  bool is_incremental :1;
} _TAlterTableUpdateStatsParams__isset;

class TAlterTableUpdateStatsParams {
 public:

  TAlterTableUpdateStatsParams(const TAlterTableUpdateStatsParams&);
  TAlterTableUpdateStatsParams(TAlterTableUpdateStatsParams&&);
  TAlterTableUpdateStatsParams& operator=(const TAlterTableUpdateStatsParams&);
  TAlterTableUpdateStatsParams& operator=(TAlterTableUpdateStatsParams&&);
  TAlterTableUpdateStatsParams() : expect_all_partitions(0), is_incremental(0) {
  }

  virtual ~TAlterTableUpdateStatsParams() throw();
   ::impala::TTableName table_name;
   ::impala::TTableStats table_stats;
  std::map<std::vector<std::string> ,  ::impala::TPartitionStats>  partition_stats;
  std::map<std::string,  ::impala::TColumnStats>  column_stats;
  bool expect_all_partitions;
  bool is_incremental;

  _TAlterTableUpdateStatsParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_table_stats(const  ::impala::TTableStats& val);

  void __set_partition_stats(const std::map<std::vector<std::string> ,  ::impala::TPartitionStats> & val);

  void __set_column_stats(const std::map<std::string,  ::impala::TColumnStats> & val);

  void __set_expect_all_partitions(const bool val);

  void __set_is_incremental(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableUpdateStatsParams &a, TAlterTableUpdateStatsParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableUpdateStatsParams& obj);

typedef struct _TAlterTableSetCachedParams__isset {
  _TAlterTableSetCachedParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TAlterTableSetCachedParams__isset;

class TAlterTableSetCachedParams {
 public:

  TAlterTableSetCachedParams(const TAlterTableSetCachedParams&);
  TAlterTableSetCachedParams(TAlterTableSetCachedParams&&);
  TAlterTableSetCachedParams& operator=(const TAlterTableSetCachedParams&);
  TAlterTableSetCachedParams& operator=(TAlterTableSetCachedParams&&);
  TAlterTableSetCachedParams() {
  }

  virtual ~TAlterTableSetCachedParams() throw();
  THdfsCachingOp cache_op;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TAlterTableSetCachedParams__isset __isset;

  void __set_cache_op(const THdfsCachingOp& val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableSetCachedParams &a, TAlterTableSetCachedParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableSetCachedParams& obj);

typedef struct _TAlterTableUnSetTblPropertiesParams__isset {
  _TAlterTableUnSetTblPropertiesParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TAlterTableUnSetTblPropertiesParams__isset;

class TAlterTableUnSetTblPropertiesParams {
 public:

  TAlterTableUnSetTblPropertiesParams(const TAlterTableUnSetTblPropertiesParams&);
  TAlterTableUnSetTblPropertiesParams(TAlterTableUnSetTblPropertiesParams&&);
  TAlterTableUnSetTblPropertiesParams& operator=(const TAlterTableUnSetTblPropertiesParams&);
  TAlterTableUnSetTblPropertiesParams& operator=(TAlterTableUnSetTblPropertiesParams&&);
  TAlterTableUnSetTblPropertiesParams() : target(( ::impala::TTablePropertyType::type)0), if_exists(0) {
  }

  virtual ~TAlterTableUnSetTblPropertiesParams() throw();
   ::impala::TTablePropertyType::type target;
  std::vector<std::string>  property_keys;
  bool if_exists;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TAlterTableUnSetTblPropertiesParams__isset __isset;

  void __set_target(const  ::impala::TTablePropertyType::type val);

  void __set_property_keys(const std::vector<std::string> & val);

  void __set_if_exists(const bool val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableUnSetTblPropertiesParams &a, TAlterTableUnSetTblPropertiesParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableUnSetTblPropertiesParams& obj);


class TAlterTableSetPartitionSpecParams {
 public:

  TAlterTableSetPartitionSpecParams(const TAlterTableSetPartitionSpecParams&);
  TAlterTableSetPartitionSpecParams(TAlterTableSetPartitionSpecParams&&);
  TAlterTableSetPartitionSpecParams& operator=(const TAlterTableSetPartitionSpecParams&);
  TAlterTableSetPartitionSpecParams& operator=(TAlterTableSetPartitionSpecParams&&);
  TAlterTableSetPartitionSpecParams() {
  }

  virtual ~TAlterTableSetPartitionSpecParams() throw();
   ::impala::TIcebergPartitionSpec partition_spec;

  void __set_partition_spec(const  ::impala::TIcebergPartitionSpec& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableSetPartitionSpecParams &a, TAlterTableSetPartitionSpecParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableSetPartitionSpecParams& obj);

typedef struct _TAlterTableParams__isset {
  _TAlterTableParams__isset() : rename_params(false), add_cols_params(false), add_partition_params(false), alter_col_params(false), drop_col_params(false), drop_partition_params(false), set_file_format_params(false), set_location_params(false), set_tbl_properties_params(false), update_stats_params(false), set_cached_params(false), add_drop_range_partition_params(false), set_row_format_params(false), set_owner_params(false), replace_cols_params(false), unset_tbl_properties_params(false), set_partition_spec_params(false) {}
  bool rename_params :1;
  bool add_cols_params :1;
  bool add_partition_params :1;
  bool alter_col_params :1;
  bool drop_col_params :1;
  bool drop_partition_params :1;
  bool set_file_format_params :1;
  bool set_location_params :1;
  bool set_tbl_properties_params :1;
  bool update_stats_params :1;
  bool set_cached_params :1;
  bool add_drop_range_partition_params :1;
  bool set_row_format_params :1;
  bool set_owner_params :1;
  bool replace_cols_params :1;
  bool unset_tbl_properties_params :1;
  bool set_partition_spec_params :1;
} _TAlterTableParams__isset;

class TAlterTableParams {
 public:

  TAlterTableParams(const TAlterTableParams&);
  TAlterTableParams(TAlterTableParams&&);
  TAlterTableParams& operator=(const TAlterTableParams&);
  TAlterTableParams& operator=(TAlterTableParams&&);
  TAlterTableParams() : alter_type((TAlterTableType::type)0) {
  }

  virtual ~TAlterTableParams() throw();
  TAlterTableType::type alter_type;
   ::impala::TTableName table_name;
  TAlterTableOrViewRenameParams rename_params;
  TAlterTableAddColsParams add_cols_params;
  TAlterTableAddPartitionParams add_partition_params;
  TAlterTableAlterColParams alter_col_params;
  TAlterTableDropColParams drop_col_params;
  TAlterTableDropPartitionParams drop_partition_params;
  TAlterTableSetFileFormatParams set_file_format_params;
  TAlterTableSetLocationParams set_location_params;
  TAlterTableSetTblPropertiesParams set_tbl_properties_params;
  TAlterTableUpdateStatsParams update_stats_params;
  TAlterTableSetCachedParams set_cached_params;
  TAlterTableAddDropRangePartitionParams add_drop_range_partition_params;
  TAlterTableSetRowFormatParams set_row_format_params;
  TAlterTableOrViewSetOwnerParams set_owner_params;
  TAlterTableReplaceColsParams replace_cols_params;
  TAlterTableUnSetTblPropertiesParams unset_tbl_properties_params;
  TAlterTableSetPartitionSpecParams set_partition_spec_params;

  _TAlterTableParams__isset __isset;

  void __set_alter_type(const TAlterTableType::type val);

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_rename_params(const TAlterTableOrViewRenameParams& val);

  void __set_add_cols_params(const TAlterTableAddColsParams& val);

  void __set_add_partition_params(const TAlterTableAddPartitionParams& val);

  void __set_alter_col_params(const TAlterTableAlterColParams& val);

  void __set_drop_col_params(const TAlterTableDropColParams& val);

  void __set_drop_partition_params(const TAlterTableDropPartitionParams& val);

  void __set_set_file_format_params(const TAlterTableSetFileFormatParams& val);

  void __set_set_location_params(const TAlterTableSetLocationParams& val);

  void __set_set_tbl_properties_params(const TAlterTableSetTblPropertiesParams& val);

  void __set_update_stats_params(const TAlterTableUpdateStatsParams& val);

  void __set_set_cached_params(const TAlterTableSetCachedParams& val);

  void __set_add_drop_range_partition_params(const TAlterTableAddDropRangePartitionParams& val);

  void __set_set_row_format_params(const TAlterTableSetRowFormatParams& val);

  void __set_set_owner_params(const TAlterTableOrViewSetOwnerParams& val);

  void __set_replace_cols_params(const TAlterTableReplaceColsParams& val);

  void __set_unset_tbl_properties_params(const TAlterTableUnSetTblPropertiesParams& val);

  void __set_set_partition_spec_params(const TAlterTableSetPartitionSpecParams& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAlterTableParams &a, TAlterTableParams &b);

std::ostream& operator<<(std::ostream& out, const TAlterTableParams& obj);

typedef struct _TCreateTableLikeParams__isset {
  _TCreateTableLikeParams__isset() : file_format(false), comment(false), location(false), sort_columns(false), server_name(false) {}
  bool file_format :1;
  bool comment :1;
  bool location :1;
  bool sort_columns :1;
  bool server_name :1;
} _TCreateTableLikeParams__isset;

class TCreateTableLikeParams {
 public:

  TCreateTableLikeParams(const TCreateTableLikeParams&);
  TCreateTableLikeParams(TCreateTableLikeParams&&);
  TCreateTableLikeParams& operator=(const TCreateTableLikeParams&);
  TCreateTableLikeParams& operator=(TCreateTableLikeParams&&);
  TCreateTableLikeParams() : is_external(0), if_not_exists(0), owner(), file_format(( ::impala::THdfsFileFormat::type)0), comment(), location(), server_name(), sorting_order(( ::impala::TSortingOrder::type)0) {
  }

  virtual ~TCreateTableLikeParams() throw();
   ::impala::TTableName table_name;
   ::impala::TTableName src_table_name;
  bool is_external;
  bool if_not_exists;
  std::string owner;
   ::impala::THdfsFileFormat::type file_format;
  std::string comment;
  std::string location;
  std::vector<std::string>  sort_columns;
  std::string server_name;
   ::impala::TSortingOrder::type sorting_order;

  _TCreateTableLikeParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_src_table_name(const  ::impala::TTableName& val);

  void __set_is_external(const bool val);

  void __set_if_not_exists(const bool val);

  void __set_owner(const std::string& val);

  void __set_file_format(const  ::impala::THdfsFileFormat::type val);

  void __set_comment(const std::string& val);

  void __set_location(const std::string& val);

  void __set_sort_columns(const std::vector<std::string> & val);

  void __set_server_name(const std::string& val);

  void __set_sorting_order(const  ::impala::TSortingOrder::type val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateTableLikeParams &a, TCreateTableLikeParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateTableLikeParams& obj);

typedef struct _TCreateTableParams__isset {
  _TCreateTableParams__isset() : partition_columns(false), row_format(false), comment(false), location(false), table_properties(false), serde_properties(false), cache_op(false), partition_by(false), primary_key_column_names(false), sort_columns(false), server_name(false), primary_keys(false), foreign_keys(false), partition_spec(false) {}
  bool partition_columns :1;
  bool row_format :1;
  bool comment :1;
  bool location :1;
  bool table_properties :1;
  bool serde_properties :1;
  bool cache_op :1;
  bool partition_by :1;
  bool primary_key_column_names :1;
  bool sort_columns :1;
  bool server_name :1;
  bool primary_keys :1;
  bool foreign_keys :1;
  bool partition_spec :1;
} _TCreateTableParams__isset;

class TCreateTableParams {
 public:

  TCreateTableParams(const TCreateTableParams&);
  TCreateTableParams(TCreateTableParams&&);
  TCreateTableParams& operator=(const TCreateTableParams&);
  TCreateTableParams& operator=(TCreateTableParams&&);
  TCreateTableParams() : file_format(( ::impala::THdfsFileFormat::type)0), is_external(0), if_not_exists(0), owner(), comment(), location(), server_name(), sorting_order(( ::impala::TSortingOrder::type)0) {
  }

  virtual ~TCreateTableParams() throw();
   ::impala::TTableName table_name;
  std::vector< ::impala::TColumn>  columns;
  std::vector< ::impala::TColumn>  partition_columns;
   ::impala::THdfsFileFormat::type file_format;
  bool is_external;
  bool if_not_exists;
  std::string owner;
  TTableRowFormat row_format;
  std::string comment;
  std::string location;
  std::map<std::string, std::string>  table_properties;
  std::map<std::string, std::string>  serde_properties;
  THdfsCachingOp cache_op;
  std::vector< ::impala::TKuduPartitionParam>  partition_by;
  std::vector<std::string>  primary_key_column_names;
  std::vector<std::string>  sort_columns;
  std::string server_name;
   ::impala::TSortingOrder::type sorting_order;
  std::vector< ::Apache::Hadoop::Hive::SQLPrimaryKey>  primary_keys;
  std::vector< ::Apache::Hadoop::Hive::SQLForeignKey>  foreign_keys;
   ::impala::TIcebergPartitionSpec partition_spec;

  _TCreateTableParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_columns(const std::vector< ::impala::TColumn> & val);

  void __set_partition_columns(const std::vector< ::impala::TColumn> & val);

  void __set_file_format(const  ::impala::THdfsFileFormat::type val);

  void __set_is_external(const bool val);

  void __set_if_not_exists(const bool val);

  void __set_owner(const std::string& val);

  void __set_row_format(const TTableRowFormat& val);

  void __set_comment(const std::string& val);

  void __set_location(const std::string& val);

  void __set_table_properties(const std::map<std::string, std::string> & val);

  void __set_serde_properties(const std::map<std::string, std::string> & val);

  void __set_cache_op(const THdfsCachingOp& val);

  void __set_partition_by(const std::vector< ::impala::TKuduPartitionParam> & val);

  void __set_primary_key_column_names(const std::vector<std::string> & val);

  void __set_sort_columns(const std::vector<std::string> & val);

  void __set_server_name(const std::string& val);

  void __set_sorting_order(const  ::impala::TSortingOrder::type val);

  void __set_primary_keys(const std::vector< ::Apache::Hadoop::Hive::SQLPrimaryKey> & val);

  void __set_foreign_keys(const std::vector< ::Apache::Hadoop::Hive::SQLForeignKey> & val);

  void __set_partition_spec(const  ::impala::TIcebergPartitionSpec& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateTableParams &a, TCreateTableParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateTableParams& obj);

typedef struct _TCreateOrAlterViewParams__isset {
  _TCreateOrAlterViewParams__isset() : comment(false), if_not_exists(false), server_name(false) {}
  bool comment :1;
  bool if_not_exists :1;
  bool server_name :1;
} _TCreateOrAlterViewParams__isset;

class TCreateOrAlterViewParams {
 public:

  TCreateOrAlterViewParams(const TCreateOrAlterViewParams&);
  TCreateOrAlterViewParams(TCreateOrAlterViewParams&&);
  TCreateOrAlterViewParams& operator=(const TCreateOrAlterViewParams&);
  TCreateOrAlterViewParams& operator=(TCreateOrAlterViewParams&&);
  TCreateOrAlterViewParams() : owner(), original_view_def(), expanded_view_def(), comment(), if_not_exists(0), server_name() {
  }

  virtual ~TCreateOrAlterViewParams() throw();
   ::impala::TTableName view_name;
  std::vector< ::impala::TColumn>  columns;
  std::string owner;
  std::string original_view_def;
  std::string expanded_view_def;
  std::string comment;
  bool if_not_exists;
  std::string server_name;

  _TCreateOrAlterViewParams__isset __isset;

  void __set_view_name(const  ::impala::TTableName& val);

  void __set_columns(const std::vector< ::impala::TColumn> & val);

  void __set_owner(const std::string& val);

  void __set_original_view_def(const std::string& val);

  void __set_expanded_view_def(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_if_not_exists(const bool val);

  void __set_server_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateOrAlterViewParams &a, TCreateOrAlterViewParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateOrAlterViewParams& obj);

typedef struct _TComputeStatsParams__isset {
  _TComputeStatsParams__isset() : tbl_stats_query(false), col_stats_query(false), is_incremental(false), existing_part_stats(false), expected_partitions(false), expect_all_partitions(false), num_partition_cols(false), total_file_bytes(false) {}
  bool tbl_stats_query :1;
  bool col_stats_query :1;
  bool is_incremental :1;
  bool existing_part_stats :1;
  bool expected_partitions :1;
  bool expect_all_partitions :1;
  bool num_partition_cols :1;
  bool total_file_bytes :1;
} _TComputeStatsParams__isset;

class TComputeStatsParams {
 public:

  TComputeStatsParams(const TComputeStatsParams&);
  TComputeStatsParams(TComputeStatsParams&&);
  TComputeStatsParams& operator=(const TComputeStatsParams&);
  TComputeStatsParams& operator=(TComputeStatsParams&&);
  TComputeStatsParams() : tbl_stats_query(), col_stats_query(), is_incremental(0), expect_all_partitions(0), num_partition_cols(0), total_file_bytes(0) {
  }

  virtual ~TComputeStatsParams() throw();
   ::impala::TTableName table_name;
  std::string tbl_stats_query;
  std::string col_stats_query;
  bool is_incremental;
  std::vector< ::impala::TPartitionStats>  existing_part_stats;
  std::vector<std::vector<std::string> >  expected_partitions;
  bool expect_all_partitions;
  int32_t num_partition_cols;
  int64_t total_file_bytes;

  _TComputeStatsParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_tbl_stats_query(const std::string& val);

  void __set_col_stats_query(const std::string& val);

  void __set_is_incremental(const bool val);

  void __set_existing_part_stats(const std::vector< ::impala::TPartitionStats> & val);

  void __set_expected_partitions(const std::vector<std::vector<std::string> > & val);

  void __set_expect_all_partitions(const bool val);

  void __set_num_partition_cols(const int32_t val);

  void __set_total_file_bytes(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TComputeStatsParams &a, TComputeStatsParams &b);

std::ostream& operator<<(std::ostream& out, const TComputeStatsParams& obj);


class TCreateDropRoleParams {
 public:

  TCreateDropRoleParams(const TCreateDropRoleParams&);
  TCreateDropRoleParams(TCreateDropRoleParams&&);
  TCreateDropRoleParams& operator=(const TCreateDropRoleParams&);
  TCreateDropRoleParams& operator=(TCreateDropRoleParams&&);
  TCreateDropRoleParams() : is_drop(0), role_name() {
  }

  virtual ~TCreateDropRoleParams() throw();
  bool is_drop;
  std::string role_name;

  void __set_is_drop(const bool val);

  void __set_role_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCreateDropRoleParams &a, TCreateDropRoleParams &b);

std::ostream& operator<<(std::ostream& out, const TCreateDropRoleParams& obj);


class TGrantRevokeRoleParams {
 public:

  TGrantRevokeRoleParams(const TGrantRevokeRoleParams&);
  TGrantRevokeRoleParams(TGrantRevokeRoleParams&&);
  TGrantRevokeRoleParams& operator=(const TGrantRevokeRoleParams&);
  TGrantRevokeRoleParams& operator=(TGrantRevokeRoleParams&&);
  TGrantRevokeRoleParams() : is_grant(0) {
  }

  virtual ~TGrantRevokeRoleParams() throw();
  std::vector<std::string>  role_names;
  std::vector<std::string>  group_names;
  bool is_grant;

  void __set_role_names(const std::vector<std::string> & val);

  void __set_group_names(const std::vector<std::string> & val);

  void __set_is_grant(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGrantRevokeRoleParams &a, TGrantRevokeRoleParams &b);

std::ostream& operator<<(std::ostream& out, const TGrantRevokeRoleParams& obj);


class TGrantRevokePrivParams {
 public:

  TGrantRevokePrivParams(const TGrantRevokePrivParams&);
  TGrantRevokePrivParams(TGrantRevokePrivParams&&);
  TGrantRevokePrivParams& operator=(const TGrantRevokePrivParams&);
  TGrantRevokePrivParams& operator=(TGrantRevokePrivParams&&);
  TGrantRevokePrivParams() : principal_name(), is_grant(0), has_grant_opt(0), principal_type(( ::impala::TPrincipalType::type)0) {
  }

  virtual ~TGrantRevokePrivParams() throw();
  std::vector< ::impala::TPrivilege>  privileges;
  std::string principal_name;
  bool is_grant;
  bool has_grant_opt;
   ::impala::TPrincipalType::type principal_type;

  void __set_privileges(const std::vector< ::impala::TPrivilege> & val);

  void __set_principal_name(const std::string& val);

  void __set_is_grant(const bool val);

  void __set_has_grant_opt(const bool val);

  void __set_principal_type(const  ::impala::TPrincipalType::type val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGrantRevokePrivParams &a, TGrantRevokePrivParams &b);

std::ostream& operator<<(std::ostream& out, const TGrantRevokePrivParams& obj);

typedef struct _TDropDbParams__isset {
  _TDropDbParams__isset() : server_name(false) {}
  bool server_name :1;
} _TDropDbParams__isset;

class TDropDbParams {
 public:

  TDropDbParams(const TDropDbParams&);
  TDropDbParams(TDropDbParams&&);
  TDropDbParams& operator=(const TDropDbParams&);
  TDropDbParams& operator=(TDropDbParams&&);
  TDropDbParams() : db(), if_exists(0), cascade(0), server_name() {
  }

  virtual ~TDropDbParams() throw();
  std::string db;
  bool if_exists;
  bool cascade;
  std::string server_name;

  _TDropDbParams__isset __isset;

  void __set_db(const std::string& val);

  void __set_if_exists(const bool val);

  void __set_cascade(const bool val);

  void __set_server_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropDbParams &a, TDropDbParams &b);

std::ostream& operator<<(std::ostream& out, const TDropDbParams& obj);

typedef struct _TDropTableOrViewParams__isset {
  _TDropTableOrViewParams__isset() : is_table(false), server_name(false) {}
  bool is_table :1;
  bool server_name :1;
} _TDropTableOrViewParams__isset;

class TDropTableOrViewParams {
 public:

  TDropTableOrViewParams(const TDropTableOrViewParams&);
  TDropTableOrViewParams(TDropTableOrViewParams&&);
  TDropTableOrViewParams& operator=(const TDropTableOrViewParams&);
  TDropTableOrViewParams& operator=(TDropTableOrViewParams&&);
  TDropTableOrViewParams() : if_exists(0), purge(0), is_table(0), server_name() {
  }

  virtual ~TDropTableOrViewParams() throw();
   ::impala::TTableName table_name;
  bool if_exists;
  bool purge;
  bool is_table;
  std::string server_name;

  _TDropTableOrViewParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_if_exists(const bool val);

  void __set_purge(const bool val);

  void __set_is_table(const bool val);

  void __set_server_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropTableOrViewParams &a, TDropTableOrViewParams &b);

std::ostream& operator<<(std::ostream& out, const TDropTableOrViewParams& obj);

typedef struct _TTruncateParams__isset {
  _TTruncateParams__isset() : delete_stats(true) {}
  bool delete_stats :1;
} _TTruncateParams__isset;

class TTruncateParams {
 public:

  TTruncateParams(const TTruncateParams&);
  TTruncateParams(TTruncateParams&&);
  TTruncateParams& operator=(const TTruncateParams&);
  TTruncateParams& operator=(TTruncateParams&&);
  TTruncateParams() : if_exists(0), delete_stats(true) {
  }

  virtual ~TTruncateParams() throw();
   ::impala::TTableName table_name;
  bool if_exists;
  bool delete_stats;

  _TTruncateParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_if_exists(const bool val);

  void __set_delete_stats(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTruncateParams &a, TTruncateParams &b);

std::ostream& operator<<(std::ostream& out, const TTruncateParams& obj);

typedef struct _TDropFunctionParams__isset {
  _TDropFunctionParams__isset() : signature(false) {}
  bool signature :1;
} _TDropFunctionParams__isset;

class TDropFunctionParams {
 public:

  TDropFunctionParams(const TDropFunctionParams&);
  TDropFunctionParams(TDropFunctionParams&&);
  TDropFunctionParams& operator=(const TDropFunctionParams&);
  TDropFunctionParams& operator=(TDropFunctionParams&&);
  TDropFunctionParams() : if_exists(0), signature() {
  }

  virtual ~TDropFunctionParams() throw();
   ::impala::TFunctionName fn_name;
  std::vector< ::impala::TColumnType>  arg_types;
  bool if_exists;
  std::string signature;

  _TDropFunctionParams__isset __isset;

  void __set_fn_name(const  ::impala::TFunctionName& val);

  void __set_arg_types(const std::vector< ::impala::TColumnType> & val);

  void __set_if_exists(const bool val);

  void __set_signature(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDropFunctionParams &a, TDropFunctionParams &b);

std::ostream& operator<<(std::ostream& out, const TDropFunctionParams& obj);

typedef struct _TTableUsageMetrics__isset {
  _TTableUsageMetrics__isset() : memory_estimate_bytes(false), num_metadata_operations(false), num_files(false), median_table_loading_ns(false), max_table_loading_ns(false), num_table_loading(false), p75_loading_time_ns(false), p95_loading_time_ns(false), p99_loading_time_ns(false) {}
  bool memory_estimate_bytes :1;
  bool num_metadata_operations :1;
  bool num_files :1;
  bool median_table_loading_ns :1;
  bool max_table_loading_ns :1;
  bool num_table_loading :1;
  bool p75_loading_time_ns :1;
  bool p95_loading_time_ns :1;
  bool p99_loading_time_ns :1;
} _TTableUsageMetrics__isset;

class TTableUsageMetrics {
 public:

  TTableUsageMetrics(const TTableUsageMetrics&);
  TTableUsageMetrics(TTableUsageMetrics&&);
  TTableUsageMetrics& operator=(const TTableUsageMetrics&);
  TTableUsageMetrics& operator=(TTableUsageMetrics&&);
  TTableUsageMetrics() : memory_estimate_bytes(0), num_metadata_operations(0), num_files(0), median_table_loading_ns(0), max_table_loading_ns(0), num_table_loading(0), p75_loading_time_ns(0), p95_loading_time_ns(0), p99_loading_time_ns(0) {
  }

  virtual ~TTableUsageMetrics() throw();
   ::impala::TTableName table_name;
  int64_t memory_estimate_bytes;
  int64_t num_metadata_operations;
  int64_t num_files;
  int64_t median_table_loading_ns;
  int64_t max_table_loading_ns;
  int64_t num_table_loading;
  int64_t p75_loading_time_ns;
  int64_t p95_loading_time_ns;
  int64_t p99_loading_time_ns;

  _TTableUsageMetrics__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_memory_estimate_bytes(const int64_t val);

  void __set_num_metadata_operations(const int64_t val);

  void __set_num_files(const int64_t val);

  void __set_median_table_loading_ns(const int64_t val);

  void __set_max_table_loading_ns(const int64_t val);

  void __set_num_table_loading(const int64_t val);

  void __set_p75_loading_time_ns(const int64_t val);

  void __set_p95_loading_time_ns(const int64_t val);

  void __set_p99_loading_time_ns(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableUsageMetrics &a, TTableUsageMetrics &b);

std::ostream& operator<<(std::ostream& out, const TTableUsageMetrics& obj);


class TGetCatalogUsageResponse {
 public:

  TGetCatalogUsageResponse(const TGetCatalogUsageResponse&);
  TGetCatalogUsageResponse(TGetCatalogUsageResponse&&);
  TGetCatalogUsageResponse& operator=(const TGetCatalogUsageResponse&);
  TGetCatalogUsageResponse& operator=(TGetCatalogUsageResponse&&);
  TGetCatalogUsageResponse() {
  }

  virtual ~TGetCatalogUsageResponse() throw();
  std::vector<TTableUsageMetrics>  large_tables;
  std::vector<TTableUsageMetrics>  frequently_accessed_tables;
  std::vector<TTableUsageMetrics>  high_file_count_tables;
  std::vector<TTableUsageMetrics>  long_metadata_loading_tables;

  void __set_large_tables(const std::vector<TTableUsageMetrics> & val);

  void __set_frequently_accessed_tables(const std::vector<TTableUsageMetrics> & val);

  void __set_high_file_count_tables(const std::vector<TTableUsageMetrics> & val);

  void __set_long_metadata_loading_tables(const std::vector<TTableUsageMetrics> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogUsageResponse &a, TGetCatalogUsageResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetCatalogUsageResponse& obj);

typedef struct _TOperationUsageCounter__isset {
  _TOperationUsageCounter__isset() : op_counter(false) {}
  bool op_counter :1;
} _TOperationUsageCounter__isset;

class TOperationUsageCounter {
 public:

  TOperationUsageCounter(const TOperationUsageCounter&);
  TOperationUsageCounter(TOperationUsageCounter&&);
  TOperationUsageCounter& operator=(const TOperationUsageCounter&);
  TOperationUsageCounter& operator=(TOperationUsageCounter&&);
  TOperationUsageCounter() : catalog_op_name(), table_name(), op_counter(0) {
  }

  virtual ~TOperationUsageCounter() throw();
  std::string catalog_op_name;
  std::string table_name;
  int64_t op_counter;

  _TOperationUsageCounter__isset __isset;

  void __set_catalog_op_name(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_op_counter(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOperationUsageCounter &a, TOperationUsageCounter &b);

std::ostream& operator<<(std::ostream& out, const TOperationUsageCounter& obj);


class TGetOperationUsageResponse {
 public:

  TGetOperationUsageResponse(const TGetOperationUsageResponse&);
  TGetOperationUsageResponse(TGetOperationUsageResponse&&);
  TGetOperationUsageResponse& operator=(const TGetOperationUsageResponse&);
  TGetOperationUsageResponse& operator=(TGetOperationUsageResponse&&);
  TGetOperationUsageResponse() {
  }

  virtual ~TGetOperationUsageResponse() throw();
  std::vector<TOperationUsageCounter>  catalog_op_counters;

  void __set_catalog_op_counters(const std::vector<TOperationUsageCounter> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetOperationUsageResponse &a, TGetOperationUsageResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetOperationUsageResponse& obj);


class TColumnName {
 public:

  TColumnName(const TColumnName&);
  TColumnName(TColumnName&&);
  TColumnName& operator=(const TColumnName&);
  TColumnName& operator=(TColumnName&&);
  TColumnName() : column_name() {
  }

  virtual ~TColumnName() throw();
   ::impala::TTableName table_name;
  std::string column_name;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_column_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnName &a, TColumnName &b);

std::ostream& operator<<(std::ostream& out, const TColumnName& obj);

typedef struct _TCommentOnParams__isset {
  _TCommentOnParams__isset() : comment(false), db(false), table_name(false), column_name(false) {}
  bool comment :1;
  bool db :1;
  bool table_name :1;
  bool column_name :1;
} _TCommentOnParams__isset;

class TCommentOnParams {
 public:

  TCommentOnParams(const TCommentOnParams&);
  TCommentOnParams(TCommentOnParams&&);
  TCommentOnParams& operator=(const TCommentOnParams&);
  TCommentOnParams& operator=(TCommentOnParams&&);
  TCommentOnParams() : comment(), db() {
  }

  virtual ~TCommentOnParams() throw();
  std::string comment;
  std::string db;
   ::impala::TTableName table_name;
  TColumnName column_name;

  _TCommentOnParams__isset __isset;

  void __set_comment(const std::string& val);

  void __set_db(const std::string& val);

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_column_name(const TColumnName& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCommentOnParams &a, TCommentOnParams &b);

std::ostream& operator<<(std::ostream& out, const TCommentOnParams& obj);

typedef struct _TEventProcessorMetrics__isset {
  _TEventProcessorMetrics__isset() : events_received(false), events_skipped(false), events_fetch_duration_mean(false), events_process_duration_mean(false), events_received_1min_rate(false), events_received_5min_rate(false), events_received_15min_rate(false), events_skipped_per_poll_mean(false), last_synced_event_id(false) {}
  bool events_received :1;
  bool events_skipped :1;
  bool events_fetch_duration_mean :1;
  bool events_process_duration_mean :1;
  bool events_received_1min_rate :1;
  bool events_received_5min_rate :1;
  bool events_received_15min_rate :1;
  bool events_skipped_per_poll_mean :1;
  bool last_synced_event_id :1;
} _TEventProcessorMetrics__isset;

class TEventProcessorMetrics {
 public:

  TEventProcessorMetrics(const TEventProcessorMetrics&);
  TEventProcessorMetrics(TEventProcessorMetrics&&);
  TEventProcessorMetrics& operator=(const TEventProcessorMetrics&);
  TEventProcessorMetrics& operator=(TEventProcessorMetrics&&);
  TEventProcessorMetrics() : status(), events_received(0), events_skipped(0), events_fetch_duration_mean(0), events_process_duration_mean(0), events_received_1min_rate(0), events_received_5min_rate(0), events_received_15min_rate(0), events_skipped_per_poll_mean(0), last_synced_event_id(0) {
  }

  virtual ~TEventProcessorMetrics() throw();
  std::string status;
  int64_t events_received;
  int64_t events_skipped;
  double events_fetch_duration_mean;
  double events_process_duration_mean;
  double events_received_1min_rate;
  double events_received_5min_rate;
  double events_received_15min_rate;
  double events_skipped_per_poll_mean;
  int64_t last_synced_event_id;

  _TEventProcessorMetrics__isset __isset;

  void __set_status(const std::string& val);

  void __set_events_received(const int64_t val);

  void __set_events_skipped(const int64_t val);

  void __set_events_fetch_duration_mean(const double val);

  void __set_events_process_duration_mean(const double val);

  void __set_events_received_1min_rate(const double val);

  void __set_events_received_5min_rate(const double val);

  void __set_events_received_15min_rate(const double val);

  void __set_events_skipped_per_poll_mean(const double val);

  void __set_last_synced_event_id(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEventProcessorMetrics &a, TEventProcessorMetrics &b);

std::ostream& operator<<(std::ostream& out, const TEventProcessorMetrics& obj);

typedef struct _TCatalogHmsCacheApiMetrics__isset {
  _TCatalogHmsCacheApiMetrics__isset() : api_requests(false), p99_response_time_ms(false), p95_response_time_ms(false), response_time_mean_ms(false), response_time_max_ms(false), response_time_min_ms(false), api_requests_1min_rate(false), api_requests_5min_rate(false), api_requests_15min_rate(false), cache_hit_ratio(false) {}
  bool api_requests :1;
  bool p99_response_time_ms :1;
  bool p95_response_time_ms :1;
  bool response_time_mean_ms :1;
  bool response_time_max_ms :1;
  bool response_time_min_ms :1;
  bool api_requests_1min_rate :1;
  bool api_requests_5min_rate :1;
  bool api_requests_15min_rate :1;
  bool cache_hit_ratio :1;
} _TCatalogHmsCacheApiMetrics__isset;

class TCatalogHmsCacheApiMetrics {
 public:

  TCatalogHmsCacheApiMetrics(const TCatalogHmsCacheApiMetrics&);
  TCatalogHmsCacheApiMetrics(TCatalogHmsCacheApiMetrics&&);
  TCatalogHmsCacheApiMetrics& operator=(const TCatalogHmsCacheApiMetrics&);
  TCatalogHmsCacheApiMetrics& operator=(TCatalogHmsCacheApiMetrics&&);
  TCatalogHmsCacheApiMetrics() : api_name(), api_requests(0), p99_response_time_ms(0), p95_response_time_ms(0), response_time_mean_ms(0), response_time_max_ms(0), response_time_min_ms(0), api_requests_1min_rate(0), api_requests_5min_rate(0), api_requests_15min_rate(0), cache_hit_ratio(0) {
  }

  virtual ~TCatalogHmsCacheApiMetrics() throw();
  std::string api_name;
  int64_t api_requests;
  double p99_response_time_ms;
  double p95_response_time_ms;
  double response_time_mean_ms;
  double response_time_max_ms;
  double response_time_min_ms;
  double api_requests_1min_rate;
  double api_requests_5min_rate;
  double api_requests_15min_rate;
  double cache_hit_ratio;

  _TCatalogHmsCacheApiMetrics__isset __isset;

  void __set_api_name(const std::string& val);

  void __set_api_requests(const int64_t val);

  void __set_p99_response_time_ms(const double val);

  void __set_p95_response_time_ms(const double val);

  void __set_response_time_mean_ms(const double val);

  void __set_response_time_max_ms(const double val);

  void __set_response_time_min_ms(const double val);

  void __set_api_requests_1min_rate(const double val);

  void __set_api_requests_5min_rate(const double val);

  void __set_api_requests_15min_rate(const double val);

  void __set_cache_hit_ratio(const double val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogHmsCacheApiMetrics &a, TCatalogHmsCacheApiMetrics &b);

std::ostream& operator<<(std::ostream& out, const TCatalogHmsCacheApiMetrics& obj);

typedef struct _TCatalogdHmsCacheMetrics__isset {
  _TCatalogdHmsCacheMetrics__isset() : cache_hit_ratio(false), api_requests(false), api_requests_1min_rate(false), api_requests_5min_rate(false), api_requests_15min_rate(false) {}
  bool cache_hit_ratio :1;
  bool api_requests :1;
  bool api_requests_1min_rate :1;
  bool api_requests_5min_rate :1;
  bool api_requests_15min_rate :1;
} _TCatalogdHmsCacheMetrics__isset;

class TCatalogdHmsCacheMetrics {
 public:

  TCatalogdHmsCacheMetrics(const TCatalogdHmsCacheMetrics&);
  TCatalogdHmsCacheMetrics(TCatalogdHmsCacheMetrics&&);
  TCatalogdHmsCacheMetrics& operator=(const TCatalogdHmsCacheMetrics&);
  TCatalogdHmsCacheMetrics& operator=(TCatalogdHmsCacheMetrics&&);
  TCatalogdHmsCacheMetrics() : cache_hit_ratio(0), api_requests(0), api_requests_1min_rate(0), api_requests_5min_rate(0), api_requests_15min_rate(0) {
  }

  virtual ~TCatalogdHmsCacheMetrics() throw();
  std::vector<TCatalogHmsCacheApiMetrics>  api_metrics;
  double cache_hit_ratio;
  int64_t api_requests;
  double api_requests_1min_rate;
  double api_requests_5min_rate;
  double api_requests_15min_rate;

  _TCatalogdHmsCacheMetrics__isset __isset;

  void __set_api_metrics(const std::vector<TCatalogHmsCacheApiMetrics> & val);

  void __set_cache_hit_ratio(const double val);

  void __set_api_requests(const int64_t val);

  void __set_api_requests_1min_rate(const double val);

  void __set_api_requests_5min_rate(const double val);

  void __set_api_requests_15min_rate(const double val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogdHmsCacheMetrics &a, TCatalogdHmsCacheMetrics &b);

std::ostream& operator<<(std::ostream& out, const TCatalogdHmsCacheMetrics& obj);

typedef struct _TGetCatalogServerMetricsResponse__isset {
  _TGetCatalogServerMetricsResponse__isset() : event_metrics(false), catalogd_hms_cache_metrics(false) {}
  bool event_metrics :1;
  bool catalogd_hms_cache_metrics :1;
} _TGetCatalogServerMetricsResponse__isset;

class TGetCatalogServerMetricsResponse {
 public:

  TGetCatalogServerMetricsResponse(const TGetCatalogServerMetricsResponse&);
  TGetCatalogServerMetricsResponse(TGetCatalogServerMetricsResponse&&);
  TGetCatalogServerMetricsResponse& operator=(const TGetCatalogServerMetricsResponse&);
  TGetCatalogServerMetricsResponse& operator=(TGetCatalogServerMetricsResponse&&);
  TGetCatalogServerMetricsResponse() : catalog_partial_fetch_rpc_queue_len(0) {
  }

  virtual ~TGetCatalogServerMetricsResponse() throw();
  int32_t catalog_partial_fetch_rpc_queue_len;
  TEventProcessorMetrics event_metrics;
  TCatalogdHmsCacheMetrics catalogd_hms_cache_metrics;

  _TGetCatalogServerMetricsResponse__isset __isset;

  void __set_catalog_partial_fetch_rpc_queue_len(const int32_t val);

  void __set_event_metrics(const TEventProcessorMetrics& val);

  void __set_catalogd_hms_cache_metrics(const TCatalogdHmsCacheMetrics& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogServerMetricsResponse &a, TGetCatalogServerMetricsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetCatalogServerMetricsResponse& obj);


class TCopyTestCaseReq {
 public:

  TCopyTestCaseReq(const TCopyTestCaseReq&);
  TCopyTestCaseReq(TCopyTestCaseReq&&);
  TCopyTestCaseReq& operator=(const TCopyTestCaseReq&);
  TCopyTestCaseReq& operator=(TCopyTestCaseReq&&);
  TCopyTestCaseReq() : input_path() {
  }

  virtual ~TCopyTestCaseReq() throw();
  std::string input_path;

  void __set_input_path(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCopyTestCaseReq &a, TCopyTestCaseReq &b);

std::ostream& operator<<(std::ostream& out, const TCopyTestCaseReq& obj);


class TEventProcessorMetricsSummaryResponse {
 public:

  TEventProcessorMetricsSummaryResponse(const TEventProcessorMetricsSummaryResponse&);
  TEventProcessorMetricsSummaryResponse(TEventProcessorMetricsSummaryResponse&&);
  TEventProcessorMetricsSummaryResponse& operator=(const TEventProcessorMetricsSummaryResponse&);
  TEventProcessorMetricsSummaryResponse& operator=(TEventProcessorMetricsSummaryResponse&&);
  TEventProcessorMetricsSummaryResponse() : summary() {
  }

  virtual ~TEventProcessorMetricsSummaryResponse() throw();
  std::string summary;

  void __set_summary(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEventProcessorMetricsSummaryResponse &a, TEventProcessorMetricsSummaryResponse &b);

std::ostream& operator<<(std::ostream& out, const TEventProcessorMetricsSummaryResponse& obj);

} // namespace

#include "JniCatalog_types.tcc"

#endif
