/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "parquet_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace parquet {

int _kTypeValues[] = {
  Type::BOOLEAN,
  Type::INT32,
  Type::INT64,
  Type::INT96,
  Type::FLOAT,
  Type::DOUBLE,
  Type::BYTE_ARRAY,
  Type::FIXED_LEN_BYTE_ARRAY,
  Type::UBSAN_FORCE_WIDTH
};
const char* _kTypeNames[] = {
  "BOOLEAN",
  "INT32",
  "INT64",
  "INT96",
  "FLOAT",
  "DOUBLE",
  "BYTE_ARRAY",
  "FIXED_LEN_BYTE_ARRAY",
  "UBSAN_FORCE_WIDTH"
};
const std::map<int, const char*> _Type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kTypeValues, _kTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Type::type& val) {
  std::map<int, const char*>::const_iterator it = _Type_VALUES_TO_NAMES.find(val);
  if (it != _Type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kConvertedTypeValues[] = {
  ConvertedType::UTF8,
  ConvertedType::MAP,
  ConvertedType::MAP_KEY_VALUE,
  ConvertedType::LIST,
  ConvertedType::ENUM,
  ConvertedType::DECIMAL,
  ConvertedType::DATE,
  ConvertedType::TIME_MILLIS,
  ConvertedType::TIME_MICROS,
  ConvertedType::TIMESTAMP_MILLIS,
  ConvertedType::TIMESTAMP_MICROS,
  ConvertedType::UINT_8,
  ConvertedType::UINT_16,
  ConvertedType::UINT_32,
  ConvertedType::UINT_64,
  ConvertedType::INT_8,
  ConvertedType::INT_16,
  ConvertedType::INT_32,
  ConvertedType::INT_64,
  ConvertedType::JSON,
  ConvertedType::BSON,
  ConvertedType::INTERVAL
};
const char* _kConvertedTypeNames[] = {
  "UTF8",
  "MAP",
  "MAP_KEY_VALUE",
  "LIST",
  "ENUM",
  "DECIMAL",
  "DATE",
  "TIME_MILLIS",
  "TIME_MICROS",
  "TIMESTAMP_MILLIS",
  "TIMESTAMP_MICROS",
  "UINT_8",
  "UINT_16",
  "UINT_32",
  "UINT_64",
  "INT_8",
  "INT_16",
  "INT_32",
  "INT_64",
  "JSON",
  "BSON",
  "INTERVAL"
};
const std::map<int, const char*> _ConvertedType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(22, _kConvertedTypeValues, _kConvertedTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ConvertedType::type& val) {
  std::map<int, const char*>::const_iterator it = _ConvertedType_VALUES_TO_NAMES.find(val);
  if (it != _ConvertedType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kFieldRepetitionTypeValues[] = {
  FieldRepetitionType::REQUIRED,
  FieldRepetitionType::OPTIONAL,
  FieldRepetitionType::REPEATED
};
const char* _kFieldRepetitionTypeNames[] = {
  "REQUIRED",
  "OPTIONAL",
  "REPEATED"
};
const std::map<int, const char*> _FieldRepetitionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kFieldRepetitionTypeValues, _kFieldRepetitionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const FieldRepetitionType::type& val) {
  std::map<int, const char*>::const_iterator it = _FieldRepetitionType_VALUES_TO_NAMES.find(val);
  if (it != _FieldRepetitionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kEncodingValues[] = {
  Encoding::PLAIN,
  Encoding::PLAIN_DICTIONARY,
  Encoding::RLE,
  Encoding::BIT_PACKED,
  Encoding::DELTA_BINARY_PACKED,
  Encoding::DELTA_LENGTH_BYTE_ARRAY,
  Encoding::DELTA_BYTE_ARRAY,
  Encoding::RLE_DICTIONARY,
  Encoding::BYTE_STREAM_SPLIT,
  Encoding::MAX_ENUM_VALUE
};
const char* _kEncodingNames[] = {
  "PLAIN",
  "PLAIN_DICTIONARY",
  "RLE",
  "BIT_PACKED",
  "DELTA_BINARY_PACKED",
  "DELTA_LENGTH_BYTE_ARRAY",
  "DELTA_BYTE_ARRAY",
  "RLE_DICTIONARY",
  "BYTE_STREAM_SPLIT",
  "MAX_ENUM_VALUE"
};
const std::map<int, const char*> _Encoding_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kEncodingValues, _kEncodingNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Encoding::type& val) {
  std::map<int, const char*>::const_iterator it = _Encoding_VALUES_TO_NAMES.find(val);
  if (it != _Encoding_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kCompressionCodecValues[] = {
  CompressionCodec::UNCOMPRESSED,
  CompressionCodec::SNAPPY,
  CompressionCodec::GZIP,
  CompressionCodec::LZO,
  CompressionCodec::BROTLI,
  CompressionCodec::LZ4,
  CompressionCodec::ZSTD
};
const char* _kCompressionCodecNames[] = {
  "UNCOMPRESSED",
  "SNAPPY",
  "GZIP",
  "LZO",
  "BROTLI",
  "LZ4",
  "ZSTD"
};
const std::map<int, const char*> _CompressionCodec_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kCompressionCodecValues, _kCompressionCodecNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CompressionCodec::type& val) {
  std::map<int, const char*>::const_iterator it = _CompressionCodec_VALUES_TO_NAMES.find(val);
  if (it != _CompressionCodec_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kPageTypeValues[] = {
  PageType::DATA_PAGE,
  PageType::INDEX_PAGE,
  PageType::DICTIONARY_PAGE,
  PageType::DATA_PAGE_V2
};
const char* _kPageTypeNames[] = {
  "DATA_PAGE",
  "INDEX_PAGE",
  "DICTIONARY_PAGE",
  "DATA_PAGE_V2"
};
const std::map<int, const char*> _PageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kPageTypeValues, _kPageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const PageType::type& val) {
  std::map<int, const char*>::const_iterator it = _PageType_VALUES_TO_NAMES.find(val);
  if (it != _PageType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kBoundaryOrderValues[] = {
  BoundaryOrder::UNORDERED,
  BoundaryOrder::ASCENDING,
  BoundaryOrder::DESCENDING
};
const char* _kBoundaryOrderNames[] = {
  "UNORDERED",
  "ASCENDING",
  "DESCENDING"
};
const std::map<int, const char*> _BoundaryOrder_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBoundaryOrderValues, _kBoundaryOrderNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BoundaryOrder::type& val) {
  std::map<int, const char*>::const_iterator it = _BoundaryOrder_VALUES_TO_NAMES.find(val);
  if (it != _BoundaryOrder_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Statistics::~Statistics() throw() {
}


void Statistics::__set_max(const std::string& val) {
  this->max = val;
__isset.max = true;
}

void Statistics::__set_min(const std::string& val) {
  this->min = val;
__isset.min = true;
}

void Statistics::__set_null_count(const int64_t val) {
  this->null_count = val;
__isset.null_count = true;
}

void Statistics::__set_distinct_count(const int64_t val) {
  this->distinct_count = val;
__isset.distinct_count = true;
}

void Statistics::__set_max_value(const std::string& val) {
  this->max_value = val;
__isset.max_value = true;
}

void Statistics::__set_min_value(const std::string& val) {
  this->min_value = val;
__isset.min_value = true;
}
std::ostream& operator<<(std::ostream& out, const Statistics& obj)
{
  obj.printTo(out);
  return out;
}


void swap(Statistics &a, Statistics &b) {
  using ::std::swap;
  swap(a.max, b.max);
  swap(a.min, b.min);
  swap(a.null_count, b.null_count);
  swap(a.distinct_count, b.distinct_count);
  swap(a.max_value, b.max_value);
  swap(a.min_value, b.min_value);
  swap(a.__isset, b.__isset);
}

Statistics::Statistics(const Statistics& other0) {
  max = other0.max;
  min = other0.min;
  null_count = other0.null_count;
  distinct_count = other0.distinct_count;
  max_value = other0.max_value;
  min_value = other0.min_value;
  __isset = other0.__isset;
}
Statistics::Statistics( Statistics&& other1) {
  max = std::move(other1.max);
  min = std::move(other1.min);
  null_count = std::move(other1.null_count);
  distinct_count = std::move(other1.distinct_count);
  max_value = std::move(other1.max_value);
  min_value = std::move(other1.min_value);
  __isset = std::move(other1.__isset);
}
Statistics& Statistics::operator=(const Statistics& other2) {
  max = other2.max;
  min = other2.min;
  null_count = other2.null_count;
  distinct_count = other2.distinct_count;
  max_value = other2.max_value;
  min_value = other2.min_value;
  __isset = other2.__isset;
  return *this;
}
Statistics& Statistics::operator=(Statistics&& other3) {
  max = std::move(other3.max);
  min = std::move(other3.min);
  null_count = std::move(other3.null_count);
  distinct_count = std::move(other3.distinct_count);
  max_value = std::move(other3.max_value);
  min_value = std::move(other3.min_value);
  __isset = std::move(other3.__isset);
  return *this;
}
void Statistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Statistics(";
  out << "max="; (__isset.max ? (out << to_string(max)) : (out << "<null>"));
  out << ", " << "min="; (__isset.min ? (out << to_string(min)) : (out << "<null>"));
  out << ", " << "null_count="; (__isset.null_count ? (out << to_string(null_count)) : (out << "<null>"));
  out << ", " << "distinct_count="; (__isset.distinct_count ? (out << to_string(distinct_count)) : (out << "<null>"));
  out << ", " << "max_value="; (__isset.max_value ? (out << to_string(max_value)) : (out << "<null>"));
  out << ", " << "min_value="; (__isset.min_value ? (out << to_string(min_value)) : (out << "<null>"));
  out << ")";
}


StringType::~StringType() throw() {
}

std::ostream& operator<<(std::ostream& out, const StringType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(StringType &a, StringType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

StringType::StringType(const StringType& other4) {
  (void) other4;
}
StringType::StringType( StringType&& other5) {
  (void) other5;
}
StringType& StringType::operator=(const StringType& other6) {
  (void) other6;
  return *this;
}
StringType& StringType::operator=(StringType&& other7) {
  (void) other7;
  return *this;
}
void StringType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StringType(";
  out << ")";
}


UUIDType::~UUIDType() throw() {
}

std::ostream& operator<<(std::ostream& out, const UUIDType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(UUIDType &a, UUIDType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

UUIDType::UUIDType(const UUIDType& other8) {
  (void) other8;
}
UUIDType::UUIDType( UUIDType&& other9) {
  (void) other9;
}
UUIDType& UUIDType::operator=(const UUIDType& other10) {
  (void) other10;
  return *this;
}
UUIDType& UUIDType::operator=(UUIDType&& other11) {
  (void) other11;
  return *this;
}
void UUIDType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UUIDType(";
  out << ")";
}


MapType::~MapType() throw() {
}

std::ostream& operator<<(std::ostream& out, const MapType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(MapType &a, MapType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

MapType::MapType(const MapType& other12) {
  (void) other12;
}
MapType::MapType( MapType&& other13) {
  (void) other13;
}
MapType& MapType::operator=(const MapType& other14) {
  (void) other14;
  return *this;
}
MapType& MapType::operator=(MapType&& other15) {
  (void) other15;
  return *this;
}
void MapType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapType(";
  out << ")";
}


ListType::~ListType() throw() {
}

std::ostream& operator<<(std::ostream& out, const ListType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(ListType &a, ListType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

ListType::ListType(const ListType& other16) {
  (void) other16;
}
ListType::ListType( ListType&& other17) {
  (void) other17;
}
ListType& ListType::operator=(const ListType& other18) {
  (void) other18;
  return *this;
}
ListType& ListType::operator=(ListType&& other19) {
  (void) other19;
  return *this;
}
void ListType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListType(";
  out << ")";
}


EnumType::~EnumType() throw() {
}

std::ostream& operator<<(std::ostream& out, const EnumType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(EnumType &a, EnumType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

EnumType::EnumType(const EnumType& other20) {
  (void) other20;
}
EnumType::EnumType( EnumType&& other21) {
  (void) other21;
}
EnumType& EnumType::operator=(const EnumType& other22) {
  (void) other22;
  return *this;
}
EnumType& EnumType::operator=(EnumType&& other23) {
  (void) other23;
  return *this;
}
void EnumType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EnumType(";
  out << ")";
}


DateType::~DateType() throw() {
}

std::ostream& operator<<(std::ostream& out, const DateType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(DateType &a, DateType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

DateType::DateType(const DateType& other24) {
  (void) other24;
}
DateType::DateType( DateType&& other25) {
  (void) other25;
}
DateType& DateType::operator=(const DateType& other26) {
  (void) other26;
  return *this;
}
DateType& DateType::operator=(DateType&& other27) {
  (void) other27;
  return *this;
}
void DateType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DateType(";
  out << ")";
}


NullType::~NullType() throw() {
}

std::ostream& operator<<(std::ostream& out, const NullType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(NullType &a, NullType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NullType::NullType(const NullType& other28) {
  (void) other28;
}
NullType::NullType( NullType&& other29) {
  (void) other29;
}
NullType& NullType::operator=(const NullType& other30) {
  (void) other30;
  return *this;
}
NullType& NullType::operator=(NullType&& other31) {
  (void) other31;
  return *this;
}
void NullType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NullType(";
  out << ")";
}


DecimalType::~DecimalType() throw() {
}


void DecimalType::__set_scale(const int32_t val) {
  this->scale = val;
}

void DecimalType::__set_precision(const int32_t val) {
  this->precision = val;
}
std::ostream& operator<<(std::ostream& out, const DecimalType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(DecimalType &a, DecimalType &b) {
  using ::std::swap;
  swap(a.scale, b.scale);
  swap(a.precision, b.precision);
}

DecimalType::DecimalType(const DecimalType& other32) {
  scale = other32.scale;
  precision = other32.precision;
}
DecimalType::DecimalType( DecimalType&& other33) {
  scale = std::move(other33.scale);
  precision = std::move(other33.precision);
}
DecimalType& DecimalType::operator=(const DecimalType& other34) {
  scale = other34.scale;
  precision = other34.precision;
  return *this;
}
DecimalType& DecimalType::operator=(DecimalType&& other35) {
  scale = std::move(other35.scale);
  precision = std::move(other35.precision);
  return *this;
}
void DecimalType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DecimalType(";
  out << "scale=" << to_string(scale);
  out << ", " << "precision=" << to_string(precision);
  out << ")";
}


MilliSeconds::~MilliSeconds() throw() {
}

std::ostream& operator<<(std::ostream& out, const MilliSeconds& obj)
{
  obj.printTo(out);
  return out;
}


void swap(MilliSeconds &a, MilliSeconds &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

MilliSeconds::MilliSeconds(const MilliSeconds& other36) {
  (void) other36;
}
MilliSeconds::MilliSeconds( MilliSeconds&& other37) {
  (void) other37;
}
MilliSeconds& MilliSeconds::operator=(const MilliSeconds& other38) {
  (void) other38;
  return *this;
}
MilliSeconds& MilliSeconds::operator=(MilliSeconds&& other39) {
  (void) other39;
  return *this;
}
void MilliSeconds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MilliSeconds(";
  out << ")";
}


MicroSeconds::~MicroSeconds() throw() {
}

std::ostream& operator<<(std::ostream& out, const MicroSeconds& obj)
{
  obj.printTo(out);
  return out;
}


void swap(MicroSeconds &a, MicroSeconds &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

MicroSeconds::MicroSeconds(const MicroSeconds& other40) {
  (void) other40;
}
MicroSeconds::MicroSeconds( MicroSeconds&& other41) {
  (void) other41;
}
MicroSeconds& MicroSeconds::operator=(const MicroSeconds& other42) {
  (void) other42;
  return *this;
}
MicroSeconds& MicroSeconds::operator=(MicroSeconds&& other43) {
  (void) other43;
  return *this;
}
void MicroSeconds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MicroSeconds(";
  out << ")";
}


NanoSeconds::~NanoSeconds() throw() {
}

std::ostream& operator<<(std::ostream& out, const NanoSeconds& obj)
{
  obj.printTo(out);
  return out;
}


void swap(NanoSeconds &a, NanoSeconds &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NanoSeconds::NanoSeconds(const NanoSeconds& other44) {
  (void) other44;
}
NanoSeconds::NanoSeconds( NanoSeconds&& other45) {
  (void) other45;
}
NanoSeconds& NanoSeconds::operator=(const NanoSeconds& other46) {
  (void) other46;
  return *this;
}
NanoSeconds& NanoSeconds::operator=(NanoSeconds&& other47) {
  (void) other47;
  return *this;
}
void NanoSeconds::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NanoSeconds(";
  out << ")";
}


TimeUnit::~TimeUnit() throw() {
}


void TimeUnit::__set_MILLIS(const MilliSeconds& val) {
  this->MILLIS = val;
__isset.MILLIS = true;
}

void TimeUnit::__set_MICROS(const MicroSeconds& val) {
  this->MICROS = val;
__isset.MICROS = true;
}

void TimeUnit::__set_NANOS(const NanoSeconds& val) {
  this->NANOS = val;
__isset.NANOS = true;
}
std::ostream& operator<<(std::ostream& out, const TimeUnit& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TimeUnit &a, TimeUnit &b) {
  using ::std::swap;
  swap(a.MILLIS, b.MILLIS);
  swap(a.MICROS, b.MICROS);
  swap(a.NANOS, b.NANOS);
  swap(a.__isset, b.__isset);
}

TimeUnit::TimeUnit(const TimeUnit& other48) {
  MILLIS = other48.MILLIS;
  MICROS = other48.MICROS;
  NANOS = other48.NANOS;
  __isset = other48.__isset;
}
TimeUnit::TimeUnit( TimeUnit&& other49) {
  MILLIS = std::move(other49.MILLIS);
  MICROS = std::move(other49.MICROS);
  NANOS = std::move(other49.NANOS);
  __isset = std::move(other49.__isset);
}
TimeUnit& TimeUnit::operator=(const TimeUnit& other50) {
  MILLIS = other50.MILLIS;
  MICROS = other50.MICROS;
  NANOS = other50.NANOS;
  __isset = other50.__isset;
  return *this;
}
TimeUnit& TimeUnit::operator=(TimeUnit&& other51) {
  MILLIS = std::move(other51.MILLIS);
  MICROS = std::move(other51.MICROS);
  NANOS = std::move(other51.NANOS);
  __isset = std::move(other51.__isset);
  return *this;
}
void TimeUnit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimeUnit(";
  out << "MILLIS="; (__isset.MILLIS ? (out << to_string(MILLIS)) : (out << "<null>"));
  out << ", " << "MICROS="; (__isset.MICROS ? (out << to_string(MICROS)) : (out << "<null>"));
  out << ", " << "NANOS="; (__isset.NANOS ? (out << to_string(NANOS)) : (out << "<null>"));
  out << ")";
}


TimestampType::~TimestampType() throw() {
}


void TimestampType::__set_isAdjustedToUTC(const bool val) {
  this->isAdjustedToUTC = val;
}

void TimestampType::__set_unit(const TimeUnit& val) {
  this->unit = val;
}
std::ostream& operator<<(std::ostream& out, const TimestampType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TimestampType &a, TimestampType &b) {
  using ::std::swap;
  swap(a.isAdjustedToUTC, b.isAdjustedToUTC);
  swap(a.unit, b.unit);
}

TimestampType::TimestampType(const TimestampType& other52) {
  isAdjustedToUTC = other52.isAdjustedToUTC;
  unit = other52.unit;
}
TimestampType::TimestampType( TimestampType&& other53) {
  isAdjustedToUTC = std::move(other53.isAdjustedToUTC);
  unit = std::move(other53.unit);
}
TimestampType& TimestampType::operator=(const TimestampType& other54) {
  isAdjustedToUTC = other54.isAdjustedToUTC;
  unit = other54.unit;
  return *this;
}
TimestampType& TimestampType::operator=(TimestampType&& other55) {
  isAdjustedToUTC = std::move(other55.isAdjustedToUTC);
  unit = std::move(other55.unit);
  return *this;
}
void TimestampType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimestampType(";
  out << "isAdjustedToUTC=" << to_string(isAdjustedToUTC);
  out << ", " << "unit=" << to_string(unit);
  out << ")";
}


TimeType::~TimeType() throw() {
}


void TimeType::__set_isAdjustedToUTC(const bool val) {
  this->isAdjustedToUTC = val;
}

void TimeType::__set_unit(const TimeUnit& val) {
  this->unit = val;
}
std::ostream& operator<<(std::ostream& out, const TimeType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TimeType &a, TimeType &b) {
  using ::std::swap;
  swap(a.isAdjustedToUTC, b.isAdjustedToUTC);
  swap(a.unit, b.unit);
}

TimeType::TimeType(const TimeType& other56) {
  isAdjustedToUTC = other56.isAdjustedToUTC;
  unit = other56.unit;
}
TimeType::TimeType( TimeType&& other57) {
  isAdjustedToUTC = std::move(other57.isAdjustedToUTC);
  unit = std::move(other57.unit);
}
TimeType& TimeType::operator=(const TimeType& other58) {
  isAdjustedToUTC = other58.isAdjustedToUTC;
  unit = other58.unit;
  return *this;
}
TimeType& TimeType::operator=(TimeType&& other59) {
  isAdjustedToUTC = std::move(other59.isAdjustedToUTC);
  unit = std::move(other59.unit);
  return *this;
}
void TimeType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TimeType(";
  out << "isAdjustedToUTC=" << to_string(isAdjustedToUTC);
  out << ", " << "unit=" << to_string(unit);
  out << ")";
}


IntType::~IntType() throw() {
}


void IntType::__set_bitWidth(const int8_t val) {
  this->bitWidth = val;
}

void IntType::__set_isSigned(const bool val) {
  this->isSigned = val;
}
std::ostream& operator<<(std::ostream& out, const IntType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(IntType &a, IntType &b) {
  using ::std::swap;
  swap(a.bitWidth, b.bitWidth);
  swap(a.isSigned, b.isSigned);
}

IntType::IntType(const IntType& other60) {
  bitWidth = other60.bitWidth;
  isSigned = other60.isSigned;
}
IntType::IntType( IntType&& other61) {
  bitWidth = std::move(other61.bitWidth);
  isSigned = std::move(other61.isSigned);
}
IntType& IntType::operator=(const IntType& other62) {
  bitWidth = other62.bitWidth;
  isSigned = other62.isSigned;
  return *this;
}
IntType& IntType::operator=(IntType&& other63) {
  bitWidth = std::move(other63.bitWidth);
  isSigned = std::move(other63.isSigned);
  return *this;
}
void IntType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IntType(";
  out << "bitWidth=" << to_string(bitWidth);
  out << ", " << "isSigned=" << to_string(isSigned);
  out << ")";
}


JsonType::~JsonType() throw() {
}

std::ostream& operator<<(std::ostream& out, const JsonType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(JsonType &a, JsonType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

JsonType::JsonType(const JsonType& other64) {
  (void) other64;
}
JsonType::JsonType( JsonType&& other65) {
  (void) other65;
}
JsonType& JsonType::operator=(const JsonType& other66) {
  (void) other66;
  return *this;
}
JsonType& JsonType::operator=(JsonType&& other67) {
  (void) other67;
  return *this;
}
void JsonType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "JsonType(";
  out << ")";
}


BsonType::~BsonType() throw() {
}

std::ostream& operator<<(std::ostream& out, const BsonType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(BsonType &a, BsonType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

BsonType::BsonType(const BsonType& other68) {
  (void) other68;
}
BsonType::BsonType( BsonType&& other69) {
  (void) other69;
}
BsonType& BsonType::operator=(const BsonType& other70) {
  (void) other70;
  return *this;
}
BsonType& BsonType::operator=(BsonType&& other71) {
  (void) other71;
  return *this;
}
void BsonType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BsonType(";
  out << ")";
}


LogicalType::~LogicalType() throw() {
}


void LogicalType::__set_STRING(const StringType& val) {
  this->STRING = val;
__isset.STRING = true;
}

void LogicalType::__set_MAP(const MapType& val) {
  this->MAP = val;
__isset.MAP = true;
}

void LogicalType::__set_LIST(const ListType& val) {
  this->LIST = val;
__isset.LIST = true;
}

void LogicalType::__set_ENUM(const EnumType& val) {
  this->ENUM = val;
__isset.ENUM = true;
}

void LogicalType::__set_DECIMAL(const DecimalType& val) {
  this->DECIMAL = val;
__isset.DECIMAL = true;
}

void LogicalType::__set_DATE(const DateType& val) {
  this->DATE = val;
__isset.DATE = true;
}

void LogicalType::__set_TIME(const TimeType& val) {
  this->TIME = val;
__isset.TIME = true;
}

void LogicalType::__set_TIMESTAMP(const TimestampType& val) {
  this->TIMESTAMP = val;
__isset.TIMESTAMP = true;
}

void LogicalType::__set_INTEGER(const IntType& val) {
  this->INTEGER = val;
__isset.INTEGER = true;
}

void LogicalType::__set_UNKNOWN(const NullType& val) {
  this->UNKNOWN = val;
__isset.UNKNOWN = true;
}

void LogicalType::__set_JSON(const JsonType& val) {
  this->JSON = val;
__isset.JSON = true;
}

void LogicalType::__set_BSON(const BsonType& val) {
  this->BSON = val;
__isset.BSON = true;
}

void LogicalType::__set_UUID(const UUIDType& val) {
  this->UUID = val;
__isset.UUID = true;
}
std::ostream& operator<<(std::ostream& out, const LogicalType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(LogicalType &a, LogicalType &b) {
  using ::std::swap;
  swap(a.STRING, b.STRING);
  swap(a.MAP, b.MAP);
  swap(a.LIST, b.LIST);
  swap(a.ENUM, b.ENUM);
  swap(a.DECIMAL, b.DECIMAL);
  swap(a.DATE, b.DATE);
  swap(a.TIME, b.TIME);
  swap(a.TIMESTAMP, b.TIMESTAMP);
  swap(a.INTEGER, b.INTEGER);
  swap(a.UNKNOWN, b.UNKNOWN);
  swap(a.JSON, b.JSON);
  swap(a.BSON, b.BSON);
  swap(a.UUID, b.UUID);
  swap(a.__isset, b.__isset);
}

LogicalType::LogicalType(const LogicalType& other72) {
  STRING = other72.STRING;
  MAP = other72.MAP;
  LIST = other72.LIST;
  ENUM = other72.ENUM;
  DECIMAL = other72.DECIMAL;
  DATE = other72.DATE;
  TIME = other72.TIME;
  TIMESTAMP = other72.TIMESTAMP;
  INTEGER = other72.INTEGER;
  UNKNOWN = other72.UNKNOWN;
  JSON = other72.JSON;
  BSON = other72.BSON;
  UUID = other72.UUID;
  __isset = other72.__isset;
}
LogicalType::LogicalType( LogicalType&& other73) {
  STRING = std::move(other73.STRING);
  MAP = std::move(other73.MAP);
  LIST = std::move(other73.LIST);
  ENUM = std::move(other73.ENUM);
  DECIMAL = std::move(other73.DECIMAL);
  DATE = std::move(other73.DATE);
  TIME = std::move(other73.TIME);
  TIMESTAMP = std::move(other73.TIMESTAMP);
  INTEGER = std::move(other73.INTEGER);
  UNKNOWN = std::move(other73.UNKNOWN);
  JSON = std::move(other73.JSON);
  BSON = std::move(other73.BSON);
  UUID = std::move(other73.UUID);
  __isset = std::move(other73.__isset);
}
LogicalType& LogicalType::operator=(const LogicalType& other74) {
  STRING = other74.STRING;
  MAP = other74.MAP;
  LIST = other74.LIST;
  ENUM = other74.ENUM;
  DECIMAL = other74.DECIMAL;
  DATE = other74.DATE;
  TIME = other74.TIME;
  TIMESTAMP = other74.TIMESTAMP;
  INTEGER = other74.INTEGER;
  UNKNOWN = other74.UNKNOWN;
  JSON = other74.JSON;
  BSON = other74.BSON;
  UUID = other74.UUID;
  __isset = other74.__isset;
  return *this;
}
LogicalType& LogicalType::operator=(LogicalType&& other75) {
  STRING = std::move(other75.STRING);
  MAP = std::move(other75.MAP);
  LIST = std::move(other75.LIST);
  ENUM = std::move(other75.ENUM);
  DECIMAL = std::move(other75.DECIMAL);
  DATE = std::move(other75.DATE);
  TIME = std::move(other75.TIME);
  TIMESTAMP = std::move(other75.TIMESTAMP);
  INTEGER = std::move(other75.INTEGER);
  UNKNOWN = std::move(other75.UNKNOWN);
  JSON = std::move(other75.JSON);
  BSON = std::move(other75.BSON);
  UUID = std::move(other75.UUID);
  __isset = std::move(other75.__isset);
  return *this;
}
void LogicalType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LogicalType(";
  out << "STRING="; (__isset.STRING ? (out << to_string(STRING)) : (out << "<null>"));
  out << ", " << "MAP="; (__isset.MAP ? (out << to_string(MAP)) : (out << "<null>"));
  out << ", " << "LIST="; (__isset.LIST ? (out << to_string(LIST)) : (out << "<null>"));
  out << ", " << "ENUM="; (__isset.ENUM ? (out << to_string(ENUM)) : (out << "<null>"));
  out << ", " << "DECIMAL="; (__isset.DECIMAL ? (out << to_string(DECIMAL)) : (out << "<null>"));
  out << ", " << "DATE="; (__isset.DATE ? (out << to_string(DATE)) : (out << "<null>"));
  out << ", " << "TIME="; (__isset.TIME ? (out << to_string(TIME)) : (out << "<null>"));
  out << ", " << "TIMESTAMP="; (__isset.TIMESTAMP ? (out << to_string(TIMESTAMP)) : (out << "<null>"));
  out << ", " << "INTEGER="; (__isset.INTEGER ? (out << to_string(INTEGER)) : (out << "<null>"));
  out << ", " << "UNKNOWN="; (__isset.UNKNOWN ? (out << to_string(UNKNOWN)) : (out << "<null>"));
  out << ", " << "JSON="; (__isset.JSON ? (out << to_string(JSON)) : (out << "<null>"));
  out << ", " << "BSON="; (__isset.BSON ? (out << to_string(BSON)) : (out << "<null>"));
  out << ", " << "UUID="; (__isset.UUID ? (out << to_string(UUID)) : (out << "<null>"));
  out << ")";
}


SchemaElement::~SchemaElement() throw() {
}


void SchemaElement::__set_type(const Type::type val) {
  this->type = val;
__isset.type = true;
}

void SchemaElement::__set_type_length(const int32_t val) {
  this->type_length = val;
__isset.type_length = true;
}

void SchemaElement::__set_repetition_type(const FieldRepetitionType::type val) {
  this->repetition_type = val;
__isset.repetition_type = true;
}

void SchemaElement::__set_name(const std::string& val) {
  this->name = val;
}

void SchemaElement::__set_num_children(const int32_t val) {
  this->num_children = val;
__isset.num_children = true;
}

void SchemaElement::__set_converted_type(const ConvertedType::type val) {
  this->converted_type = val;
__isset.converted_type = true;
}

void SchemaElement::__set_scale(const int32_t val) {
  this->scale = val;
__isset.scale = true;
}

void SchemaElement::__set_precision(const int32_t val) {
  this->precision = val;
__isset.precision = true;
}

void SchemaElement::__set_field_id(const int32_t val) {
  this->field_id = val;
__isset.field_id = true;
}

void SchemaElement::__set_logicalType(const LogicalType& val) {
  this->logicalType = val;
__isset.logicalType = true;
}
std::ostream& operator<<(std::ostream& out, const SchemaElement& obj)
{
  obj.printTo(out);
  return out;
}


void swap(SchemaElement &a, SchemaElement &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.type_length, b.type_length);
  swap(a.repetition_type, b.repetition_type);
  swap(a.name, b.name);
  swap(a.num_children, b.num_children);
  swap(a.converted_type, b.converted_type);
  swap(a.scale, b.scale);
  swap(a.precision, b.precision);
  swap(a.field_id, b.field_id);
  swap(a.logicalType, b.logicalType);
  swap(a.__isset, b.__isset);
}

SchemaElement::SchemaElement(const SchemaElement& other79) {
  type = other79.type;
  type_length = other79.type_length;
  repetition_type = other79.repetition_type;
  name = other79.name;
  num_children = other79.num_children;
  converted_type = other79.converted_type;
  scale = other79.scale;
  precision = other79.precision;
  field_id = other79.field_id;
  logicalType = other79.logicalType;
  __isset = other79.__isset;
}
SchemaElement::SchemaElement( SchemaElement&& other80) {
  type = std::move(other80.type);
  type_length = std::move(other80.type_length);
  repetition_type = std::move(other80.repetition_type);
  name = std::move(other80.name);
  num_children = std::move(other80.num_children);
  converted_type = std::move(other80.converted_type);
  scale = std::move(other80.scale);
  precision = std::move(other80.precision);
  field_id = std::move(other80.field_id);
  logicalType = std::move(other80.logicalType);
  __isset = std::move(other80.__isset);
}
SchemaElement& SchemaElement::operator=(const SchemaElement& other81) {
  type = other81.type;
  type_length = other81.type_length;
  repetition_type = other81.repetition_type;
  name = other81.name;
  num_children = other81.num_children;
  converted_type = other81.converted_type;
  scale = other81.scale;
  precision = other81.precision;
  field_id = other81.field_id;
  logicalType = other81.logicalType;
  __isset = other81.__isset;
  return *this;
}
SchemaElement& SchemaElement::operator=(SchemaElement&& other82) {
  type = std::move(other82.type);
  type_length = std::move(other82.type_length);
  repetition_type = std::move(other82.repetition_type);
  name = std::move(other82.name);
  num_children = std::move(other82.num_children);
  converted_type = std::move(other82.converted_type);
  scale = std::move(other82.scale);
  precision = std::move(other82.precision);
  field_id = std::move(other82.field_id);
  logicalType = std::move(other82.logicalType);
  __isset = std::move(other82.__isset);
  return *this;
}
void SchemaElement::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaElement(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "type_length="; (__isset.type_length ? (out << to_string(type_length)) : (out << "<null>"));
  out << ", " << "repetition_type="; (__isset.repetition_type ? (out << to_string(repetition_type)) : (out << "<null>"));
  out << ", " << "name=" << to_string(name);
  out << ", " << "num_children="; (__isset.num_children ? (out << to_string(num_children)) : (out << "<null>"));
  out << ", " << "converted_type="; (__isset.converted_type ? (out << to_string(converted_type)) : (out << "<null>"));
  out << ", " << "scale="; (__isset.scale ? (out << to_string(scale)) : (out << "<null>"));
  out << ", " << "precision="; (__isset.precision ? (out << to_string(precision)) : (out << "<null>"));
  out << ", " << "field_id="; (__isset.field_id ? (out << to_string(field_id)) : (out << "<null>"));
  out << ", " << "logicalType="; (__isset.logicalType ? (out << to_string(logicalType)) : (out << "<null>"));
  out << ")";
}


DataPageHeader::~DataPageHeader() throw() {
}


void DataPageHeader::__set_num_values(const int32_t val) {
  this->num_values = val;
}

void DataPageHeader::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void DataPageHeader::__set_definition_level_encoding(const Encoding::type val) {
  this->definition_level_encoding = val;
}

void DataPageHeader::__set_repetition_level_encoding(const Encoding::type val) {
  this->repetition_level_encoding = val;
}

void DataPageHeader::__set_statistics(const Statistics& val) {
  this->statistics = val;
__isset.statistics = true;
}
std::ostream& operator<<(std::ostream& out, const DataPageHeader& obj)
{
  obj.printTo(out);
  return out;
}


void swap(DataPageHeader &a, DataPageHeader &b) {
  using ::std::swap;
  swap(a.num_values, b.num_values);
  swap(a.encoding, b.encoding);
  swap(a.definition_level_encoding, b.definition_level_encoding);
  swap(a.repetition_level_encoding, b.repetition_level_encoding);
  swap(a.statistics, b.statistics);
  swap(a.__isset, b.__isset);
}

DataPageHeader::DataPageHeader(const DataPageHeader& other86) {
  num_values = other86.num_values;
  encoding = other86.encoding;
  definition_level_encoding = other86.definition_level_encoding;
  repetition_level_encoding = other86.repetition_level_encoding;
  statistics = other86.statistics;
  __isset = other86.__isset;
}
DataPageHeader::DataPageHeader( DataPageHeader&& other87) {
  num_values = std::move(other87.num_values);
  encoding = std::move(other87.encoding);
  definition_level_encoding = std::move(other87.definition_level_encoding);
  repetition_level_encoding = std::move(other87.repetition_level_encoding);
  statistics = std::move(other87.statistics);
  __isset = std::move(other87.__isset);
}
DataPageHeader& DataPageHeader::operator=(const DataPageHeader& other88) {
  num_values = other88.num_values;
  encoding = other88.encoding;
  definition_level_encoding = other88.definition_level_encoding;
  repetition_level_encoding = other88.repetition_level_encoding;
  statistics = other88.statistics;
  __isset = other88.__isset;
  return *this;
}
DataPageHeader& DataPageHeader::operator=(DataPageHeader&& other89) {
  num_values = std::move(other89.num_values);
  encoding = std::move(other89.encoding);
  definition_level_encoding = std::move(other89.definition_level_encoding);
  repetition_level_encoding = std::move(other89.repetition_level_encoding);
  statistics = std::move(other89.statistics);
  __isset = std::move(other89.__isset);
  return *this;
}
void DataPageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataPageHeader(";
  out << "num_values=" << to_string(num_values);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "definition_level_encoding=" << to_string(definition_level_encoding);
  out << ", " << "repetition_level_encoding=" << to_string(repetition_level_encoding);
  out << ", " << "statistics="; (__isset.statistics ? (out << to_string(statistics)) : (out << "<null>"));
  out << ")";
}


IndexPageHeader::~IndexPageHeader() throw() {
}

std::ostream& operator<<(std::ostream& out, const IndexPageHeader& obj)
{
  obj.printTo(out);
  return out;
}


void swap(IndexPageHeader &a, IndexPageHeader &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

IndexPageHeader::IndexPageHeader(const IndexPageHeader& other90) {
  (void) other90;
}
IndexPageHeader::IndexPageHeader( IndexPageHeader&& other91) {
  (void) other91;
}
IndexPageHeader& IndexPageHeader::operator=(const IndexPageHeader& other92) {
  (void) other92;
  return *this;
}
IndexPageHeader& IndexPageHeader::operator=(IndexPageHeader&& other93) {
  (void) other93;
  return *this;
}
void IndexPageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexPageHeader(";
  out << ")";
}


DictionaryPageHeader::~DictionaryPageHeader() throw() {
}


void DictionaryPageHeader::__set_num_values(const int32_t val) {
  this->num_values = val;
}

void DictionaryPageHeader::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void DictionaryPageHeader::__set_is_sorted(const bool val) {
  this->is_sorted = val;
__isset.is_sorted = true;
}
std::ostream& operator<<(std::ostream& out, const DictionaryPageHeader& obj)
{
  obj.printTo(out);
  return out;
}


void swap(DictionaryPageHeader &a, DictionaryPageHeader &b) {
  using ::std::swap;
  swap(a.num_values, b.num_values);
  swap(a.encoding, b.encoding);
  swap(a.is_sorted, b.is_sorted);
  swap(a.__isset, b.__isset);
}

DictionaryPageHeader::DictionaryPageHeader(const DictionaryPageHeader& other95) {
  num_values = other95.num_values;
  encoding = other95.encoding;
  is_sorted = other95.is_sorted;
  __isset = other95.__isset;
}
DictionaryPageHeader::DictionaryPageHeader( DictionaryPageHeader&& other96) {
  num_values = std::move(other96.num_values);
  encoding = std::move(other96.encoding);
  is_sorted = std::move(other96.is_sorted);
  __isset = std::move(other96.__isset);
}
DictionaryPageHeader& DictionaryPageHeader::operator=(const DictionaryPageHeader& other97) {
  num_values = other97.num_values;
  encoding = other97.encoding;
  is_sorted = other97.is_sorted;
  __isset = other97.__isset;
  return *this;
}
DictionaryPageHeader& DictionaryPageHeader::operator=(DictionaryPageHeader&& other98) {
  num_values = std::move(other98.num_values);
  encoding = std::move(other98.encoding);
  is_sorted = std::move(other98.is_sorted);
  __isset = std::move(other98.__isset);
  return *this;
}
void DictionaryPageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DictionaryPageHeader(";
  out << "num_values=" << to_string(num_values);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "is_sorted="; (__isset.is_sorted ? (out << to_string(is_sorted)) : (out << "<null>"));
  out << ")";
}


DataPageHeaderV2::~DataPageHeaderV2() throw() {
}


void DataPageHeaderV2::__set_num_values(const int32_t val) {
  this->num_values = val;
}

void DataPageHeaderV2::__set_num_nulls(const int32_t val) {
  this->num_nulls = val;
}

void DataPageHeaderV2::__set_num_rows(const int32_t val) {
  this->num_rows = val;
}

void DataPageHeaderV2::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void DataPageHeaderV2::__set_definition_levels_byte_length(const int32_t val) {
  this->definition_levels_byte_length = val;
}

void DataPageHeaderV2::__set_repetition_levels_byte_length(const int32_t val) {
  this->repetition_levels_byte_length = val;
}

void DataPageHeaderV2::__set_is_compressed(const bool val) {
  this->is_compressed = val;
__isset.is_compressed = true;
}

void DataPageHeaderV2::__set_statistics(const Statistics& val) {
  this->statistics = val;
__isset.statistics = true;
}
std::ostream& operator<<(std::ostream& out, const DataPageHeaderV2& obj)
{
  obj.printTo(out);
  return out;
}


void swap(DataPageHeaderV2 &a, DataPageHeaderV2 &b) {
  using ::std::swap;
  swap(a.num_values, b.num_values);
  swap(a.num_nulls, b.num_nulls);
  swap(a.num_rows, b.num_rows);
  swap(a.encoding, b.encoding);
  swap(a.definition_levels_byte_length, b.definition_levels_byte_length);
  swap(a.repetition_levels_byte_length, b.repetition_levels_byte_length);
  swap(a.is_compressed, b.is_compressed);
  swap(a.statistics, b.statistics);
  swap(a.__isset, b.__isset);
}

DataPageHeaderV2::DataPageHeaderV2(const DataPageHeaderV2& other100) {
  num_values = other100.num_values;
  num_nulls = other100.num_nulls;
  num_rows = other100.num_rows;
  encoding = other100.encoding;
  definition_levels_byte_length = other100.definition_levels_byte_length;
  repetition_levels_byte_length = other100.repetition_levels_byte_length;
  is_compressed = other100.is_compressed;
  statistics = other100.statistics;
  __isset = other100.__isset;
}
DataPageHeaderV2::DataPageHeaderV2( DataPageHeaderV2&& other101) {
  num_values = std::move(other101.num_values);
  num_nulls = std::move(other101.num_nulls);
  num_rows = std::move(other101.num_rows);
  encoding = std::move(other101.encoding);
  definition_levels_byte_length = std::move(other101.definition_levels_byte_length);
  repetition_levels_byte_length = std::move(other101.repetition_levels_byte_length);
  is_compressed = std::move(other101.is_compressed);
  statistics = std::move(other101.statistics);
  __isset = std::move(other101.__isset);
}
DataPageHeaderV2& DataPageHeaderV2::operator=(const DataPageHeaderV2& other102) {
  num_values = other102.num_values;
  num_nulls = other102.num_nulls;
  num_rows = other102.num_rows;
  encoding = other102.encoding;
  definition_levels_byte_length = other102.definition_levels_byte_length;
  repetition_levels_byte_length = other102.repetition_levels_byte_length;
  is_compressed = other102.is_compressed;
  statistics = other102.statistics;
  __isset = other102.__isset;
  return *this;
}
DataPageHeaderV2& DataPageHeaderV2::operator=(DataPageHeaderV2&& other103) {
  num_values = std::move(other103.num_values);
  num_nulls = std::move(other103.num_nulls);
  num_rows = std::move(other103.num_rows);
  encoding = std::move(other103.encoding);
  definition_levels_byte_length = std::move(other103.definition_levels_byte_length);
  repetition_levels_byte_length = std::move(other103.repetition_levels_byte_length);
  is_compressed = std::move(other103.is_compressed);
  statistics = std::move(other103.statistics);
  __isset = std::move(other103.__isset);
  return *this;
}
void DataPageHeaderV2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataPageHeaderV2(";
  out << "num_values=" << to_string(num_values);
  out << ", " << "num_nulls=" << to_string(num_nulls);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "definition_levels_byte_length=" << to_string(definition_levels_byte_length);
  out << ", " << "repetition_levels_byte_length=" << to_string(repetition_levels_byte_length);
  out << ", " << "is_compressed="; (__isset.is_compressed ? (out << to_string(is_compressed)) : (out << "<null>"));
  out << ", " << "statistics="; (__isset.statistics ? (out << to_string(statistics)) : (out << "<null>"));
  out << ")";
}


SplitBlockAlgorithm::~SplitBlockAlgorithm() throw() {
}

std::ostream& operator<<(std::ostream& out, const SplitBlockAlgorithm& obj)
{
  obj.printTo(out);
  return out;
}


void swap(SplitBlockAlgorithm &a, SplitBlockAlgorithm &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

SplitBlockAlgorithm::SplitBlockAlgorithm(const SplitBlockAlgorithm& other104) {
  (void) other104;
}
SplitBlockAlgorithm::SplitBlockAlgorithm( SplitBlockAlgorithm&& other105) {
  (void) other105;
}
SplitBlockAlgorithm& SplitBlockAlgorithm::operator=(const SplitBlockAlgorithm& other106) {
  (void) other106;
  return *this;
}
SplitBlockAlgorithm& SplitBlockAlgorithm::operator=(SplitBlockAlgorithm&& other107) {
  (void) other107;
  return *this;
}
void SplitBlockAlgorithm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SplitBlockAlgorithm(";
  out << ")";
}


BloomFilterAlgorithm::~BloomFilterAlgorithm() throw() {
}


void BloomFilterAlgorithm::__set_BLOCK(const SplitBlockAlgorithm& val) {
  this->BLOCK = val;
__isset.BLOCK = true;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterAlgorithm& obj)
{
  obj.printTo(out);
  return out;
}


void swap(BloomFilterAlgorithm &a, BloomFilterAlgorithm &b) {
  using ::std::swap;
  swap(a.BLOCK, b.BLOCK);
  swap(a.__isset, b.__isset);
}

BloomFilterAlgorithm::BloomFilterAlgorithm(const BloomFilterAlgorithm& other108) {
  BLOCK = other108.BLOCK;
  __isset = other108.__isset;
}
BloomFilterAlgorithm::BloomFilterAlgorithm( BloomFilterAlgorithm&& other109) {
  BLOCK = std::move(other109.BLOCK);
  __isset = std::move(other109.__isset);
}
BloomFilterAlgorithm& BloomFilterAlgorithm::operator=(const BloomFilterAlgorithm& other110) {
  BLOCK = other110.BLOCK;
  __isset = other110.__isset;
  return *this;
}
BloomFilterAlgorithm& BloomFilterAlgorithm::operator=(BloomFilterAlgorithm&& other111) {
  BLOCK = std::move(other111.BLOCK);
  __isset = std::move(other111.__isset);
  return *this;
}
void BloomFilterAlgorithm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterAlgorithm(";
  out << "BLOCK="; (__isset.BLOCK ? (out << to_string(BLOCK)) : (out << "<null>"));
  out << ")";
}


XxHash::~XxHash() throw() {
}

std::ostream& operator<<(std::ostream& out, const XxHash& obj)
{
  obj.printTo(out);
  return out;
}


void swap(XxHash &a, XxHash &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

XxHash::XxHash(const XxHash& other112) {
  (void) other112;
}
XxHash::XxHash( XxHash&& other113) {
  (void) other113;
}
XxHash& XxHash::operator=(const XxHash& other114) {
  (void) other114;
  return *this;
}
XxHash& XxHash::operator=(XxHash&& other115) {
  (void) other115;
  return *this;
}
void XxHash::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "XxHash(";
  out << ")";
}


BloomFilterHash::~BloomFilterHash() throw() {
}


void BloomFilterHash::__set_XXHASH(const XxHash& val) {
  this->XXHASH = val;
__isset.XXHASH = true;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterHash& obj)
{
  obj.printTo(out);
  return out;
}


void swap(BloomFilterHash &a, BloomFilterHash &b) {
  using ::std::swap;
  swap(a.XXHASH, b.XXHASH);
  swap(a.__isset, b.__isset);
}

BloomFilterHash::BloomFilterHash(const BloomFilterHash& other116) {
  XXHASH = other116.XXHASH;
  __isset = other116.__isset;
}
BloomFilterHash::BloomFilterHash( BloomFilterHash&& other117) {
  XXHASH = std::move(other117.XXHASH);
  __isset = std::move(other117.__isset);
}
BloomFilterHash& BloomFilterHash::operator=(const BloomFilterHash& other118) {
  XXHASH = other118.XXHASH;
  __isset = other118.__isset;
  return *this;
}
BloomFilterHash& BloomFilterHash::operator=(BloomFilterHash&& other119) {
  XXHASH = std::move(other119.XXHASH);
  __isset = std::move(other119.__isset);
  return *this;
}
void BloomFilterHash::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterHash(";
  out << "XXHASH="; (__isset.XXHASH ? (out << to_string(XXHASH)) : (out << "<null>"));
  out << ")";
}


Uncompressed::~Uncompressed() throw() {
}

std::ostream& operator<<(std::ostream& out, const Uncompressed& obj)
{
  obj.printTo(out);
  return out;
}


void swap(Uncompressed &a, Uncompressed &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

Uncompressed::Uncompressed(const Uncompressed& other120) {
  (void) other120;
}
Uncompressed::Uncompressed( Uncompressed&& other121) {
  (void) other121;
}
Uncompressed& Uncompressed::operator=(const Uncompressed& other122) {
  (void) other122;
  return *this;
}
Uncompressed& Uncompressed::operator=(Uncompressed&& other123) {
  (void) other123;
  return *this;
}
void Uncompressed::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Uncompressed(";
  out << ")";
}


BloomFilterCompression::~BloomFilterCompression() throw() {
}


void BloomFilterCompression::__set_UNCOMPRESSED(const Uncompressed& val) {
  this->UNCOMPRESSED = val;
__isset.UNCOMPRESSED = true;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterCompression& obj)
{
  obj.printTo(out);
  return out;
}


void swap(BloomFilterCompression &a, BloomFilterCompression &b) {
  using ::std::swap;
  swap(a.UNCOMPRESSED, b.UNCOMPRESSED);
  swap(a.__isset, b.__isset);
}

BloomFilterCompression::BloomFilterCompression(const BloomFilterCompression& other124) {
  UNCOMPRESSED = other124.UNCOMPRESSED;
  __isset = other124.__isset;
}
BloomFilterCompression::BloomFilterCompression( BloomFilterCompression&& other125) {
  UNCOMPRESSED = std::move(other125.UNCOMPRESSED);
  __isset = std::move(other125.__isset);
}
BloomFilterCompression& BloomFilterCompression::operator=(const BloomFilterCompression& other126) {
  UNCOMPRESSED = other126.UNCOMPRESSED;
  __isset = other126.__isset;
  return *this;
}
BloomFilterCompression& BloomFilterCompression::operator=(BloomFilterCompression&& other127) {
  UNCOMPRESSED = std::move(other127.UNCOMPRESSED);
  __isset = std::move(other127.__isset);
  return *this;
}
void BloomFilterCompression::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterCompression(";
  out << "UNCOMPRESSED="; (__isset.UNCOMPRESSED ? (out << to_string(UNCOMPRESSED)) : (out << "<null>"));
  out << ")";
}


BloomFilterHeader::~BloomFilterHeader() throw() {
}


void BloomFilterHeader::__set_numBytes(const int32_t val) {
  this->numBytes = val;
}

void BloomFilterHeader::__set_algorithm(const BloomFilterAlgorithm& val) {
  this->algorithm = val;
}

void BloomFilterHeader::__set_hash(const BloomFilterHash& val) {
  this->hash = val;
}

void BloomFilterHeader::__set_compression(const BloomFilterCompression& val) {
  this->compression = val;
}
std::ostream& operator<<(std::ostream& out, const BloomFilterHeader& obj)
{
  obj.printTo(out);
  return out;
}


void swap(BloomFilterHeader &a, BloomFilterHeader &b) {
  using ::std::swap;
  swap(a.numBytes, b.numBytes);
  swap(a.algorithm, b.algorithm);
  swap(a.hash, b.hash);
  swap(a.compression, b.compression);
}

BloomFilterHeader::BloomFilterHeader(const BloomFilterHeader& other128) {
  numBytes = other128.numBytes;
  algorithm = other128.algorithm;
  hash = other128.hash;
  compression = other128.compression;
}
BloomFilterHeader::BloomFilterHeader( BloomFilterHeader&& other129) {
  numBytes = std::move(other129.numBytes);
  algorithm = std::move(other129.algorithm);
  hash = std::move(other129.hash);
  compression = std::move(other129.compression);
}
BloomFilterHeader& BloomFilterHeader::operator=(const BloomFilterHeader& other130) {
  numBytes = other130.numBytes;
  algorithm = other130.algorithm;
  hash = other130.hash;
  compression = other130.compression;
  return *this;
}
BloomFilterHeader& BloomFilterHeader::operator=(BloomFilterHeader&& other131) {
  numBytes = std::move(other131.numBytes);
  algorithm = std::move(other131.algorithm);
  hash = std::move(other131.hash);
  compression = std::move(other131.compression);
  return *this;
}
void BloomFilterHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BloomFilterHeader(";
  out << "numBytes=" << to_string(numBytes);
  out << ", " << "algorithm=" << to_string(algorithm);
  out << ", " << "hash=" << to_string(hash);
  out << ", " << "compression=" << to_string(compression);
  out << ")";
}


PageHeader::~PageHeader() throw() {
}


void PageHeader::__set_type(const PageType::type val) {
  this->type = val;
}

void PageHeader::__set_uncompressed_page_size(const int32_t val) {
  this->uncompressed_page_size = val;
}

void PageHeader::__set_compressed_page_size(const int32_t val) {
  this->compressed_page_size = val;
}

void PageHeader::__set_crc(const int32_t val) {
  this->crc = val;
__isset.crc = true;
}

void PageHeader::__set_data_page_header(const DataPageHeader& val) {
  this->data_page_header = val;
__isset.data_page_header = true;
}

void PageHeader::__set_index_page_header(const IndexPageHeader& val) {
  this->index_page_header = val;
__isset.index_page_header = true;
}

void PageHeader::__set_dictionary_page_header(const DictionaryPageHeader& val) {
  this->dictionary_page_header = val;
__isset.dictionary_page_header = true;
}

void PageHeader::__set_data_page_header_v2(const DataPageHeaderV2& val) {
  this->data_page_header_v2 = val;
__isset.data_page_header_v2 = true;
}
std::ostream& operator<<(std::ostream& out, const PageHeader& obj)
{
  obj.printTo(out);
  return out;
}


void swap(PageHeader &a, PageHeader &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.uncompressed_page_size, b.uncompressed_page_size);
  swap(a.compressed_page_size, b.compressed_page_size);
  swap(a.crc, b.crc);
  swap(a.data_page_header, b.data_page_header);
  swap(a.index_page_header, b.index_page_header);
  swap(a.dictionary_page_header, b.dictionary_page_header);
  swap(a.data_page_header_v2, b.data_page_header_v2);
  swap(a.__isset, b.__isset);
}

PageHeader::PageHeader(const PageHeader& other133) {
  type = other133.type;
  uncompressed_page_size = other133.uncompressed_page_size;
  compressed_page_size = other133.compressed_page_size;
  crc = other133.crc;
  data_page_header = other133.data_page_header;
  index_page_header = other133.index_page_header;
  dictionary_page_header = other133.dictionary_page_header;
  data_page_header_v2 = other133.data_page_header_v2;
  __isset = other133.__isset;
}
PageHeader::PageHeader( PageHeader&& other134) {
  type = std::move(other134.type);
  uncompressed_page_size = std::move(other134.uncompressed_page_size);
  compressed_page_size = std::move(other134.compressed_page_size);
  crc = std::move(other134.crc);
  data_page_header = std::move(other134.data_page_header);
  index_page_header = std::move(other134.index_page_header);
  dictionary_page_header = std::move(other134.dictionary_page_header);
  data_page_header_v2 = std::move(other134.data_page_header_v2);
  __isset = std::move(other134.__isset);
}
PageHeader& PageHeader::operator=(const PageHeader& other135) {
  type = other135.type;
  uncompressed_page_size = other135.uncompressed_page_size;
  compressed_page_size = other135.compressed_page_size;
  crc = other135.crc;
  data_page_header = other135.data_page_header;
  index_page_header = other135.index_page_header;
  dictionary_page_header = other135.dictionary_page_header;
  data_page_header_v2 = other135.data_page_header_v2;
  __isset = other135.__isset;
  return *this;
}
PageHeader& PageHeader::operator=(PageHeader&& other136) {
  type = std::move(other136.type);
  uncompressed_page_size = std::move(other136.uncompressed_page_size);
  compressed_page_size = std::move(other136.compressed_page_size);
  crc = std::move(other136.crc);
  data_page_header = std::move(other136.data_page_header);
  index_page_header = std::move(other136.index_page_header);
  dictionary_page_header = std::move(other136.dictionary_page_header);
  data_page_header_v2 = std::move(other136.data_page_header_v2);
  __isset = std::move(other136.__isset);
  return *this;
}
void PageHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageHeader(";
  out << "type=" << to_string(type);
  out << ", " << "uncompressed_page_size=" << to_string(uncompressed_page_size);
  out << ", " << "compressed_page_size=" << to_string(compressed_page_size);
  out << ", " << "crc="; (__isset.crc ? (out << to_string(crc)) : (out << "<null>"));
  out << ", " << "data_page_header="; (__isset.data_page_header ? (out << to_string(data_page_header)) : (out << "<null>"));
  out << ", " << "index_page_header="; (__isset.index_page_header ? (out << to_string(index_page_header)) : (out << "<null>"));
  out << ", " << "dictionary_page_header="; (__isset.dictionary_page_header ? (out << to_string(dictionary_page_header)) : (out << "<null>"));
  out << ", " << "data_page_header_v2="; (__isset.data_page_header_v2 ? (out << to_string(data_page_header_v2)) : (out << "<null>"));
  out << ")";
}


KeyValue::~KeyValue() throw() {
}


void KeyValue::__set_key(const std::string& val) {
  this->key = val;
}

void KeyValue::__set_value(const std::string& val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const KeyValue& obj)
{
  obj.printTo(out);
  return out;
}


void swap(KeyValue &a, KeyValue &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

KeyValue::KeyValue(const KeyValue& other137) {
  key = other137.key;
  value = other137.value;
  __isset = other137.__isset;
}
KeyValue::KeyValue( KeyValue&& other138) {
  key = std::move(other138.key);
  value = std::move(other138.value);
  __isset = std::move(other138.__isset);
}
KeyValue& KeyValue::operator=(const KeyValue& other139) {
  key = other139.key;
  value = other139.value;
  __isset = other139.__isset;
  return *this;
}
KeyValue& KeyValue::operator=(KeyValue&& other140) {
  key = std::move(other140.key);
  value = std::move(other140.value);
  __isset = std::move(other140.__isset);
  return *this;
}
void KeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KeyValue(";
  out << "key=" << to_string(key);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


SortingColumn::~SortingColumn() throw() {
}


void SortingColumn::__set_column_idx(const int32_t val) {
  this->column_idx = val;
}

void SortingColumn::__set_descending(const bool val) {
  this->descending = val;
}

void SortingColumn::__set_nulls_first(const bool val) {
  this->nulls_first = val;
}
std::ostream& operator<<(std::ostream& out, const SortingColumn& obj)
{
  obj.printTo(out);
  return out;
}


void swap(SortingColumn &a, SortingColumn &b) {
  using ::std::swap;
  swap(a.column_idx, b.column_idx);
  swap(a.descending, b.descending);
  swap(a.nulls_first, b.nulls_first);
}

SortingColumn::SortingColumn(const SortingColumn& other141) {
  column_idx = other141.column_idx;
  descending = other141.descending;
  nulls_first = other141.nulls_first;
}
SortingColumn::SortingColumn( SortingColumn&& other142) {
  column_idx = std::move(other142.column_idx);
  descending = std::move(other142.descending);
  nulls_first = std::move(other142.nulls_first);
}
SortingColumn& SortingColumn::operator=(const SortingColumn& other143) {
  column_idx = other143.column_idx;
  descending = other143.descending;
  nulls_first = other143.nulls_first;
  return *this;
}
SortingColumn& SortingColumn::operator=(SortingColumn&& other144) {
  column_idx = std::move(other144.column_idx);
  descending = std::move(other144.descending);
  nulls_first = std::move(other144.nulls_first);
  return *this;
}
void SortingColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SortingColumn(";
  out << "column_idx=" << to_string(column_idx);
  out << ", " << "descending=" << to_string(descending);
  out << ", " << "nulls_first=" << to_string(nulls_first);
  out << ")";
}


PageEncodingStats::~PageEncodingStats() throw() {
}


void PageEncodingStats::__set_page_type(const PageType::type val) {
  this->page_type = val;
}

void PageEncodingStats::__set_encoding(const Encoding::type val) {
  this->encoding = val;
}

void PageEncodingStats::__set_count(const int32_t val) {
  this->count = val;
}
std::ostream& operator<<(std::ostream& out, const PageEncodingStats& obj)
{
  obj.printTo(out);
  return out;
}


void swap(PageEncodingStats &a, PageEncodingStats &b) {
  using ::std::swap;
  swap(a.page_type, b.page_type);
  swap(a.encoding, b.encoding);
  swap(a.count, b.count);
}

PageEncodingStats::PageEncodingStats(const PageEncodingStats& other147) {
  page_type = other147.page_type;
  encoding = other147.encoding;
  count = other147.count;
}
PageEncodingStats::PageEncodingStats( PageEncodingStats&& other148) {
  page_type = std::move(other148.page_type);
  encoding = std::move(other148.encoding);
  count = std::move(other148.count);
}
PageEncodingStats& PageEncodingStats::operator=(const PageEncodingStats& other149) {
  page_type = other149.page_type;
  encoding = other149.encoding;
  count = other149.count;
  return *this;
}
PageEncodingStats& PageEncodingStats::operator=(PageEncodingStats&& other150) {
  page_type = std::move(other150.page_type);
  encoding = std::move(other150.encoding);
  count = std::move(other150.count);
  return *this;
}
void PageEncodingStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageEncodingStats(";
  out << "page_type=" << to_string(page_type);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


ColumnMetaData::~ColumnMetaData() throw() {
}


void ColumnMetaData::__set_type(const Type::type val) {
  this->type = val;
}

void ColumnMetaData::__set_encodings(const std::vector<Encoding::type> & val) {
  this->encodings = val;
}

void ColumnMetaData::__set_path_in_schema(const std::vector<std::string> & val) {
  this->path_in_schema = val;
}

void ColumnMetaData::__set_codec(const CompressionCodec::type val) {
  this->codec = val;
}

void ColumnMetaData::__set_num_values(const int64_t val) {
  this->num_values = val;
}

void ColumnMetaData::__set_total_uncompressed_size(const int64_t val) {
  this->total_uncompressed_size = val;
}

void ColumnMetaData::__set_total_compressed_size(const int64_t val) {
  this->total_compressed_size = val;
}

void ColumnMetaData::__set_key_value_metadata(const std::vector<KeyValue> & val) {
  this->key_value_metadata = val;
__isset.key_value_metadata = true;
}

void ColumnMetaData::__set_data_page_offset(const int64_t val) {
  this->data_page_offset = val;
}

void ColumnMetaData::__set_index_page_offset(const int64_t val) {
  this->index_page_offset = val;
__isset.index_page_offset = true;
}

void ColumnMetaData::__set_dictionary_page_offset(const int64_t val) {
  this->dictionary_page_offset = val;
__isset.dictionary_page_offset = true;
}

void ColumnMetaData::__set_statistics(const Statistics& val) {
  this->statistics = val;
__isset.statistics = true;
}

void ColumnMetaData::__set_encoding_stats(const std::vector<PageEncodingStats> & val) {
  this->encoding_stats = val;
__isset.encoding_stats = true;
}

void ColumnMetaData::__set_bloom_filter_offset(const int64_t val) {
  this->bloom_filter_offset = val;
__isset.bloom_filter_offset = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnMetaData& obj)
{
  obj.printTo(out);
  return out;
}


void swap(ColumnMetaData &a, ColumnMetaData &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.encodings, b.encodings);
  swap(a.path_in_schema, b.path_in_schema);
  swap(a.codec, b.codec);
  swap(a.num_values, b.num_values);
  swap(a.total_uncompressed_size, b.total_uncompressed_size);
  swap(a.total_compressed_size, b.total_compressed_size);
  swap(a.key_value_metadata, b.key_value_metadata);
  swap(a.data_page_offset, b.data_page_offset);
  swap(a.index_page_offset, b.index_page_offset);
  swap(a.dictionary_page_offset, b.dictionary_page_offset);
  swap(a.statistics, b.statistics);
  swap(a.encoding_stats, b.encoding_stats);
  swap(a.bloom_filter_offset, b.bloom_filter_offset);
  swap(a.__isset, b.__isset);
}

ColumnMetaData::ColumnMetaData(const ColumnMetaData& other178) {
  type = other178.type;
  encodings = other178.encodings;
  path_in_schema = other178.path_in_schema;
  codec = other178.codec;
  num_values = other178.num_values;
  total_uncompressed_size = other178.total_uncompressed_size;
  total_compressed_size = other178.total_compressed_size;
  key_value_metadata = other178.key_value_metadata;
  data_page_offset = other178.data_page_offset;
  index_page_offset = other178.index_page_offset;
  dictionary_page_offset = other178.dictionary_page_offset;
  statistics = other178.statistics;
  encoding_stats = other178.encoding_stats;
  bloom_filter_offset = other178.bloom_filter_offset;
  __isset = other178.__isset;
}
ColumnMetaData::ColumnMetaData( ColumnMetaData&& other179) {
  type = std::move(other179.type);
  encodings = std::move(other179.encodings);
  path_in_schema = std::move(other179.path_in_schema);
  codec = std::move(other179.codec);
  num_values = std::move(other179.num_values);
  total_uncompressed_size = std::move(other179.total_uncompressed_size);
  total_compressed_size = std::move(other179.total_compressed_size);
  key_value_metadata = std::move(other179.key_value_metadata);
  data_page_offset = std::move(other179.data_page_offset);
  index_page_offset = std::move(other179.index_page_offset);
  dictionary_page_offset = std::move(other179.dictionary_page_offset);
  statistics = std::move(other179.statistics);
  encoding_stats = std::move(other179.encoding_stats);
  bloom_filter_offset = std::move(other179.bloom_filter_offset);
  __isset = std::move(other179.__isset);
}
ColumnMetaData& ColumnMetaData::operator=(const ColumnMetaData& other180) {
  type = other180.type;
  encodings = other180.encodings;
  path_in_schema = other180.path_in_schema;
  codec = other180.codec;
  num_values = other180.num_values;
  total_uncompressed_size = other180.total_uncompressed_size;
  total_compressed_size = other180.total_compressed_size;
  key_value_metadata = other180.key_value_metadata;
  data_page_offset = other180.data_page_offset;
  index_page_offset = other180.index_page_offset;
  dictionary_page_offset = other180.dictionary_page_offset;
  statistics = other180.statistics;
  encoding_stats = other180.encoding_stats;
  bloom_filter_offset = other180.bloom_filter_offset;
  __isset = other180.__isset;
  return *this;
}
ColumnMetaData& ColumnMetaData::operator=(ColumnMetaData&& other181) {
  type = std::move(other181.type);
  encodings = std::move(other181.encodings);
  path_in_schema = std::move(other181.path_in_schema);
  codec = std::move(other181.codec);
  num_values = std::move(other181.num_values);
  total_uncompressed_size = std::move(other181.total_uncompressed_size);
  total_compressed_size = std::move(other181.total_compressed_size);
  key_value_metadata = std::move(other181.key_value_metadata);
  data_page_offset = std::move(other181.data_page_offset);
  index_page_offset = std::move(other181.index_page_offset);
  dictionary_page_offset = std::move(other181.dictionary_page_offset);
  statistics = std::move(other181.statistics);
  encoding_stats = std::move(other181.encoding_stats);
  bloom_filter_offset = std::move(other181.bloom_filter_offset);
  __isset = std::move(other181.__isset);
  return *this;
}
void ColumnMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnMetaData(";
  out << "type=" << to_string(type);
  out << ", " << "encodings=" << to_string(encodings);
  out << ", " << "path_in_schema=" << to_string(path_in_schema);
  out << ", " << "codec=" << to_string(codec);
  out << ", " << "num_values=" << to_string(num_values);
  out << ", " << "total_uncompressed_size=" << to_string(total_uncompressed_size);
  out << ", " << "total_compressed_size=" << to_string(total_compressed_size);
  out << ", " << "key_value_metadata="; (__isset.key_value_metadata ? (out << to_string(key_value_metadata)) : (out << "<null>"));
  out << ", " << "data_page_offset=" << to_string(data_page_offset);
  out << ", " << "index_page_offset="; (__isset.index_page_offset ? (out << to_string(index_page_offset)) : (out << "<null>"));
  out << ", " << "dictionary_page_offset="; (__isset.dictionary_page_offset ? (out << to_string(dictionary_page_offset)) : (out << "<null>"));
  out << ", " << "statistics="; (__isset.statistics ? (out << to_string(statistics)) : (out << "<null>"));
  out << ", " << "encoding_stats="; (__isset.encoding_stats ? (out << to_string(encoding_stats)) : (out << "<null>"));
  out << ", " << "bloom_filter_offset="; (__isset.bloom_filter_offset ? (out << to_string(bloom_filter_offset)) : (out << "<null>"));
  out << ")";
}


EncryptionWithFooterKey::~EncryptionWithFooterKey() throw() {
}

std::ostream& operator<<(std::ostream& out, const EncryptionWithFooterKey& obj)
{
  obj.printTo(out);
  return out;
}


void swap(EncryptionWithFooterKey &a, EncryptionWithFooterKey &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

EncryptionWithFooterKey::EncryptionWithFooterKey(const EncryptionWithFooterKey& other182) {
  (void) other182;
}
EncryptionWithFooterKey::EncryptionWithFooterKey( EncryptionWithFooterKey&& other183) {
  (void) other183;
}
EncryptionWithFooterKey& EncryptionWithFooterKey::operator=(const EncryptionWithFooterKey& other184) {
  (void) other184;
  return *this;
}
EncryptionWithFooterKey& EncryptionWithFooterKey::operator=(EncryptionWithFooterKey&& other185) {
  (void) other185;
  return *this;
}
void EncryptionWithFooterKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EncryptionWithFooterKey(";
  out << ")";
}


EncryptionWithColumnKey::~EncryptionWithColumnKey() throw() {
}


void EncryptionWithColumnKey::__set_path_in_schema(const std::vector<std::string> & val) {
  this->path_in_schema = val;
}

void EncryptionWithColumnKey::__set_key_metadata(const std::string& val) {
  this->key_metadata = val;
__isset.key_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const EncryptionWithColumnKey& obj)
{
  obj.printTo(out);
  return out;
}


void swap(EncryptionWithColumnKey &a, EncryptionWithColumnKey &b) {
  using ::std::swap;
  swap(a.path_in_schema, b.path_in_schema);
  swap(a.key_metadata, b.key_metadata);
  swap(a.__isset, b.__isset);
}

EncryptionWithColumnKey::EncryptionWithColumnKey(const EncryptionWithColumnKey& other192) {
  path_in_schema = other192.path_in_schema;
  key_metadata = other192.key_metadata;
  __isset = other192.__isset;
}
EncryptionWithColumnKey::EncryptionWithColumnKey( EncryptionWithColumnKey&& other193) {
  path_in_schema = std::move(other193.path_in_schema);
  key_metadata = std::move(other193.key_metadata);
  __isset = std::move(other193.__isset);
}
EncryptionWithColumnKey& EncryptionWithColumnKey::operator=(const EncryptionWithColumnKey& other194) {
  path_in_schema = other194.path_in_schema;
  key_metadata = other194.key_metadata;
  __isset = other194.__isset;
  return *this;
}
EncryptionWithColumnKey& EncryptionWithColumnKey::operator=(EncryptionWithColumnKey&& other195) {
  path_in_schema = std::move(other195.path_in_schema);
  key_metadata = std::move(other195.key_metadata);
  __isset = std::move(other195.__isset);
  return *this;
}
void EncryptionWithColumnKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EncryptionWithColumnKey(";
  out << "path_in_schema=" << to_string(path_in_schema);
  out << ", " << "key_metadata="; (__isset.key_metadata ? (out << to_string(key_metadata)) : (out << "<null>"));
  out << ")";
}


ColumnCryptoMetaData::~ColumnCryptoMetaData() throw() {
}


void ColumnCryptoMetaData::__set_ENCRYPTION_WITH_FOOTER_KEY(const EncryptionWithFooterKey& val) {
  this->ENCRYPTION_WITH_FOOTER_KEY = val;
__isset.ENCRYPTION_WITH_FOOTER_KEY = true;
}

void ColumnCryptoMetaData::__set_ENCRYPTION_WITH_COLUMN_KEY(const EncryptionWithColumnKey& val) {
  this->ENCRYPTION_WITH_COLUMN_KEY = val;
__isset.ENCRYPTION_WITH_COLUMN_KEY = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnCryptoMetaData& obj)
{
  obj.printTo(out);
  return out;
}


void swap(ColumnCryptoMetaData &a, ColumnCryptoMetaData &b) {
  using ::std::swap;
  swap(a.ENCRYPTION_WITH_FOOTER_KEY, b.ENCRYPTION_WITH_FOOTER_KEY);
  swap(a.ENCRYPTION_WITH_COLUMN_KEY, b.ENCRYPTION_WITH_COLUMN_KEY);
  swap(a.__isset, b.__isset);
}

ColumnCryptoMetaData::ColumnCryptoMetaData(const ColumnCryptoMetaData& other196) {
  ENCRYPTION_WITH_FOOTER_KEY = other196.ENCRYPTION_WITH_FOOTER_KEY;
  ENCRYPTION_WITH_COLUMN_KEY = other196.ENCRYPTION_WITH_COLUMN_KEY;
  __isset = other196.__isset;
}
ColumnCryptoMetaData::ColumnCryptoMetaData( ColumnCryptoMetaData&& other197) {
  ENCRYPTION_WITH_FOOTER_KEY = std::move(other197.ENCRYPTION_WITH_FOOTER_KEY);
  ENCRYPTION_WITH_COLUMN_KEY = std::move(other197.ENCRYPTION_WITH_COLUMN_KEY);
  __isset = std::move(other197.__isset);
}
ColumnCryptoMetaData& ColumnCryptoMetaData::operator=(const ColumnCryptoMetaData& other198) {
  ENCRYPTION_WITH_FOOTER_KEY = other198.ENCRYPTION_WITH_FOOTER_KEY;
  ENCRYPTION_WITH_COLUMN_KEY = other198.ENCRYPTION_WITH_COLUMN_KEY;
  __isset = other198.__isset;
  return *this;
}
ColumnCryptoMetaData& ColumnCryptoMetaData::operator=(ColumnCryptoMetaData&& other199) {
  ENCRYPTION_WITH_FOOTER_KEY = std::move(other199.ENCRYPTION_WITH_FOOTER_KEY);
  ENCRYPTION_WITH_COLUMN_KEY = std::move(other199.ENCRYPTION_WITH_COLUMN_KEY);
  __isset = std::move(other199.__isset);
  return *this;
}
void ColumnCryptoMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnCryptoMetaData(";
  out << "ENCRYPTION_WITH_FOOTER_KEY="; (__isset.ENCRYPTION_WITH_FOOTER_KEY ? (out << to_string(ENCRYPTION_WITH_FOOTER_KEY)) : (out << "<null>"));
  out << ", " << "ENCRYPTION_WITH_COLUMN_KEY="; (__isset.ENCRYPTION_WITH_COLUMN_KEY ? (out << to_string(ENCRYPTION_WITH_COLUMN_KEY)) : (out << "<null>"));
  out << ")";
}


ColumnChunk::~ColumnChunk() throw() {
}


void ColumnChunk::__set_file_path(const std::string& val) {
  this->file_path = val;
__isset.file_path = true;
}

void ColumnChunk::__set_file_offset(const int64_t val) {
  this->file_offset = val;
}

void ColumnChunk::__set_meta_data(const ColumnMetaData& val) {
  this->meta_data = val;
__isset.meta_data = true;
}

void ColumnChunk::__set_offset_index_offset(const int64_t val) {
  this->offset_index_offset = val;
__isset.offset_index_offset = true;
}

void ColumnChunk::__set_offset_index_length(const int32_t val) {
  this->offset_index_length = val;
__isset.offset_index_length = true;
}

void ColumnChunk::__set_column_index_offset(const int64_t val) {
  this->column_index_offset = val;
__isset.column_index_offset = true;
}

void ColumnChunk::__set_column_index_length(const int32_t val) {
  this->column_index_length = val;
__isset.column_index_length = true;
}

void ColumnChunk::__set_crypto_metadata(const ColumnCryptoMetaData& val) {
  this->crypto_metadata = val;
__isset.crypto_metadata = true;
}

void ColumnChunk::__set_encrypted_column_metadata(const std::string& val) {
  this->encrypted_column_metadata = val;
__isset.encrypted_column_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnChunk& obj)
{
  obj.printTo(out);
  return out;
}


void swap(ColumnChunk &a, ColumnChunk &b) {
  using ::std::swap;
  swap(a.file_path, b.file_path);
  swap(a.file_offset, b.file_offset);
  swap(a.meta_data, b.meta_data);
  swap(a.offset_index_offset, b.offset_index_offset);
  swap(a.offset_index_length, b.offset_index_length);
  swap(a.column_index_offset, b.column_index_offset);
  swap(a.column_index_length, b.column_index_length);
  swap(a.crypto_metadata, b.crypto_metadata);
  swap(a.encrypted_column_metadata, b.encrypted_column_metadata);
  swap(a.__isset, b.__isset);
}

ColumnChunk::ColumnChunk(const ColumnChunk& other200) {
  file_path = other200.file_path;
  file_offset = other200.file_offset;
  meta_data = other200.meta_data;
  offset_index_offset = other200.offset_index_offset;
  offset_index_length = other200.offset_index_length;
  column_index_offset = other200.column_index_offset;
  column_index_length = other200.column_index_length;
  crypto_metadata = other200.crypto_metadata;
  encrypted_column_metadata = other200.encrypted_column_metadata;
  __isset = other200.__isset;
}
ColumnChunk::ColumnChunk( ColumnChunk&& other201) {
  file_path = std::move(other201.file_path);
  file_offset = std::move(other201.file_offset);
  meta_data = std::move(other201.meta_data);
  offset_index_offset = std::move(other201.offset_index_offset);
  offset_index_length = std::move(other201.offset_index_length);
  column_index_offset = std::move(other201.column_index_offset);
  column_index_length = std::move(other201.column_index_length);
  crypto_metadata = std::move(other201.crypto_metadata);
  encrypted_column_metadata = std::move(other201.encrypted_column_metadata);
  __isset = std::move(other201.__isset);
}
ColumnChunk& ColumnChunk::operator=(const ColumnChunk& other202) {
  file_path = other202.file_path;
  file_offset = other202.file_offset;
  meta_data = other202.meta_data;
  offset_index_offset = other202.offset_index_offset;
  offset_index_length = other202.offset_index_length;
  column_index_offset = other202.column_index_offset;
  column_index_length = other202.column_index_length;
  crypto_metadata = other202.crypto_metadata;
  encrypted_column_metadata = other202.encrypted_column_metadata;
  __isset = other202.__isset;
  return *this;
}
ColumnChunk& ColumnChunk::operator=(ColumnChunk&& other203) {
  file_path = std::move(other203.file_path);
  file_offset = std::move(other203.file_offset);
  meta_data = std::move(other203.meta_data);
  offset_index_offset = std::move(other203.offset_index_offset);
  offset_index_length = std::move(other203.offset_index_length);
  column_index_offset = std::move(other203.column_index_offset);
  column_index_length = std::move(other203.column_index_length);
  crypto_metadata = std::move(other203.crypto_metadata);
  encrypted_column_metadata = std::move(other203.encrypted_column_metadata);
  __isset = std::move(other203.__isset);
  return *this;
}
void ColumnChunk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnChunk(";
  out << "file_path="; (__isset.file_path ? (out << to_string(file_path)) : (out << "<null>"));
  out << ", " << "file_offset=" << to_string(file_offset);
  out << ", " << "meta_data="; (__isset.meta_data ? (out << to_string(meta_data)) : (out << "<null>"));
  out << ", " << "offset_index_offset="; (__isset.offset_index_offset ? (out << to_string(offset_index_offset)) : (out << "<null>"));
  out << ", " << "offset_index_length="; (__isset.offset_index_length ? (out << to_string(offset_index_length)) : (out << "<null>"));
  out << ", " << "column_index_offset="; (__isset.column_index_offset ? (out << to_string(column_index_offset)) : (out << "<null>"));
  out << ", " << "column_index_length="; (__isset.column_index_length ? (out << to_string(column_index_length)) : (out << "<null>"));
  out << ", " << "crypto_metadata="; (__isset.crypto_metadata ? (out << to_string(crypto_metadata)) : (out << "<null>"));
  out << ", " << "encrypted_column_metadata="; (__isset.encrypted_column_metadata ? (out << to_string(encrypted_column_metadata)) : (out << "<null>"));
  out << ")";
}


RowGroup::~RowGroup() throw() {
}


void RowGroup::__set_columns(const std::vector<ColumnChunk> & val) {
  this->columns = val;
}

void RowGroup::__set_total_byte_size(const int64_t val) {
  this->total_byte_size = val;
}

void RowGroup::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void RowGroup::__set_sorting_columns(const std::vector<SortingColumn> & val) {
  this->sorting_columns = val;
__isset.sorting_columns = true;
}

void RowGroup::__set_file_offset(const int64_t val) {
  this->file_offset = val;
__isset.file_offset = true;
}

void RowGroup::__set_total_compressed_size(const int64_t val) {
  this->total_compressed_size = val;
__isset.total_compressed_size = true;
}

void RowGroup::__set_ordinal(const int16_t val) {
  this->ordinal = val;
__isset.ordinal = true;
}
std::ostream& operator<<(std::ostream& out, const RowGroup& obj)
{
  obj.printTo(out);
  return out;
}


void swap(RowGroup &a, RowGroup &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.total_byte_size, b.total_byte_size);
  swap(a.num_rows, b.num_rows);
  swap(a.sorting_columns, b.sorting_columns);
  swap(a.file_offset, b.file_offset);
  swap(a.total_compressed_size, b.total_compressed_size);
  swap(a.ordinal, b.ordinal);
  swap(a.__isset, b.__isset);
}

RowGroup::RowGroup(const RowGroup& other216) {
  columns = other216.columns;
  total_byte_size = other216.total_byte_size;
  num_rows = other216.num_rows;
  sorting_columns = other216.sorting_columns;
  file_offset = other216.file_offset;
  total_compressed_size = other216.total_compressed_size;
  ordinal = other216.ordinal;
  __isset = other216.__isset;
}
RowGroup::RowGroup( RowGroup&& other217) {
  columns = std::move(other217.columns);
  total_byte_size = std::move(other217.total_byte_size);
  num_rows = std::move(other217.num_rows);
  sorting_columns = std::move(other217.sorting_columns);
  file_offset = std::move(other217.file_offset);
  total_compressed_size = std::move(other217.total_compressed_size);
  ordinal = std::move(other217.ordinal);
  __isset = std::move(other217.__isset);
}
RowGroup& RowGroup::operator=(const RowGroup& other218) {
  columns = other218.columns;
  total_byte_size = other218.total_byte_size;
  num_rows = other218.num_rows;
  sorting_columns = other218.sorting_columns;
  file_offset = other218.file_offset;
  total_compressed_size = other218.total_compressed_size;
  ordinal = other218.ordinal;
  __isset = other218.__isset;
  return *this;
}
RowGroup& RowGroup::operator=(RowGroup&& other219) {
  columns = std::move(other219.columns);
  total_byte_size = std::move(other219.total_byte_size);
  num_rows = std::move(other219.num_rows);
  sorting_columns = std::move(other219.sorting_columns);
  file_offset = std::move(other219.file_offset);
  total_compressed_size = std::move(other219.total_compressed_size);
  ordinal = std::move(other219.ordinal);
  __isset = std::move(other219.__isset);
  return *this;
}
void RowGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RowGroup(";
  out << "columns=" << to_string(columns);
  out << ", " << "total_byte_size=" << to_string(total_byte_size);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ", " << "sorting_columns="; (__isset.sorting_columns ? (out << to_string(sorting_columns)) : (out << "<null>"));
  out << ", " << "file_offset="; (__isset.file_offset ? (out << to_string(file_offset)) : (out << "<null>"));
  out << ", " << "total_compressed_size="; (__isset.total_compressed_size ? (out << to_string(total_compressed_size)) : (out << "<null>"));
  out << ", " << "ordinal="; (__isset.ordinal ? (out << to_string(ordinal)) : (out << "<null>"));
  out << ")";
}


TypeDefinedOrder::~TypeDefinedOrder() throw() {
}

std::ostream& operator<<(std::ostream& out, const TypeDefinedOrder& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TypeDefinedOrder &a, TypeDefinedOrder &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

TypeDefinedOrder::TypeDefinedOrder(const TypeDefinedOrder& other220) {
  (void) other220;
}
TypeDefinedOrder::TypeDefinedOrder( TypeDefinedOrder&& other221) {
  (void) other221;
}
TypeDefinedOrder& TypeDefinedOrder::operator=(const TypeDefinedOrder& other222) {
  (void) other222;
  return *this;
}
TypeDefinedOrder& TypeDefinedOrder::operator=(TypeDefinedOrder&& other223) {
  (void) other223;
  return *this;
}
void TypeDefinedOrder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TypeDefinedOrder(";
  out << ")";
}


ColumnOrder::~ColumnOrder() throw() {
}


void ColumnOrder::__set_TYPE_ORDER(const TypeDefinedOrder& val) {
  this->TYPE_ORDER = val;
__isset.TYPE_ORDER = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnOrder& obj)
{
  obj.printTo(out);
  return out;
}


void swap(ColumnOrder &a, ColumnOrder &b) {
  using ::std::swap;
  swap(a.TYPE_ORDER, b.TYPE_ORDER);
  swap(a.__isset, b.__isset);
}

ColumnOrder::ColumnOrder(const ColumnOrder& other224) {
  TYPE_ORDER = other224.TYPE_ORDER;
  __isset = other224.__isset;
}
ColumnOrder::ColumnOrder( ColumnOrder&& other225) {
  TYPE_ORDER = std::move(other225.TYPE_ORDER);
  __isset = std::move(other225.__isset);
}
ColumnOrder& ColumnOrder::operator=(const ColumnOrder& other226) {
  TYPE_ORDER = other226.TYPE_ORDER;
  __isset = other226.__isset;
  return *this;
}
ColumnOrder& ColumnOrder::operator=(ColumnOrder&& other227) {
  TYPE_ORDER = std::move(other227.TYPE_ORDER);
  __isset = std::move(other227.__isset);
  return *this;
}
void ColumnOrder::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnOrder(";
  out << "TYPE_ORDER="; (__isset.TYPE_ORDER ? (out << to_string(TYPE_ORDER)) : (out << "<null>"));
  out << ")";
}


PageLocation::~PageLocation() throw() {
}


void PageLocation::__set_offset(const int64_t val) {
  this->offset = val;
}

void PageLocation::__set_compressed_page_size(const int32_t val) {
  this->compressed_page_size = val;
}

void PageLocation::__set_first_row_index(const int64_t val) {
  this->first_row_index = val;
}
std::ostream& operator<<(std::ostream& out, const PageLocation& obj)
{
  obj.printTo(out);
  return out;
}


void swap(PageLocation &a, PageLocation &b) {
  using ::std::swap;
  swap(a.offset, b.offset);
  swap(a.compressed_page_size, b.compressed_page_size);
  swap(a.first_row_index, b.first_row_index);
}

PageLocation::PageLocation(const PageLocation& other228) {
  offset = other228.offset;
  compressed_page_size = other228.compressed_page_size;
  first_row_index = other228.first_row_index;
}
PageLocation::PageLocation( PageLocation&& other229) {
  offset = std::move(other229.offset);
  compressed_page_size = std::move(other229.compressed_page_size);
  first_row_index = std::move(other229.first_row_index);
}
PageLocation& PageLocation::operator=(const PageLocation& other230) {
  offset = other230.offset;
  compressed_page_size = other230.compressed_page_size;
  first_row_index = other230.first_row_index;
  return *this;
}
PageLocation& PageLocation::operator=(PageLocation&& other231) {
  offset = std::move(other231.offset);
  compressed_page_size = std::move(other231.compressed_page_size);
  first_row_index = std::move(other231.first_row_index);
  return *this;
}
void PageLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageLocation(";
  out << "offset=" << to_string(offset);
  out << ", " << "compressed_page_size=" << to_string(compressed_page_size);
  out << ", " << "first_row_index=" << to_string(first_row_index);
  out << ")";
}


OffsetIndex::~OffsetIndex() throw() {
}


void OffsetIndex::__set_page_locations(const std::vector<PageLocation> & val) {
  this->page_locations = val;
}
std::ostream& operator<<(std::ostream& out, const OffsetIndex& obj)
{
  obj.printTo(out);
  return out;
}


void swap(OffsetIndex &a, OffsetIndex &b) {
  using ::std::swap;
  swap(a.page_locations, b.page_locations);
}

OffsetIndex::OffsetIndex(const OffsetIndex& other238) {
  page_locations = other238.page_locations;
}
OffsetIndex::OffsetIndex( OffsetIndex&& other239) {
  page_locations = std::move(other239.page_locations);
}
OffsetIndex& OffsetIndex::operator=(const OffsetIndex& other240) {
  page_locations = other240.page_locations;
  return *this;
}
OffsetIndex& OffsetIndex::operator=(OffsetIndex&& other241) {
  page_locations = std::move(other241.page_locations);
  return *this;
}
void OffsetIndex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OffsetIndex(";
  out << "page_locations=" << to_string(page_locations);
  out << ")";
}


ColumnIndex::~ColumnIndex() throw() {
}


void ColumnIndex::__set_null_pages(const std::vector<bool> & val) {
  this->null_pages = val;
}

void ColumnIndex::__set_min_values(const std::vector<std::string> & val) {
  this->min_values = val;
}

void ColumnIndex::__set_max_values(const std::vector<std::string> & val) {
  this->max_values = val;
}

void ColumnIndex::__set_boundary_order(const BoundaryOrder::type val) {
  this->boundary_order = val;
}

void ColumnIndex::__set_null_counts(const std::vector<int64_t> & val) {
  this->null_counts = val;
__isset.null_counts = true;
}
std::ostream& operator<<(std::ostream& out, const ColumnIndex& obj)
{
  obj.printTo(out);
  return out;
}


void swap(ColumnIndex &a, ColumnIndex &b) {
  using ::std::swap;
  swap(a.null_pages, b.null_pages);
  swap(a.min_values, b.min_values);
  swap(a.max_values, b.max_values);
  swap(a.boundary_order, b.boundary_order);
  swap(a.null_counts, b.null_counts);
  swap(a.__isset, b.__isset);
}

ColumnIndex::ColumnIndex(const ColumnIndex& other267) {
  null_pages = other267.null_pages;
  min_values = other267.min_values;
  max_values = other267.max_values;
  boundary_order = other267.boundary_order;
  null_counts = other267.null_counts;
  __isset = other267.__isset;
}
ColumnIndex::ColumnIndex( ColumnIndex&& other268) {
  null_pages = std::move(other268.null_pages);
  min_values = std::move(other268.min_values);
  max_values = std::move(other268.max_values);
  boundary_order = std::move(other268.boundary_order);
  null_counts = std::move(other268.null_counts);
  __isset = std::move(other268.__isset);
}
ColumnIndex& ColumnIndex::operator=(const ColumnIndex& other269) {
  null_pages = other269.null_pages;
  min_values = other269.min_values;
  max_values = other269.max_values;
  boundary_order = other269.boundary_order;
  null_counts = other269.null_counts;
  __isset = other269.__isset;
  return *this;
}
ColumnIndex& ColumnIndex::operator=(ColumnIndex&& other270) {
  null_pages = std::move(other270.null_pages);
  min_values = std::move(other270.min_values);
  max_values = std::move(other270.max_values);
  boundary_order = std::move(other270.boundary_order);
  null_counts = std::move(other270.null_counts);
  __isset = std::move(other270.__isset);
  return *this;
}
void ColumnIndex::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnIndex(";
  out << "null_pages=" << to_string(null_pages);
  out << ", " << "min_values=" << to_string(min_values);
  out << ", " << "max_values=" << to_string(max_values);
  out << ", " << "boundary_order=" << to_string(boundary_order);
  out << ", " << "null_counts="; (__isset.null_counts ? (out << to_string(null_counts)) : (out << "<null>"));
  out << ")";
}


AesGcmV1::~AesGcmV1() throw() {
}


void AesGcmV1::__set_aad_prefix(const std::string& val) {
  this->aad_prefix = val;
__isset.aad_prefix = true;
}

void AesGcmV1::__set_aad_file_unique(const std::string& val) {
  this->aad_file_unique = val;
__isset.aad_file_unique = true;
}

void AesGcmV1::__set_supply_aad_prefix(const bool val) {
  this->supply_aad_prefix = val;
__isset.supply_aad_prefix = true;
}
std::ostream& operator<<(std::ostream& out, const AesGcmV1& obj)
{
  obj.printTo(out);
  return out;
}


void swap(AesGcmV1 &a, AesGcmV1 &b) {
  using ::std::swap;
  swap(a.aad_prefix, b.aad_prefix);
  swap(a.aad_file_unique, b.aad_file_unique);
  swap(a.supply_aad_prefix, b.supply_aad_prefix);
  swap(a.__isset, b.__isset);
}

AesGcmV1::AesGcmV1(const AesGcmV1& other271) {
  aad_prefix = other271.aad_prefix;
  aad_file_unique = other271.aad_file_unique;
  supply_aad_prefix = other271.supply_aad_prefix;
  __isset = other271.__isset;
}
AesGcmV1::AesGcmV1( AesGcmV1&& other272) {
  aad_prefix = std::move(other272.aad_prefix);
  aad_file_unique = std::move(other272.aad_file_unique);
  supply_aad_prefix = std::move(other272.supply_aad_prefix);
  __isset = std::move(other272.__isset);
}
AesGcmV1& AesGcmV1::operator=(const AesGcmV1& other273) {
  aad_prefix = other273.aad_prefix;
  aad_file_unique = other273.aad_file_unique;
  supply_aad_prefix = other273.supply_aad_prefix;
  __isset = other273.__isset;
  return *this;
}
AesGcmV1& AesGcmV1::operator=(AesGcmV1&& other274) {
  aad_prefix = std::move(other274.aad_prefix);
  aad_file_unique = std::move(other274.aad_file_unique);
  supply_aad_prefix = std::move(other274.supply_aad_prefix);
  __isset = std::move(other274.__isset);
  return *this;
}
void AesGcmV1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AesGcmV1(";
  out << "aad_prefix="; (__isset.aad_prefix ? (out << to_string(aad_prefix)) : (out << "<null>"));
  out << ", " << "aad_file_unique="; (__isset.aad_file_unique ? (out << to_string(aad_file_unique)) : (out << "<null>"));
  out << ", " << "supply_aad_prefix="; (__isset.supply_aad_prefix ? (out << to_string(supply_aad_prefix)) : (out << "<null>"));
  out << ")";
}


AesGcmCtrV1::~AesGcmCtrV1() throw() {
}


void AesGcmCtrV1::__set_aad_prefix(const std::string& val) {
  this->aad_prefix = val;
__isset.aad_prefix = true;
}

void AesGcmCtrV1::__set_aad_file_unique(const std::string& val) {
  this->aad_file_unique = val;
__isset.aad_file_unique = true;
}

void AesGcmCtrV1::__set_supply_aad_prefix(const bool val) {
  this->supply_aad_prefix = val;
__isset.supply_aad_prefix = true;
}
std::ostream& operator<<(std::ostream& out, const AesGcmCtrV1& obj)
{
  obj.printTo(out);
  return out;
}


void swap(AesGcmCtrV1 &a, AesGcmCtrV1 &b) {
  using ::std::swap;
  swap(a.aad_prefix, b.aad_prefix);
  swap(a.aad_file_unique, b.aad_file_unique);
  swap(a.supply_aad_prefix, b.supply_aad_prefix);
  swap(a.__isset, b.__isset);
}

AesGcmCtrV1::AesGcmCtrV1(const AesGcmCtrV1& other275) {
  aad_prefix = other275.aad_prefix;
  aad_file_unique = other275.aad_file_unique;
  supply_aad_prefix = other275.supply_aad_prefix;
  __isset = other275.__isset;
}
AesGcmCtrV1::AesGcmCtrV1( AesGcmCtrV1&& other276) {
  aad_prefix = std::move(other276.aad_prefix);
  aad_file_unique = std::move(other276.aad_file_unique);
  supply_aad_prefix = std::move(other276.supply_aad_prefix);
  __isset = std::move(other276.__isset);
}
AesGcmCtrV1& AesGcmCtrV1::operator=(const AesGcmCtrV1& other277) {
  aad_prefix = other277.aad_prefix;
  aad_file_unique = other277.aad_file_unique;
  supply_aad_prefix = other277.supply_aad_prefix;
  __isset = other277.__isset;
  return *this;
}
AesGcmCtrV1& AesGcmCtrV1::operator=(AesGcmCtrV1&& other278) {
  aad_prefix = std::move(other278.aad_prefix);
  aad_file_unique = std::move(other278.aad_file_unique);
  supply_aad_prefix = std::move(other278.supply_aad_prefix);
  __isset = std::move(other278.__isset);
  return *this;
}
void AesGcmCtrV1::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AesGcmCtrV1(";
  out << "aad_prefix="; (__isset.aad_prefix ? (out << to_string(aad_prefix)) : (out << "<null>"));
  out << ", " << "aad_file_unique="; (__isset.aad_file_unique ? (out << to_string(aad_file_unique)) : (out << "<null>"));
  out << ", " << "supply_aad_prefix="; (__isset.supply_aad_prefix ? (out << to_string(supply_aad_prefix)) : (out << "<null>"));
  out << ")";
}


EncryptionAlgorithm::~EncryptionAlgorithm() throw() {
}


void EncryptionAlgorithm::__set_AES_GCM_V1(const AesGcmV1& val) {
  this->AES_GCM_V1 = val;
__isset.AES_GCM_V1 = true;
}

void EncryptionAlgorithm::__set_AES_GCM_CTR_V1(const AesGcmCtrV1& val) {
  this->AES_GCM_CTR_V1 = val;
__isset.AES_GCM_CTR_V1 = true;
}
std::ostream& operator<<(std::ostream& out, const EncryptionAlgorithm& obj)
{
  obj.printTo(out);
  return out;
}


void swap(EncryptionAlgorithm &a, EncryptionAlgorithm &b) {
  using ::std::swap;
  swap(a.AES_GCM_V1, b.AES_GCM_V1);
  swap(a.AES_GCM_CTR_V1, b.AES_GCM_CTR_V1);
  swap(a.__isset, b.__isset);
}

EncryptionAlgorithm::EncryptionAlgorithm(const EncryptionAlgorithm& other279) {
  AES_GCM_V1 = other279.AES_GCM_V1;
  AES_GCM_CTR_V1 = other279.AES_GCM_CTR_V1;
  __isset = other279.__isset;
}
EncryptionAlgorithm::EncryptionAlgorithm( EncryptionAlgorithm&& other280) {
  AES_GCM_V1 = std::move(other280.AES_GCM_V1);
  AES_GCM_CTR_V1 = std::move(other280.AES_GCM_CTR_V1);
  __isset = std::move(other280.__isset);
}
EncryptionAlgorithm& EncryptionAlgorithm::operator=(const EncryptionAlgorithm& other281) {
  AES_GCM_V1 = other281.AES_GCM_V1;
  AES_GCM_CTR_V1 = other281.AES_GCM_CTR_V1;
  __isset = other281.__isset;
  return *this;
}
EncryptionAlgorithm& EncryptionAlgorithm::operator=(EncryptionAlgorithm&& other282) {
  AES_GCM_V1 = std::move(other282.AES_GCM_V1);
  AES_GCM_CTR_V1 = std::move(other282.AES_GCM_CTR_V1);
  __isset = std::move(other282.__isset);
  return *this;
}
void EncryptionAlgorithm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EncryptionAlgorithm(";
  out << "AES_GCM_V1="; (__isset.AES_GCM_V1 ? (out << to_string(AES_GCM_V1)) : (out << "<null>"));
  out << ", " << "AES_GCM_CTR_V1="; (__isset.AES_GCM_CTR_V1 ? (out << to_string(AES_GCM_CTR_V1)) : (out << "<null>"));
  out << ")";
}


FileMetaData::~FileMetaData() throw() {
}


void FileMetaData::__set_version(const int32_t val) {
  this->version = val;
}

void FileMetaData::__set_schema(const std::vector<SchemaElement> & val) {
  this->schema = val;
}

void FileMetaData::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void FileMetaData::__set_row_groups(const std::vector<RowGroup> & val) {
  this->row_groups = val;
}

void FileMetaData::__set_key_value_metadata(const std::vector<KeyValue> & val) {
  this->key_value_metadata = val;
__isset.key_value_metadata = true;
}

void FileMetaData::__set_created_by(const std::string& val) {
  this->created_by = val;
__isset.created_by = true;
}

void FileMetaData::__set_column_orders(const std::vector<ColumnOrder> & val) {
  this->column_orders = val;
__isset.column_orders = true;
}

void FileMetaData::__set_encryption_algorithm(const EncryptionAlgorithm& val) {
  this->encryption_algorithm = val;
__isset.encryption_algorithm = true;
}

void FileMetaData::__set_footer_signing_key_metadata(const std::string& val) {
  this->footer_signing_key_metadata = val;
__isset.footer_signing_key_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const FileMetaData& obj)
{
  obj.printTo(out);
  return out;
}


void swap(FileMetaData &a, FileMetaData &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.schema, b.schema);
  swap(a.num_rows, b.num_rows);
  swap(a.row_groups, b.row_groups);
  swap(a.key_value_metadata, b.key_value_metadata);
  swap(a.created_by, b.created_by);
  swap(a.column_orders, b.column_orders);
  swap(a.encryption_algorithm, b.encryption_algorithm);
  swap(a.footer_signing_key_metadata, b.footer_signing_key_metadata);
  swap(a.__isset, b.__isset);
}

FileMetaData::FileMetaData(const FileMetaData& other307) {
  version = other307.version;
  schema = other307.schema;
  num_rows = other307.num_rows;
  row_groups = other307.row_groups;
  key_value_metadata = other307.key_value_metadata;
  created_by = other307.created_by;
  column_orders = other307.column_orders;
  encryption_algorithm = other307.encryption_algorithm;
  footer_signing_key_metadata = other307.footer_signing_key_metadata;
  __isset = other307.__isset;
}
FileMetaData::FileMetaData( FileMetaData&& other308) {
  version = std::move(other308.version);
  schema = std::move(other308.schema);
  num_rows = std::move(other308.num_rows);
  row_groups = std::move(other308.row_groups);
  key_value_metadata = std::move(other308.key_value_metadata);
  created_by = std::move(other308.created_by);
  column_orders = std::move(other308.column_orders);
  encryption_algorithm = std::move(other308.encryption_algorithm);
  footer_signing_key_metadata = std::move(other308.footer_signing_key_metadata);
  __isset = std::move(other308.__isset);
}
FileMetaData& FileMetaData::operator=(const FileMetaData& other309) {
  version = other309.version;
  schema = other309.schema;
  num_rows = other309.num_rows;
  row_groups = other309.row_groups;
  key_value_metadata = other309.key_value_metadata;
  created_by = other309.created_by;
  column_orders = other309.column_orders;
  encryption_algorithm = other309.encryption_algorithm;
  footer_signing_key_metadata = other309.footer_signing_key_metadata;
  __isset = other309.__isset;
  return *this;
}
FileMetaData& FileMetaData::operator=(FileMetaData&& other310) {
  version = std::move(other310.version);
  schema = std::move(other310.schema);
  num_rows = std::move(other310.num_rows);
  row_groups = std::move(other310.row_groups);
  key_value_metadata = std::move(other310.key_value_metadata);
  created_by = std::move(other310.created_by);
  column_orders = std::move(other310.column_orders);
  encryption_algorithm = std::move(other310.encryption_algorithm);
  footer_signing_key_metadata = std::move(other310.footer_signing_key_metadata);
  __isset = std::move(other310.__isset);
  return *this;
}
void FileMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileMetaData(";
  out << "version=" << to_string(version);
  out << ", " << "schema=" << to_string(schema);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ", " << "row_groups=" << to_string(row_groups);
  out << ", " << "key_value_metadata="; (__isset.key_value_metadata ? (out << to_string(key_value_metadata)) : (out << "<null>"));
  out << ", " << "created_by="; (__isset.created_by ? (out << to_string(created_by)) : (out << "<null>"));
  out << ", " << "column_orders="; (__isset.column_orders ? (out << to_string(column_orders)) : (out << "<null>"));
  out << ", " << "encryption_algorithm="; (__isset.encryption_algorithm ? (out << to_string(encryption_algorithm)) : (out << "<null>"));
  out << ", " << "footer_signing_key_metadata="; (__isset.footer_signing_key_metadata ? (out << to_string(footer_signing_key_metadata)) : (out << "<null>"));
  out << ")";
}


FileCryptoMetaData::~FileCryptoMetaData() throw() {
}


void FileCryptoMetaData::__set_encryption_algorithm(const EncryptionAlgorithm& val) {
  this->encryption_algorithm = val;
}

void FileCryptoMetaData::__set_key_metadata(const std::string& val) {
  this->key_metadata = val;
__isset.key_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const FileCryptoMetaData& obj)
{
  obj.printTo(out);
  return out;
}


void swap(FileCryptoMetaData &a, FileCryptoMetaData &b) {
  using ::std::swap;
  swap(a.encryption_algorithm, b.encryption_algorithm);
  swap(a.key_metadata, b.key_metadata);
  swap(a.__isset, b.__isset);
}

FileCryptoMetaData::FileCryptoMetaData(const FileCryptoMetaData& other311) {
  encryption_algorithm = other311.encryption_algorithm;
  key_metadata = other311.key_metadata;
  __isset = other311.__isset;
}
FileCryptoMetaData::FileCryptoMetaData( FileCryptoMetaData&& other312) {
  encryption_algorithm = std::move(other312.encryption_algorithm);
  key_metadata = std::move(other312.key_metadata);
  __isset = std::move(other312.__isset);
}
FileCryptoMetaData& FileCryptoMetaData::operator=(const FileCryptoMetaData& other313) {
  encryption_algorithm = other313.encryption_algorithm;
  key_metadata = other313.key_metadata;
  __isset = other313.__isset;
  return *this;
}
FileCryptoMetaData& FileCryptoMetaData::operator=(FileCryptoMetaData&& other314) {
  encryption_algorithm = std::move(other314.encryption_algorithm);
  key_metadata = std::move(other314.key_metadata);
  __isset = std::move(other314.__isset);
  return *this;
}
void FileCryptoMetaData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileCryptoMetaData(";
  out << "encryption_algorithm=" << to_string(encryption_algorithm);
  out << ", " << "key_metadata="; (__isset.key_metadata ? (out << to_string(key_metadata)) : (out << "<null>"));
  out << ")";
}

} // namespace
