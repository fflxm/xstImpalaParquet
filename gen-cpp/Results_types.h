/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Results_TYPES_H
#define Results_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "Data_types.h"
#include "Types_types.h"
#include "CatalogObjects_types.h"


namespace impala {

class TRowBatch;

class TResultSetMetadata;

class TResultSet;

typedef struct _TRowBatch__isset {
  _TRowBatch__isset() : tuple_offsets(false), tuple_data(false), uncompressed_size(false) {}
  bool tuple_offsets :1;
  bool tuple_data :1;
  bool uncompressed_size :1;
} _TRowBatch__isset;

class TRowBatch {
 public:

  TRowBatch(const TRowBatch&);
  TRowBatch(TRowBatch&&);
  TRowBatch& operator=(const TRowBatch&);
  TRowBatch& operator=(TRowBatch&&);
  TRowBatch() : num_rows(0), tuple_data(), compression_type(( ::impala::THdfsCompression::type)0), uncompressed_size(0) {
  }

  virtual ~TRowBatch() throw();
  int32_t num_rows;
  std::vector< ::impala::TTupleId>  row_tuples;
  std::vector<int32_t>  tuple_offsets;
  std::string tuple_data;
   ::impala::THdfsCompression::type compression_type;
  int32_t uncompressed_size;

  _TRowBatch__isset __isset;

  void __set_num_rows(const int32_t val);

  void __set_row_tuples(const std::vector< ::impala::TTupleId> & val);

  void __set_tuple_offsets(const std::vector<int32_t> & val);

  void __set_tuple_data(const std::string& val);

  void __set_compression_type(const  ::impala::THdfsCompression::type val);

  void __set_uncompressed_size(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRowBatch &a, TRowBatch &b);

std::ostream& operator<<(std::ostream& out, const TRowBatch& obj);


class TResultSetMetadata {
 public:

  TResultSetMetadata(const TResultSetMetadata&);
  TResultSetMetadata(TResultSetMetadata&&);
  TResultSetMetadata& operator=(const TResultSetMetadata&);
  TResultSetMetadata& operator=(TResultSetMetadata&&);
  TResultSetMetadata() {
  }

  virtual ~TResultSetMetadata() throw();
  std::vector< ::impala::TColumn>  columns;

  void __set_columns(const std::vector< ::impala::TColumn> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TResultSetMetadata &a, TResultSetMetadata &b);

std::ostream& operator<<(std::ostream& out, const TResultSetMetadata& obj);


class TResultSet {
 public:

  TResultSet(const TResultSet&);
  TResultSet(TResultSet&&);
  TResultSet& operator=(const TResultSet&);
  TResultSet& operator=(TResultSet&&);
  TResultSet() {
  }

  virtual ~TResultSet() throw();
  std::vector< ::impala::TResultRow>  rows;
  TResultSetMetadata schema;

  void __set_rows(const std::vector< ::impala::TResultRow> & val);

  void __set_schema(const TResultSetMetadata& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TResultSet &a, TResultSet &b);

std::ostream& operator<<(std::ostream& out, const TResultSet& obj);

} // namespace

#include "Results_types.tcc"

#endif
