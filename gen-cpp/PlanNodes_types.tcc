/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlanNodes_TYPES_TCC
#define PlanNodes_TYPES_TCC

#include "CatalogObjects_types.tcc"
#include "Data_types.tcc"
#include "ExecStats_types.tcc"
#include "Exprs_types.tcc"
#include "Types_types.tcc"
#include "ExternalDataSource_types.tcc"
#include "ResourceProfile_types.tcc"
#include "PlanNodes_types.h"

namespace impala {

template <class Protocol_>
uint32_t TRuntimeFilterTargetDesc::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_target_expr = false;
  bool isset_is_bound_by_partition_columns = false;
  bool isset_target_expr_slotids = false;
  bool isset_is_local_target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target_expr.read(iprot);
          isset_target_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_bound_by_partition_columns);
          isset_is_bound_by_partition_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->target_expr_slotids.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->target_expr_slotids.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->target_expr_slotids[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_target_expr_slotids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_local_target);
          isset_is_local_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->kudu_col_name);
          this->__isset.kudu_col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kudu_col_type.read(iprot);
          this->__isset.kudu_col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->low_value.read(iprot);
          this->__isset.low_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->high_value.read(iprot);
          this->__isset.high_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_min_max_value_present);
          this->__isset.is_min_max_value_present = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_column_in_data_file);
          this->__isset.is_column_in_data_file = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_target_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_bound_by_partition_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target_expr_slotids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_local_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TRuntimeFilterTargetDesc::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRuntimeFilterTargetDesc");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_expr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_bound_by_partition_columns", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_bound_by_partition_columns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_expr_slotids", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->target_expr_slotids.size()));
    std::vector< ::impala::TSlotId> ::const_iterator _iter5;
    for (_iter5 = this->target_expr_slotids.begin(); _iter5 != this->target_expr_slotids.end(); ++_iter5)
    {
      xfer += oprot->writeI32((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_local_target", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_local_target);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.kudu_col_name) {
    xfer += oprot->writeFieldBegin("kudu_col_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->kudu_col_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_col_type) {
    xfer += oprot->writeFieldBegin("kudu_col_type", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->kudu_col_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.low_value) {
    xfer += oprot->writeFieldBegin("low_value", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->low_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.high_value) {
    xfer += oprot->writeFieldBegin("high_value", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->high_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_min_max_value_present) {
    xfer += oprot->writeFieldBegin("is_min_max_value_present", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_min_max_value_present);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_column_in_data_file) {
    xfer += oprot->writeFieldBegin("is_column_in_data_file", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_column_in_data_file);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TRuntimeFilterDesc::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_filter_id = false;
  bool isset_src_expr = false;
  bool isset_targets = false;
  bool isset_planid_to_target_ndx = false;
  bool isset_is_broadcast_join = false;
  bool isset_has_local_targets = false;
  bool isset_has_remote_targets = false;
  bool isset_applied_on_partition_columns = false;
  bool isset_type = false;
  bool isset_compareOp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->filter_id);
          isset_filter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->src_expr.read(iprot);
          isset_src_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->targets.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->targets[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->planid_to_target_ndx.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _ktype16;
            ::apache::thrift::protocol::TType _vtype17;
            xfer += iprot->readMapBegin(_ktype16, _vtype17, _size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
               ::impala::TPlanNodeId _key20;
              xfer += iprot->readI32(_key20);
              int32_t& _val21 = this->planid_to_target_ndx[_key20];
              xfer += iprot->readI32(_val21);
            }
            xfer += iprot->readMapEnd();
          }
          isset_planid_to_target_ndx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_broadcast_join);
          isset_is_broadcast_join = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_local_targets);
          isset_has_local_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_remote_targets);
          isset_has_remote_targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->applied_on_partition_columns);
          isset_applied_on_partition_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ndv_estimate);
          this->__isset.ndv_estimate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->type = (TRuntimeFilterType::type)ecast22;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast23;
          xfer += iprot->readI32(ecast23);
          this->compareOp = ( ::impala::extdatasource::TComparisonOp::type)ecast23;
          isset_compareOp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->filter_size_bytes);
          this->__isset.filter_size_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->src_node_id);
          this->__isset.src_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_filter_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_expr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_planid_to_target_ndx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_broadcast_join)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_local_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_remote_targets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_applied_on_partition_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compareOp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TRuntimeFilterDesc::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRuntimeFilterDesc");

  xfer += oprot->writeFieldBegin("filter_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->filter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_expr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->src_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->targets.size()));
    std::vector<TRuntimeFilterTargetDesc> ::const_iterator _iter24;
    for (_iter24 = this->targets.begin(); _iter24 != this->targets.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("planid_to_target_ndx", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->planid_to_target_ndx.size()));
    std::map< ::impala::TPlanNodeId, int32_t> ::const_iterator _iter25;
    for (_iter25 = this->planid_to_target_ndx.begin(); _iter25 != this->planid_to_target_ndx.end(); ++_iter25)
    {
      xfer += oprot->writeI32(_iter25->first);
      xfer += oprot->writeI32(_iter25->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_broadcast_join", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_broadcast_join);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_local_targets", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->has_local_targets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_remote_targets", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->has_remote_targets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("applied_on_partition_columns", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->applied_on_partition_columns);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ndv_estimate) {
    xfer += oprot->writeFieldBegin("ndv_estimate", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->ndv_estimate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compareOp", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32((int32_t)this->compareOp);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filter_size_bytes) {
    xfer += oprot->writeFieldBegin("filter_size_bytes", ::apache::thrift::protocol::T_I64, 12);
    xfer += oprot->writeI64(this->filter_size_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.src_node_id) {
    xfer += oprot->writeFieldBegin("src_node_id", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32(this->src_node_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsFileSplit::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_relative_path = false;
  bool isset_offset = false;
  bool isset_length = false;
  bool isset_partition_id = false;
  bool isset_file_length = false;
  bool isset_file_compression = false;
  bool isset_mtime = false;
  bool isset_partition_path_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->relative_path);
          isset_relative_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          isset_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->length);
          isset_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partition_id);
          isset_partition_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->file_length);
          isset_file_length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast30;
          xfer += iprot->readI32(ecast30);
          this->file_compression = ( ::impala::THdfsCompression::type)ecast30;
          isset_file_compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mtime);
          isset_mtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_path_hash);
          isset_partition_path_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_relative_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_offset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_length)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_compression)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mtime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_path_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsFileSplit::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsFileSplit");

  xfer += oprot->writeFieldBegin("relative_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->relative_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->partition_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_length", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->file_length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_compression", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->file_compression);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mtime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->mtime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_path_hash", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->partition_path_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THBaseKeyRange::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stopKey);
          this->__isset.stopKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t THBaseKeyRange::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THBaseKeyRange");

  if (this->__isset.startKey) {
    xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->startKey);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stopKey) {
    xfer += oprot->writeFieldBegin("stopKey", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->stopKey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TFileSplitGeneratorSpec::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_desc = false;
  bool isset_max_block_size = false;
  bool isset_is_splittable = false;
  bool isset_partition_id = false;
  bool isset_partition_path_hash = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->file_desc.read(iprot);
          isset_file_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_block_size);
          isset_max_block_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_splittable);
          isset_is_splittable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->partition_id);
          isset_partition_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_path_hash);
          isset_partition_path_hash = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_block_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_splittable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_path_hash)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TFileSplitGeneratorSpec::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TFileSplitGeneratorSpec");

  xfer += oprot->writeFieldBegin("file_desc", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->file_desc.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_block_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max_block_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_splittable", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_splittable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->partition_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_path_hash", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->partition_path_hash);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TScanRange::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_file_split.read(iprot);
          this->__isset.hdfs_file_split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbase_key_range.read(iprot);
          this->__isset.hbase_key_range = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->kudu_scan_token);
          this->__isset.kudu_scan_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TScanRange::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TScanRange");

  if (this->__isset.hdfs_file_split) {
    xfer += oprot->writeFieldBegin("hdfs_file_split", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->hdfs_file_split.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbase_key_range) {
    xfer += oprot->writeFieldBegin("hbase_key_range", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->hbase_key_range.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_scan_token) {
    xfer += oprot->writeFieldBegin("kudu_scan_token", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->kudu_scan_token);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TOverlapPredicateDesc::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_filter_id = false;
  bool isset_slot_index = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->filter_id);
          isset_filter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slot_index);
          isset_slot_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_filter_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slot_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TOverlapPredicateDesc::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOverlapPredicateDesc");

  xfer += oprot->writeFieldBegin("filter_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->filter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slot_index", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->slot_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsScanNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_file_formats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->collection_conjuncts.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _ktype52;
            ::apache::thrift::protocol::TType _vtype53;
            xfer += iprot->readMapBegin(_ktype52, _vtype53, _size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
               ::impala::TTupleId _key56;
              xfer += iprot->readI32(_key56);
              std::vector< ::impala::TExpr> & _val57 = this->collection_conjuncts[_key56];
              {
                _val57.clear();
                uint32_t _size58;
                ::apache::thrift::protocol::TType _etype61;
                xfer += iprot->readListBegin(_etype61, _size58);
                _val57.resize(_size58);
                uint32_t _i62;
                for (_i62 = 0; _i62 < _size58; ++_i62)
                {
                  xfer += _val57[_i62].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.collection_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->replica_preference = (TReplicaPreference::type)ecast63;
          this->__isset.replica_preference = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->random_replica);
          this->__isset.random_replica = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skip_header_line_count);
          this->__isset.skip_header_line_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_mt_scan_node);
          this->__isset.use_mt_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stats_conjuncts.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->stats_conjuncts.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->stats_conjuncts[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stats_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->stats_tuple_id);
          this->__isset.stats_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dictionary_filter_conjuncts.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _ktype70;
            ::apache::thrift::protocol::TType _vtype71;
            xfer += iprot->readMapBegin(_ktype70, _vtype71, _size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
               ::impala::TSlotId _key74;
              xfer += iprot->readI32(_key74);
              std::vector<int32_t> & _val75 = this->dictionary_filter_conjuncts[_key74];
              {
                _val75.clear();
                uint32_t _size76;
                ::apache::thrift::protocol::TType _etype79;
                xfer += iprot->readListBegin(_etype79, _size76);
                _val75.resize(_size76);
                uint32_t _i80;
                for (_i80 = 0; _i80 < _size76; ++_i80)
                {
                  xfer += iprot->readI32(_val75[_i80]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dictionary_filter_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parquet_count_star_slot_offset);
          this->__isset.parquet_count_star_slot_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_partition_key_scan);
          this->__isset.is_partition_key_scan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->file_formats.clear();
            uint32_t _size81;
            ::apache::thrift::protocol::TType _etype84;
            xfer += iprot->readSetBegin(_etype84, _size81);
            uint32_t _i85;
            for (_i85 = 0; _i85 < _size81; ++_i85)
            {
               ::impala::THdfsFileFormat::type _elem86;
              int32_t ecast87;
              xfer += iprot->readI32(ecast87);
              _elem86 = ( ::impala::THdfsFileFormat::type)ecast87;
              this->file_formats.insert(_elem86);
            }
            xfer += iprot->readSetEnd();
          }
          isset_file_formats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->overlap_predicate_descs.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->overlap_predicate_descs.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->overlap_predicate_descs[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.overlap_predicate_descs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_formats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsScanNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.collection_conjuncts) {
    xfer += oprot->writeFieldBegin("collection_conjuncts", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->collection_conjuncts.size()));
      std::map< ::impala::TTupleId, std::vector< ::impala::TExpr> > ::const_iterator _iter93;
      for (_iter93 = this->collection_conjuncts.begin(); _iter93 != this->collection_conjuncts.end(); ++_iter93)
      {
        xfer += oprot->writeI32(_iter93->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter93->second.size()));
          std::vector< ::impala::TExpr> ::const_iterator _iter94;
          for (_iter94 = _iter93->second.begin(); _iter94 != _iter93->second.end(); ++_iter94)
          {
            xfer += (*_iter94).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replica_preference) {
    xfer += oprot->writeFieldBegin("replica_preference", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->replica_preference);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.random_replica) {
    xfer += oprot->writeFieldBegin("random_replica", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->random_replica);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.skip_header_line_count) {
    xfer += oprot->writeFieldBegin("skip_header_line_count", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->skip_header_line_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.use_mt_scan_node) {
    xfer += oprot->writeFieldBegin("use_mt_scan_node", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->use_mt_scan_node);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stats_conjuncts) {
    xfer += oprot->writeFieldBegin("stats_conjuncts", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stats_conjuncts.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter95;
      for (_iter95 = this->stats_conjuncts.begin(); _iter95 != this->stats_conjuncts.end(); ++_iter95)
      {
        xfer += (*_iter95).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stats_tuple_id) {
    xfer += oprot->writeFieldBegin("stats_tuple_id", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->stats_tuple_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dictionary_filter_conjuncts) {
    xfer += oprot->writeFieldBegin("dictionary_filter_conjuncts", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->dictionary_filter_conjuncts.size()));
      std::map< ::impala::TSlotId, std::vector<int32_t> > ::const_iterator _iter96;
      for (_iter96 = this->dictionary_filter_conjuncts.begin(); _iter96 != this->dictionary_filter_conjuncts.end(); ++_iter96)
      {
        xfer += oprot->writeI32(_iter96->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(_iter96->second.size()));
          std::vector<int32_t> ::const_iterator _iter97;
          for (_iter97 = _iter96->second.begin(); _iter97 != _iter96->second.end(); ++_iter97)
          {
            xfer += oprot->writeI32((*_iter97));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parquet_count_star_slot_offset) {
    xfer += oprot->writeFieldBegin("parquet_count_star_slot_offset", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->parquet_count_star_slot_offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_partition_key_scan) {
    xfer += oprot->writeFieldBegin("is_partition_key_scan", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_partition_key_scan);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("file_formats", ::apache::thrift::protocol::T_SET, 12);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->file_formats.size()));
    std::set< ::impala::THdfsFileFormat::type> ::const_iterator _iter98;
    for (_iter98 = this->file_formats.begin(); _iter98 != this->file_formats.end(); ++_iter98)
    {
      xfer += oprot->writeI32((int32_t)(*_iter98));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.overlap_predicate_descs) {
    xfer += oprot->writeFieldBegin("overlap_predicate_descs", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->overlap_predicate_descs.size()));
      std::vector<TOverlapPredicateDesc> ::const_iterator _iter99;
      for (_iter99 = this->overlap_predicate_descs.begin(); _iter99 != this->overlap_predicate_descs.end(); ++_iter99)
      {
        xfer += (*_iter99).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDataSourceScanNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_data_source = false;
  bool isset_init_string = false;
  bool isset_accepted_predicates = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source.read(iprot);
          isset_data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_string);
          isset_init_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->accepted_predicates.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->accepted_predicates.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              {
                this->accepted_predicates[_i108].clear();
                uint32_t _size109;
                ::apache::thrift::protocol::TType _etype112;
                xfer += iprot->readListBegin(_etype112, _size109);
                this->accepted_predicates[_i108].resize(_size109);
                uint32_t _i113;
                for (_i113 = 0; _i113 < _size109; ++_i113)
                {
                  xfer += this->accepted_predicates[_i108][_i113].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_accepted_predicates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_init_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_accepted_predicates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDataSourceScanNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSourceScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data_source.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("init_string", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->init_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accepted_predicates", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->accepted_predicates.size()));
    std::vector<std::vector< ::impala::extdatasource::TBinaryPredicate> > ::const_iterator _iter114;
    for (_iter114 = this->accepted_predicates.begin(); _iter114 != this->accepted_predicates.end(); ++_iter114)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter114).size()));
        std::vector< ::impala::extdatasource::TBinaryPredicate> ::const_iterator _iter115;
        for (_iter115 = (*_iter114).begin(); _iter115 != (*_iter114).end(); ++_iter115)
        {
          xfer += (*_iter115).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THBaseFilter::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_family = false;
  bool isset_op_ordinal = false;
  bool isset_filter_constant = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->family);
          isset_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->qualifier);
          this->__isset.qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->op_ordinal);
          isset_op_ordinal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter_constant);
          isset_filter_constant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_family)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_op_ordinal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filter_constant)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THBaseFilter::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THBaseFilter");

  xfer += oprot->writeFieldBegin("family", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->family);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.qualifier) {
    xfer += oprot->writeFieldBegin("qualifier", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->qualifier);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("op_ordinal", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->op_ordinal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter_constant", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->filter_constant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THBaseScanNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _etype127;
            xfer += iprot->readListBegin(_etype127, _size124);
            this->filters.resize(_size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              xfer += this->filters[_i128].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->suggested_max_caching);
          this->__isset.suggested_max_caching = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THBaseScanNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THBaseScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filters) {
    xfer += oprot->writeFieldBegin("filters", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->filters.size()));
      std::vector<THBaseFilter> ::const_iterator _iter129;
      for (_iter129 = this->filters.begin(); _iter129 != this->filters.end(); ++_iter129)
      {
        xfer += (*_iter129).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.suggested_max_caching) {
    xfer += oprot->writeFieldBegin("suggested_max_caching", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->suggested_max_caching);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TKuduScanNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_mt_scan_node);
          this->__isset.use_mt_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count_star_slot_offset);
          this->__isset.count_star_slot_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TKuduScanNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduScanNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.use_mt_scan_node) {
    xfer += oprot->writeFieldBegin("use_mt_scan_node", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->use_mt_scan_node);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.count_star_slot_offset) {
    xfer += oprot->writeFieldBegin("count_star_slot_offset", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->count_star_slot_offset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TEqJoinCondition::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_left = false;
  bool isset_right = false;
  bool isset_is_not_distinct_from = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->left.read(iprot);
          isset_left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->right.read(iprot);
          isset_right = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_not_distinct_from);
          isset_is_not_distinct_from = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_left)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_right)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_not_distinct_from)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TEqJoinCondition::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TEqJoinCondition");

  xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->left.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("right", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->right.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_not_distinct_from", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_not_distinct_from);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THashJoinNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_eq_join_conjuncts = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eq_join_conjuncts.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _etype145;
            xfer += iprot->readListBegin(_etype145, _size142);
            this->eq_join_conjuncts.resize(_size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              xfer += this->eq_join_conjuncts[_i146].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_eq_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->other_join_conjuncts.clear();
            uint32_t _size147;
            ::apache::thrift::protocol::TType _etype150;
            xfer += iprot->readListBegin(_etype150, _size147);
            this->other_join_conjuncts.resize(_size147);
            uint32_t _i151;
            for (_i151 = 0; _i151 < _size147; ++_i151)
            {
              xfer += this->other_join_conjuncts[_i151].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.other_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hash_seed);
          this->__isset.hash_seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_eq_join_conjuncts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THashJoinNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THashJoinNode");

  xfer += oprot->writeFieldBegin("eq_join_conjuncts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->eq_join_conjuncts.size()));
    std::vector<TEqJoinCondition> ::const_iterator _iter152;
    for (_iter152 = this->eq_join_conjuncts.begin(); _iter152 != this->eq_join_conjuncts.end(); ++_iter152)
    {
      xfer += (*_iter152).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_join_conjuncts) {
    xfer += oprot->writeFieldBegin("other_join_conjuncts", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_join_conjuncts.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter153;
      for (_iter153 = this->other_join_conjuncts.begin(); _iter153 != this->other_join_conjuncts.end(); ++_iter153)
      {
        xfer += (*_iter153).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hash_seed) {
    xfer += oprot->writeFieldBegin("hash_seed", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->hash_seed);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TNestedLoopJoinNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->join_conjuncts.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size158);
            this->join_conjuncts.resize(_size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162)
            {
              xfer += this->join_conjuncts[_i162].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TNestedLoopJoinNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TNestedLoopJoinNode");

  if (this->__isset.join_conjuncts) {
    xfer += oprot->writeFieldBegin("join_conjuncts", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->join_conjuncts.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter163;
      for (_iter163 = this->join_conjuncts.begin(); _iter163 != this->join_conjuncts.end(); ++_iter163)
      {
        xfer += (*_iter163).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TJoinNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_join_op = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast168;
          xfer += iprot->readI32(ecast168);
          this->join_op = (TJoinOp::type)ecast168;
          isset_join_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->build_tuples.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->build_tuples.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readI32(this->build_tuples[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.build_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nullable_build_tuples.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->nullable_build_tuples.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += iprot->readBool(this->nullable_build_tuples[_i178]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nullable_build_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hash_join_node.read(iprot);
          this->__isset.hash_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nested_loop_join_node.read(iprot);
          this->__isset.nested_loop_join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_join_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TJoinNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJoinNode");

  xfer += oprot->writeFieldBegin("join_op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->join_op);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.build_tuples) {
    xfer += oprot->writeFieldBegin("build_tuples", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->build_tuples.size()));
      std::vector< ::impala::TTupleId> ::const_iterator _iter179;
      for (_iter179 = this->build_tuples.begin(); _iter179 != this->build_tuples.end(); ++_iter179)
      {
        xfer += oprot->writeI32((*_iter179));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nullable_build_tuples) {
    xfer += oprot->writeFieldBegin("nullable_build_tuples", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nullable_build_tuples.size()));
      std::vector<bool> ::const_iterator _iter180;
      for (_iter180 = this->nullable_build_tuples.begin(); _iter180 != this->nullable_build_tuples.end(); ++_iter180)
      {
        xfer += oprot->writeBool((*_iter180));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hash_join_node) {
    xfer += oprot->writeFieldBegin("hash_join_node", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->hash_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nested_loop_join_node) {
    xfer += oprot->writeFieldBegin("nested_loop_join_node", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->nested_loop_join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAggregator::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aggregate_functions = false;
  bool isset_intermediate_tuple_id = false;
  bool isset_output_tuple_id = false;
  bool isset_need_finalize = false;
  bool isset_use_streaming_preaggregation = false;
  bool isset_resource_profile = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grouping_exprs.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->grouping_exprs.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += this->grouping_exprs[_i189].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.grouping_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregate_functions.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->aggregate_functions.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += this->aggregate_functions[_i194].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregate_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intermediate_tuple_id);
          isset_intermediate_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->need_finalize);
          isset_need_finalize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->use_streaming_preaggregation);
          isset_use_streaming_preaggregation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_profile.read(iprot);
          isset_resource_profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aggregate_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_intermediate_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_need_finalize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_use_streaming_preaggregation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resource_profile)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAggregator::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAggregator");

  if (this->__isset.grouping_exprs) {
    xfer += oprot->writeFieldBegin("grouping_exprs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->grouping_exprs.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter195;
      for (_iter195 = this->grouping_exprs.begin(); _iter195 != this->grouping_exprs.end(); ++_iter195)
      {
        xfer += (*_iter195).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("aggregate_functions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregate_functions.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter196;
    for (_iter196 = this->aggregate_functions.begin(); _iter196 != this->aggregate_functions.end(); ++_iter196)
    {
      xfer += (*_iter196).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intermediate_tuple_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->intermediate_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("need_finalize", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->need_finalize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("use_streaming_preaggregation", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->use_streaming_preaggregation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource_profile", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->resource_profile.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAggregationNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_aggregators = false;
  bool isset_estimated_input_cardinality = false;
  bool isset_replicate_input = false;
  bool isset_fast_limit_check = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aggregators.clear();
            uint32_t _size201;
            ::apache::thrift::protocol::TType _etype204;
            xfer += iprot->readListBegin(_etype204, _size201);
            this->aggregators.resize(_size201);
            uint32_t _i205;
            for (_i205 = 0; _i205 < _size201; ++_i205)
            {
              xfer += this->aggregators[_i205].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_aggregators = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->estimated_input_cardinality);
          isset_estimated_input_cardinality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->replicate_input);
          isset_replicate_input = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->fast_limit_check);
          isset_fast_limit_check = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_aggregators)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_estimated_input_cardinality)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_replicate_input)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fast_limit_check)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAggregationNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAggregationNode");

  xfer += oprot->writeFieldBegin("aggregators", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->aggregators.size()));
    std::vector<TAggregator> ::const_iterator _iter206;
    for (_iter206 = this->aggregators.begin(); _iter206 != this->aggregators.end(); ++_iter206)
    {
      xfer += (*_iter206).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("estimated_input_cardinality", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->estimated_input_cardinality);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replicate_input", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->replicate_input);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fast_limit_check", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->fast_limit_check);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TSortInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ordering_exprs = false;
  bool isset_is_asc_order = false;
  bool isset_nulls_first = false;
  bool isset_sorting_order = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ordering_exprs.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->ordering_exprs.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              xfer += this->ordering_exprs[_i215].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_ordering_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->is_asc_order.clear();
            uint32_t _size216;
            ::apache::thrift::protocol::TType _etype219;
            xfer += iprot->readListBegin(_etype219, _size216);
            this->is_asc_order.resize(_size216);
            uint32_t _i220;
            for (_i220 = 0; _i220 < _size216; ++_i220)
            {
              xfer += iprot->readBool(this->is_asc_order[_i220]);
            }
            xfer += iprot->readListEnd();
          }
          isset_is_asc_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nulls_first.clear();
            uint32_t _size221;
            ::apache::thrift::protocol::TType _etype224;
            xfer += iprot->readListBegin(_etype224, _size221);
            this->nulls_first.resize(_size221);
            uint32_t _i225;
            for (_i225 = 0; _i225 < _size221; ++_i225)
            {
              xfer += iprot->readBool(this->nulls_first[_i225]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nulls_first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_tuple_slot_exprs.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _etype229;
            xfer += iprot->readListBegin(_etype229, _size226);
            this->sort_tuple_slot_exprs.resize(_size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              xfer += this->sort_tuple_slot_exprs[_i230].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_tuple_slot_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast231;
          xfer += iprot->readI32(ecast231);
          this->sorting_order = ( ::impala::TSortingOrder::type)ecast231;
          isset_sorting_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_lexical_keys_in_zorder);
          this->__isset.num_lexical_keys_in_zorder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ordering_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_asc_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nulls_first)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sorting_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TSortInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSortInfo");

  xfer += oprot->writeFieldBegin("ordering_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ordering_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter232;
    for (_iter232 = this->ordering_exprs.begin(); _iter232 != this->ordering_exprs.end(); ++_iter232)
    {
      xfer += (*_iter232).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_asc_order", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->is_asc_order.size()));
    std::vector<bool> ::const_iterator _iter233;
    for (_iter233 = this->is_asc_order.begin(); _iter233 != this->is_asc_order.end(); ++_iter233)
    {
      xfer += oprot->writeBool((*_iter233));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nulls_first", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nulls_first.size()));
    std::vector<bool> ::const_iterator _iter234;
    for (_iter234 = this->nulls_first.begin(); _iter234 != this->nulls_first.end(); ++_iter234)
    {
      xfer += oprot->writeBool((*_iter234));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_tuple_slot_exprs) {
    xfer += oprot->writeFieldBegin("sort_tuple_slot_exprs", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->sort_tuple_slot_exprs.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter235;
      for (_iter235 = this->sort_tuple_slot_exprs.begin(); _iter235 != this->sort_tuple_slot_exprs.end(); ++_iter235)
      {
        xfer += (*_iter235).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sorting_order", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->sorting_order);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.num_lexical_keys_in_zorder) {
    xfer += oprot->writeFieldBegin("num_lexical_keys_in_zorder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->num_lexical_keys_in_zorder);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TSortNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sort_info = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_info.read(iprot);
          isset_sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast240;
          xfer += iprot->readI32(ecast240);
          this->type = (TSortType::type)ecast240;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->estimated_full_input_size);
          this->__isset.estimated_full_input_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->include_ties);
          this->__isset.include_ties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit_with_ties);
          this->__isset.limit_with_ties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->per_partition_limit);
          this->__isset.per_partition_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->partition_exprs.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->partition_exprs[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->intra_partition_sort_info.read(iprot);
          this->__isset.intra_partition_sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sort_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TSortNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSortNode");

  xfer += oprot->writeFieldBegin("sort_info", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->sort_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.estimated_full_input_size) {
    xfer += oprot->writeFieldBegin("estimated_full_input_size", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->estimated_full_input_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.include_ties) {
    xfer += oprot->writeFieldBegin("include_ties", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->include_ties);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit_with_ties) {
    xfer += oprot->writeFieldBegin("limit_with_ties", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->limit_with_ties);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.per_partition_limit) {
    xfer += oprot->writeFieldBegin("per_partition_limit", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->per_partition_limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_exprs) {
    xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter246;
      for (_iter246 = this->partition_exprs.begin(); _iter246 != this->partition_exprs.end(); ++_iter246)
      {
        xfer += (*_iter246).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.intra_partition_sort_info) {
    xfer += oprot->writeFieldBegin("intra_partition_sort_info", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->intra_partition_sort_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAnalyticWindowBoundary::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast251;
          xfer += iprot->readI32(ecast251);
          this->type = (TAnalyticWindowBoundaryType::type)ecast251;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range_offset_predicate.read(iprot);
          this->__isset.range_offset_predicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rows_offset_value);
          this->__isset.rows_offset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAnalyticWindowBoundary::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAnalyticWindowBoundary");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_offset_predicate) {
    xfer += oprot->writeFieldBegin("range_offset_predicate", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->range_offset_predicate.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rows_offset_value) {
    xfer += oprot->writeFieldBegin("rows_offset_value", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->rows_offset_value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAnalyticWindow::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast256;
          xfer += iprot->readI32(ecast256);
          this->type = (TAnalyticWindowType::type)ecast256;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window_start.read(iprot);
          this->__isset.window_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window_end.read(iprot);
          this->__isset.window_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAnalyticWindow::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAnalyticWindow");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.window_start) {
    xfer += oprot->writeFieldBegin("window_start", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->window_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.window_end) {
    xfer += oprot->writeFieldBegin("window_end", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->window_end.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAnalyticNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_exprs = false;
  bool isset_order_by_exprs = false;
  bool isset_analytic_functions = false;
  bool isset_intermediate_tuple_id = false;
  bool isset_output_tuple_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_exprs.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _etype264;
            xfer += iprot->readListBegin(_etype264, _size261);
            this->partition_exprs.resize(_size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              xfer += this->partition_exprs[_i265].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_exprs.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _etype269;
            xfer += iprot->readListBegin(_etype269, _size266);
            this->order_by_exprs.resize(_size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              xfer += this->order_by_exprs[_i270].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_order_by_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->analytic_functions.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->analytic_functions.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += this->analytic_functions[_i275].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_analytic_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->window.read(iprot);
          this->__isset.window = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->intermediate_tuple_id);
          isset_intermediate_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->output_tuple_id);
          isset_output_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffered_tuple_id);
          this->__isset.buffered_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_by_eq.read(iprot);
          this->__isset.partition_by_eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->order_by_eq.read(iprot);
          this->__isset.order_by_eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_order_by_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_analytic_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_intermediate_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAnalyticNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAnalyticNode");

  xfer += oprot->writeFieldBegin("partition_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter276;
    for (_iter276 = this->partition_exprs.begin(); _iter276 != this->partition_exprs.end(); ++_iter276)
    {
      xfer += (*_iter276).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("order_by_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter277;
    for (_iter277 = this->order_by_exprs.begin(); _iter277 != this->order_by_exprs.end(); ++_iter277)
    {
      xfer += (*_iter277).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("analytic_functions", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->analytic_functions.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter278;
    for (_iter278 = this->analytic_functions.begin(); _iter278 != this->analytic_functions.end(); ++_iter278)
    {
      xfer += (*_iter278).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.window) {
    xfer += oprot->writeFieldBegin("window", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->window.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("intermediate_tuple_id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->intermediate_tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_tuple_id", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->output_tuple_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.buffered_tuple_id) {
    xfer += oprot->writeFieldBegin("buffered_tuple_id", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->buffered_tuple_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_by_eq) {
    xfer += oprot->writeFieldBegin("partition_by_eq", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->partition_by_eq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_eq) {
    xfer += oprot->writeFieldBegin("order_by_eq", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->order_by_eq.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUnionNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tuple_id = false;
  bool isset_result_expr_lists = false;
  bool isset_const_expr_lists = false;
  bool isset_first_materialized_child_idx = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tuple_id);
          isset_tuple_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result_expr_lists.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _etype286;
            xfer += iprot->readListBegin(_etype286, _size283);
            this->result_expr_lists.resize(_size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287)
            {
              {
                this->result_expr_lists[_i287].clear();
                uint32_t _size288;
                ::apache::thrift::protocol::TType _etype291;
                xfer += iprot->readListBegin(_etype291, _size288);
                this->result_expr_lists[_i287].resize(_size288);
                uint32_t _i292;
                for (_i292 = 0; _i292 < _size288; ++_i292)
                {
                  xfer += this->result_expr_lists[_i287][_i292].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_result_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->const_expr_lists.clear();
            uint32_t _size293;
            ::apache::thrift::protocol::TType _etype296;
            xfer += iprot->readListBegin(_etype296, _size293);
            this->const_expr_lists.resize(_size293);
            uint32_t _i297;
            for (_i297 = 0; _i297 < _size293; ++_i297)
            {
              {
                this->const_expr_lists[_i297].clear();
                uint32_t _size298;
                ::apache::thrift::protocol::TType _etype301;
                xfer += iprot->readListBegin(_etype301, _size298);
                this->const_expr_lists[_i297].resize(_size298);
                uint32_t _i302;
                for (_i302 = 0; _i302 < _size298; ++_i302)
                {
                  xfer += this->const_expr_lists[_i297][_i302].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_const_expr_lists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first_materialized_child_idx);
          isset_first_materialized_child_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tuple_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_result_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_const_expr_lists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_first_materialized_child_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUnionNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUnionNode");

  xfer += oprot->writeFieldBegin("tuple_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->tuple_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result_expr_lists", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->result_expr_lists.size()));
    std::vector<std::vector< ::impala::TExpr> > ::const_iterator _iter303;
    for (_iter303 = this->result_expr_lists.begin(); _iter303 != this->result_expr_lists.end(); ++_iter303)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter303).size()));
        std::vector< ::impala::TExpr> ::const_iterator _iter304;
        for (_iter304 = (*_iter303).begin(); _iter304 != (*_iter303).end(); ++_iter304)
        {
          xfer += (*_iter304).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("const_expr_lists", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->const_expr_lists.size()));
    std::vector<std::vector< ::impala::TExpr> > ::const_iterator _iter305;
    for (_iter305 = this->const_expr_lists.begin(); _iter305 != this->const_expr_lists.end(); ++_iter305)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter305).size()));
        std::vector< ::impala::TExpr> ::const_iterator _iter306;
        for (_iter306 = (*_iter305).begin(); _iter306 != (*_iter305).end(); ++_iter306)
        {
          xfer += (*_iter306).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first_materialized_child_idx", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->first_materialized_child_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExchangeNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_input_row_tuples = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_row_tuples.clear();
            uint32_t _size311;
            ::apache::thrift::protocol::TType _etype314;
            xfer += iprot->readListBegin(_etype314, _size311);
            this->input_row_tuples.resize(_size311);
            uint32_t _i315;
            for (_i315 = 0; _i315 < _size311; ++_i315)
            {
              xfer += iprot->readI32(this->input_row_tuples[_i315]);
            }
            xfer += iprot->readListEnd();
          }
          isset_input_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_info.read(iprot);
          this->__isset.sort_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_input_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TExchangeNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExchangeNode");

  xfer += oprot->writeFieldBegin("input_row_tuples", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->input_row_tuples.size()));
    std::vector< ::impala::TTupleId> ::const_iterator _iter316;
    for (_iter316 = this->input_row_tuples.begin(); _iter316 != this->input_row_tuples.end(); ++_iter316)
    {
      xfer += oprot->writeI32((*_iter316));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_info) {
    xfer += oprot->writeFieldBegin("sort_info", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->sort_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUnnestNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_collection_exprs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->collection_exprs.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->collection_exprs.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += this->collection_exprs[_i325].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_collection_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_collection_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUnnestNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUnnestNode");

  xfer += oprot->writeFieldBegin("collection_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->collection_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter326;
    for (_iter326 = this->collection_exprs.begin(); _iter326 != this->collection_exprs.end(); ++_iter326)
    {
      xfer += (*_iter326).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCardinalityCheckNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_display_statement = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->display_statement);
          isset_display_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_display_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCardinalityCheckNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCardinalityCheckNode");

  xfer += oprot->writeFieldBegin("display_statement", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->display_statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPipelineMembership::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pipe_id = false;
  bool isset_height = false;
  bool isset_phase = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pipe_id);
          isset_pipe_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          isset_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast335;
          xfer += iprot->readI32(ecast335);
          this->phase = (TExecNodePhase::type)ecast335;
          isset_phase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pipe_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_phase)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPipelineMembership::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPipelineMembership");

  xfer += oprot->writeFieldBegin("pipe_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->pipe_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("phase", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->phase);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPlanNode::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_node_type = false;
  bool isset_num_children = false;
  bool isset_limit = false;
  bool isset_row_tuples = false;
  bool isset_nullable_tuples = false;
  bool isset_disable_codegen = false;
  bool isset_pipelines = false;
  bool isset_resource_profile = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast340;
          xfer += iprot->readI32(ecast340);
          this->node_type = (TPlanNodeType::type)ecast340;
          isset_node_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          isset_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->row_tuples.clear();
            uint32_t _size341;
            ::apache::thrift::protocol::TType _etype344;
            xfer += iprot->readListBegin(_etype344, _size341);
            this->row_tuples.resize(_size341);
            uint32_t _i345;
            for (_i345 = 0; _i345 < _size341; ++_i345)
            {
              xfer += iprot->readI32(this->row_tuples[_i345]);
            }
            xfer += iprot->readListEnd();
          }
          isset_row_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nullable_tuples.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->nullable_tuples.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += iprot->readBool(this->nullable_tuples[_i350]);
            }
            xfer += iprot->readListEnd();
          }
          isset_nullable_tuples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->conjuncts.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->conjuncts.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += this->conjuncts[_i355].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->disable_codegen);
          isset_disable_codegen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pipelines.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->pipelines.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += this->pipelines[_i360].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pipelines = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_scan_node.read(iprot);
          this->__isset.hdfs_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbase_scan_node.read(iprot);
          this->__isset.hbase_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kudu_scan_node.read(iprot);
          this->__isset.kudu_scan_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source_node.read(iprot);
          this->__isset.data_source_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->join_node.read(iprot);
          this->__isset.join_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agg_node.read(iprot);
          this->__isset.agg_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sort_node.read(iprot);
          this->__isset.sort_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->union_node.read(iprot);
          this->__isset.union_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->exchange_node.read(iprot);
          this->__isset.exchange_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->analytic_node.read(iprot);
          this->__isset.analytic_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unnest_node.read(iprot);
          this->__isset.unnest_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          this->__isset.label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label_detail);
          this->__isset.label_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->estimated_stats.read(iprot);
          this->__isset.estimated_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runtime_filters.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _etype364;
            xfer += iprot->readListBegin(_etype364, _size361);
            this->runtime_filters.resize(_size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              xfer += this->runtime_filters[_i365].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runtime_filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_profile.read(iprot);
          isset_resource_profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cardinality_check_node.read(iprot);
          this->__isset.cardinality_check_node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_node_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_row_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullable_tuples)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_disable_codegen)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pipelines)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_resource_profile)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPlanNode::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanNode");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->node_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_tuples", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->row_tuples.size()));
    std::vector< ::impala::TTupleId> ::const_iterator _iter366;
    for (_iter366 = this->row_tuples.begin(); _iter366 != this->row_tuples.end(); ++_iter366)
    {
      xfer += oprot->writeI32((*_iter366));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullable_tuples", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->nullable_tuples.size()));
    std::vector<bool> ::const_iterator _iter367;
    for (_iter367 = this->nullable_tuples.begin(); _iter367 != this->nullable_tuples.end(); ++_iter367)
    {
      xfer += oprot->writeBool((*_iter367));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.conjuncts) {
    xfer += oprot->writeFieldBegin("conjuncts", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->conjuncts.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter368;
      for (_iter368 = this->conjuncts.begin(); _iter368 != this->conjuncts.end(); ++_iter368)
      {
        xfer += (*_iter368).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("disable_codegen", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->disable_codegen);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hdfs_scan_node) {
    xfer += oprot->writeFieldBegin("hdfs_scan_node", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->hdfs_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbase_scan_node) {
    xfer += oprot->writeFieldBegin("hbase_scan_node", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->hbase_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_scan_node) {
    xfer += oprot->writeFieldBegin("kudu_scan_node", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->kudu_scan_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_source_node) {
    xfer += oprot->writeFieldBegin("data_source_node", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->data_source_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.join_node) {
    xfer += oprot->writeFieldBegin("join_node", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->join_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agg_node) {
    xfer += oprot->writeFieldBegin("agg_node", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->agg_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_node) {
    xfer += oprot->writeFieldBegin("sort_node", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->sort_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.union_node) {
    xfer += oprot->writeFieldBegin("union_node", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->union_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exchange_node) {
    xfer += oprot->writeFieldBegin("exchange_node", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->exchange_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.analytic_node) {
    xfer += oprot->writeFieldBegin("analytic_node", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->analytic_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unnest_node) {
    xfer += oprot->writeFieldBegin("unnest_node", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->unnest_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.label) {
    xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 21);
    xfer += oprot->writeString(this->label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.label_detail) {
    xfer += oprot->writeFieldBegin("label_detail", ::apache::thrift::protocol::T_STRING, 22);
    xfer += oprot->writeString(this->label_detail);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.estimated_stats) {
    xfer += oprot->writeFieldBegin("estimated_stats", ::apache::thrift::protocol::T_STRUCT, 23);
    xfer += this->estimated_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runtime_filters) {
    xfer += oprot->writeFieldBegin("runtime_filters", ::apache::thrift::protocol::T_LIST, 24);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->runtime_filters.size()));
      std::vector<TRuntimeFilterDesc> ::const_iterator _iter369;
      for (_iter369 = this->runtime_filters.begin(); _iter369 != this->runtime_filters.end(); ++_iter369)
      {
        xfer += (*_iter369).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("resource_profile", ::apache::thrift::protocol::T_STRUCT, 25);
  xfer += this->resource_profile.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cardinality_check_node) {
    xfer += oprot->writeFieldBegin("cardinality_check_node", ::apache::thrift::protocol::T_STRUCT, 26);
    xfer += this->cardinality_check_node.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("pipelines", ::apache::thrift::protocol::T_LIST, 27);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pipelines.size()));
    std::vector<TPipelineMembership> ::const_iterator _iter370;
    for (_iter370 = this->pipelines.begin(); _iter370 != this->pipelines.end(); ++_iter370)
    {
      xfer += (*_iter370).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPlan::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_nodes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _etype378;
            xfer += iprot->readListBegin(_etype378, _size375);
            this->nodes.resize(_size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              xfer += this->nodes[_i379].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_nodes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPlan::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlan");

  xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
    std::vector<TPlanNode> ::const_iterator _iter380;
    for (_iter380 = this->nodes.begin(); _iter380 != this->nodes.end(); ++_iter380)
    {
      xfer += (*_iter380).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
