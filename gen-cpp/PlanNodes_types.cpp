/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "PlanNodes_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTPlanNodeTypeValues[] = {
  TPlanNodeType::HDFS_SCAN_NODE,
  TPlanNodeType::HBASE_SCAN_NODE,
  TPlanNodeType::HASH_JOIN_NODE,
  TPlanNodeType::AGGREGATION_NODE,
  TPlanNodeType::SORT_NODE,
  TPlanNodeType::EMPTY_SET_NODE,
  TPlanNodeType::EXCHANGE_NODE,
  TPlanNodeType::UNION_NODE,
  TPlanNodeType::SELECT_NODE,
  TPlanNodeType::NESTED_LOOP_JOIN_NODE,
  TPlanNodeType::DATA_SOURCE_NODE,
  TPlanNodeType::ANALYTIC_EVAL_NODE,
  TPlanNodeType::SINGULAR_ROW_SRC_NODE,
  TPlanNodeType::UNNEST_NODE,
  TPlanNodeType::SUBPLAN_NODE,
  TPlanNodeType::KUDU_SCAN_NODE,
  TPlanNodeType::CARDINALITY_CHECK_NODE,
  TPlanNodeType::MULTI_AGGREGATION_NODE
};
const char* _kTPlanNodeTypeNames[] = {
  "HDFS_SCAN_NODE",
  "HBASE_SCAN_NODE",
  "HASH_JOIN_NODE",
  "AGGREGATION_NODE",
  "SORT_NODE",
  "EMPTY_SET_NODE",
  "EXCHANGE_NODE",
  "UNION_NODE",
  "SELECT_NODE",
  "NESTED_LOOP_JOIN_NODE",
  "DATA_SOURCE_NODE",
  "ANALYTIC_EVAL_NODE",
  "SINGULAR_ROW_SRC_NODE",
  "UNNEST_NODE",
  "SUBPLAN_NODE",
  "KUDU_SCAN_NODE",
  "CARDINALITY_CHECK_NODE",
  "MULTI_AGGREGATION_NODE"
};
const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kTPlanNodeTypeValues, _kTPlanNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPlanNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TPlanNodeType_VALUES_TO_NAMES.find(val);
  if (it != _TPlanNodeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExecNodePhaseValues[] = {
  TExecNodePhase::PREPARE,
  TExecNodePhase::PREPARE_SCANNER,
  TExecNodePhase::OPEN,
  TExecNodePhase::GETNEXT,
  TExecNodePhase::GETNEXT_SCANNER,
  TExecNodePhase::CLOSE,
  TExecNodePhase::SCANNER_ERROR,
  TExecNodePhase::INVALID
};
const char* _kTExecNodePhaseNames[] = {
  "PREPARE",
  "PREPARE_SCANNER",
  "OPEN",
  "GETNEXT",
  "GETNEXT_SCANNER",
  "CLOSE",
  "SCANNER_ERROR",
  "INVALID"
};
const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTExecNodePhaseValues, _kTExecNodePhaseNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExecNodePhase::type& val) {
  std::map<int, const char*>::const_iterator it = _TExecNodePhase_VALUES_TO_NAMES.find(val);
  if (it != _TExecNodePhase_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTDebugActionValues[] = {
  TDebugAction::WAIT,
  TDebugAction::FAIL,
  TDebugAction::INJECT_ERROR_LOG,
  TDebugAction::MEM_LIMIT_EXCEEDED,
  TDebugAction::SET_DENY_RESERVATION_PROBABILITY,
  TDebugAction::DELAY
};
const char* _kTDebugActionNames[] = {
  "WAIT",
  "FAIL",
  "INJECT_ERROR_LOG",
  "MEM_LIMIT_EXCEEDED",
  "SET_DENY_RESERVATION_PROBABILITY",
  "DELAY"
};
const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTDebugActionValues, _kTDebugActionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TDebugAction::type& val) {
  std::map<int, const char*>::const_iterator it = _TDebugAction_VALUES_TO_NAMES.find(val);
  if (it != _TDebugAction_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTReplicaPreferenceValues[] = {
  TReplicaPreference::CACHE_LOCAL,
  TReplicaPreference::CACHE_RACK,
  TReplicaPreference::DISK_LOCAL,
  TReplicaPreference::DISK_RACK,
  TReplicaPreference::REMOTE
};
const char* _kTReplicaPreferenceNames[] = {
  "CACHE_LOCAL",
  "CACHE_RACK",
  "DISK_LOCAL",
  "DISK_RACK",
  "REMOTE"
};
const std::map<int, const char*> _TReplicaPreference_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTReplicaPreferenceValues, _kTReplicaPreferenceNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TReplicaPreference::type& val) {
  std::map<int, const char*>::const_iterator it = _TReplicaPreference_VALUES_TO_NAMES.find(val);
  if (it != _TReplicaPreference_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTRuntimeFilterTypeValues[] = {
  TRuntimeFilterType::BLOOM,
  TRuntimeFilterType::MIN_MAX
};
const char* _kTRuntimeFilterTypeNames[] = {
  "BLOOM",
  "MIN_MAX"
};
const std::map<int, const char*> _TRuntimeFilterType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTRuntimeFilterTypeValues, _kTRuntimeFilterTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterType::type& val) {
  std::map<int, const char*>::const_iterator it = _TRuntimeFilterType_VALUES_TO_NAMES.find(val);
  if (it != _TRuntimeFilterType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTEnabledRuntimeFilterTypesValues[] = {
  TEnabledRuntimeFilterTypes::BLOOM,
  TEnabledRuntimeFilterTypes::MIN_MAX,
  TEnabledRuntimeFilterTypes::ALL
};
const char* _kTEnabledRuntimeFilterTypesNames[] = {
  "BLOOM",
  "MIN_MAX",
  "ALL"
};
const std::map<int, const char*> _TEnabledRuntimeFilterTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTEnabledRuntimeFilterTypesValues, _kTEnabledRuntimeFilterTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TEnabledRuntimeFilterTypes::type& val) {
  std::map<int, const char*>::const_iterator it = _TEnabledRuntimeFilterTypes_VALUES_TO_NAMES.find(val);
  if (it != _TEnabledRuntimeFilterTypes_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTMinmaxFilteringLevelValues[] = {
  TMinmaxFilteringLevel::ROW_GROUP,
  TMinmaxFilteringLevel::PAGE,
  TMinmaxFilteringLevel::ROW
};
const char* _kTMinmaxFilteringLevelNames[] = {
  "ROW_GROUP",
  "PAGE",
  "ROW"
};
const std::map<int, const char*> _TMinmaxFilteringLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTMinmaxFilteringLevelValues, _kTMinmaxFilteringLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TMinmaxFilteringLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _TMinmaxFilteringLevel_VALUES_TO_NAMES.find(val);
  if (it != _TMinmaxFilteringLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTJoinOpValues[] = {
  TJoinOp::INNER_JOIN,
  TJoinOp::LEFT_OUTER_JOIN,
  TJoinOp::LEFT_SEMI_JOIN,
  TJoinOp::LEFT_ANTI_JOIN,
  TJoinOp::NULL_AWARE_LEFT_ANTI_JOIN,
  TJoinOp::RIGHT_OUTER_JOIN,
  TJoinOp::RIGHT_SEMI_JOIN,
  TJoinOp::RIGHT_ANTI_JOIN,
  TJoinOp::FULL_OUTER_JOIN,
  TJoinOp::CROSS_JOIN
};
const char* _kTJoinOpNames[] = {
  "INNER_JOIN",
  "LEFT_OUTER_JOIN",
  "LEFT_SEMI_JOIN",
  "LEFT_ANTI_JOIN",
  "NULL_AWARE_LEFT_ANTI_JOIN",
  "RIGHT_OUTER_JOIN",
  "RIGHT_SEMI_JOIN",
  "RIGHT_ANTI_JOIN",
  "FULL_OUTER_JOIN",
  "CROSS_JOIN"
};
const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTJoinOpValues, _kTJoinOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TJoinOp::type& val) {
  std::map<int, const char*>::const_iterator it = _TJoinOp_VALUES_TO_NAMES.find(val);
  if (it != _TJoinOp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTSortTypeValues[] = {
  TSortType::TOTAL,
  TSortType::TOPN,
  TSortType::PARTIAL,
  TSortType::PARTITIONED_TOPN
};
const char* _kTSortTypeNames[] = {
  "TOTAL",
  "TOPN",
  "PARTIAL",
  "PARTITIONED_TOPN"
};
const std::map<int, const char*> _TSortType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTSortTypeValues, _kTSortTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TSortType::type& val) {
  std::map<int, const char*>::const_iterator it = _TSortType_VALUES_TO_NAMES.find(val);
  if (it != _TSortType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTAnalyticWindowTypeValues[] = {
  TAnalyticWindowType::RANGE,
  TAnalyticWindowType::ROWS
};
const char* _kTAnalyticWindowTypeNames[] = {
  "RANGE",
  "ROWS"
};
const std::map<int, const char*> _TAnalyticWindowType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTAnalyticWindowTypeValues, _kTAnalyticWindowTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TAnalyticWindowType::type& val) {
  std::map<int, const char*>::const_iterator it = _TAnalyticWindowType_VALUES_TO_NAMES.find(val);
  if (it != _TAnalyticWindowType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTAnalyticWindowBoundaryTypeValues[] = {
  TAnalyticWindowBoundaryType::CURRENT_ROW,
  TAnalyticWindowBoundaryType::PRECEDING,
  TAnalyticWindowBoundaryType::FOLLOWING
};
const char* _kTAnalyticWindowBoundaryTypeNames[] = {
  "CURRENT_ROW",
  "PRECEDING",
  "FOLLOWING"
};
const std::map<int, const char*> _TAnalyticWindowBoundaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTAnalyticWindowBoundaryTypeValues, _kTAnalyticWindowBoundaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TAnalyticWindowBoundaryType::type& val) {
  std::map<int, const char*>::const_iterator it = _TAnalyticWindowBoundaryType_VALUES_TO_NAMES.find(val);
  if (it != _TAnalyticWindowBoundaryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TRuntimeFilterTargetDesc::~TRuntimeFilterTargetDesc() throw() {
}


void TRuntimeFilterTargetDesc::__set_node_id(const  ::impala::TPlanNodeId val) {
  this->node_id = val;
}

void TRuntimeFilterTargetDesc::__set_target_expr(const  ::impala::TExpr& val) {
  this->target_expr = val;
}

void TRuntimeFilterTargetDesc::__set_is_bound_by_partition_columns(const bool val) {
  this->is_bound_by_partition_columns = val;
}

void TRuntimeFilterTargetDesc::__set_target_expr_slotids(const std::vector< ::impala::TSlotId> & val) {
  this->target_expr_slotids = val;
}

void TRuntimeFilterTargetDesc::__set_is_local_target(const bool val) {
  this->is_local_target = val;
}

void TRuntimeFilterTargetDesc::__set_kudu_col_name(const std::string& val) {
  this->kudu_col_name = val;
__isset.kudu_col_name = true;
}

void TRuntimeFilterTargetDesc::__set_kudu_col_type(const  ::impala::TColumnType& val) {
  this->kudu_col_type = val;
__isset.kudu_col_type = true;
}

void TRuntimeFilterTargetDesc::__set_low_value(const  ::impala::TColumnValue& val) {
  this->low_value = val;
__isset.low_value = true;
}

void TRuntimeFilterTargetDesc::__set_high_value(const  ::impala::TColumnValue& val) {
  this->high_value = val;
__isset.high_value = true;
}

void TRuntimeFilterTargetDesc::__set_is_min_max_value_present(const bool val) {
  this->is_min_max_value_present = val;
__isset.is_min_max_value_present = true;
}

void TRuntimeFilterTargetDesc::__set_is_column_in_data_file(const bool val) {
  this->is_column_in_data_file = val;
__isset.is_column_in_data_file = true;
}
std::ostream& operator<<(std::ostream& out, const TRuntimeFilterTargetDesc& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TRuntimeFilterTargetDesc &a, TRuntimeFilterTargetDesc &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.target_expr, b.target_expr);
  swap(a.is_bound_by_partition_columns, b.is_bound_by_partition_columns);
  swap(a.target_expr_slotids, b.target_expr_slotids);
  swap(a.is_local_target, b.is_local_target);
  swap(a.kudu_col_name, b.kudu_col_name);
  swap(a.kudu_col_type, b.kudu_col_type);
  swap(a.low_value, b.low_value);
  swap(a.high_value, b.high_value);
  swap(a.is_min_max_value_present, b.is_min_max_value_present);
  swap(a.is_column_in_data_file, b.is_column_in_data_file);
  swap(a.__isset, b.__isset);
}

TRuntimeFilterTargetDesc::TRuntimeFilterTargetDesc(const TRuntimeFilterTargetDesc& other6) {
  node_id = other6.node_id;
  target_expr = other6.target_expr;
  is_bound_by_partition_columns = other6.is_bound_by_partition_columns;
  target_expr_slotids = other6.target_expr_slotids;
  is_local_target = other6.is_local_target;
  kudu_col_name = other6.kudu_col_name;
  kudu_col_type = other6.kudu_col_type;
  low_value = other6.low_value;
  high_value = other6.high_value;
  is_min_max_value_present = other6.is_min_max_value_present;
  is_column_in_data_file = other6.is_column_in_data_file;
  __isset = other6.__isset;
}
TRuntimeFilterTargetDesc::TRuntimeFilterTargetDesc( TRuntimeFilterTargetDesc&& other7) {
  node_id = std::move(other7.node_id);
  target_expr = std::move(other7.target_expr);
  is_bound_by_partition_columns = std::move(other7.is_bound_by_partition_columns);
  target_expr_slotids = std::move(other7.target_expr_slotids);
  is_local_target = std::move(other7.is_local_target);
  kudu_col_name = std::move(other7.kudu_col_name);
  kudu_col_type = std::move(other7.kudu_col_type);
  low_value = std::move(other7.low_value);
  high_value = std::move(other7.high_value);
  is_min_max_value_present = std::move(other7.is_min_max_value_present);
  is_column_in_data_file = std::move(other7.is_column_in_data_file);
  __isset = std::move(other7.__isset);
}
TRuntimeFilterTargetDesc& TRuntimeFilterTargetDesc::operator=(const TRuntimeFilterTargetDesc& other8) {
  node_id = other8.node_id;
  target_expr = other8.target_expr;
  is_bound_by_partition_columns = other8.is_bound_by_partition_columns;
  target_expr_slotids = other8.target_expr_slotids;
  is_local_target = other8.is_local_target;
  kudu_col_name = other8.kudu_col_name;
  kudu_col_type = other8.kudu_col_type;
  low_value = other8.low_value;
  high_value = other8.high_value;
  is_min_max_value_present = other8.is_min_max_value_present;
  is_column_in_data_file = other8.is_column_in_data_file;
  __isset = other8.__isset;
  return *this;
}
TRuntimeFilterTargetDesc& TRuntimeFilterTargetDesc::operator=(TRuntimeFilterTargetDesc&& other9) {
  node_id = std::move(other9.node_id);
  target_expr = std::move(other9.target_expr);
  is_bound_by_partition_columns = std::move(other9.is_bound_by_partition_columns);
  target_expr_slotids = std::move(other9.target_expr_slotids);
  is_local_target = std::move(other9.is_local_target);
  kudu_col_name = std::move(other9.kudu_col_name);
  kudu_col_type = std::move(other9.kudu_col_type);
  low_value = std::move(other9.low_value);
  high_value = std::move(other9.high_value);
  is_min_max_value_present = std::move(other9.is_min_max_value_present);
  is_column_in_data_file = std::move(other9.is_column_in_data_file);
  __isset = std::move(other9.__isset);
  return *this;
}
void TRuntimeFilterTargetDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRuntimeFilterTargetDesc(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "target_expr=" << to_string(target_expr);
  out << ", " << "is_bound_by_partition_columns=" << to_string(is_bound_by_partition_columns);
  out << ", " << "target_expr_slotids=" << to_string(target_expr_slotids);
  out << ", " << "is_local_target=" << to_string(is_local_target);
  out << ", " << "kudu_col_name="; (__isset.kudu_col_name ? (out << to_string(kudu_col_name)) : (out << "<null>"));
  out << ", " << "kudu_col_type="; (__isset.kudu_col_type ? (out << to_string(kudu_col_type)) : (out << "<null>"));
  out << ", " << "low_value="; (__isset.low_value ? (out << to_string(low_value)) : (out << "<null>"));
  out << ", " << "high_value="; (__isset.high_value ? (out << to_string(high_value)) : (out << "<null>"));
  out << ", " << "is_min_max_value_present="; (__isset.is_min_max_value_present ? (out << to_string(is_min_max_value_present)) : (out << "<null>"));
  out << ", " << "is_column_in_data_file="; (__isset.is_column_in_data_file ? (out << to_string(is_column_in_data_file)) : (out << "<null>"));
  out << ")";
}


TRuntimeFilterDesc::~TRuntimeFilterDesc() throw() {
}


void TRuntimeFilterDesc::__set_filter_id(const int32_t val) {
  this->filter_id = val;
}

void TRuntimeFilterDesc::__set_src_expr(const  ::impala::TExpr& val) {
  this->src_expr = val;
}

void TRuntimeFilterDesc::__set_targets(const std::vector<TRuntimeFilterTargetDesc> & val) {
  this->targets = val;
}

void TRuntimeFilterDesc::__set_planid_to_target_ndx(const std::map< ::impala::TPlanNodeId, int32_t> & val) {
  this->planid_to_target_ndx = val;
}

void TRuntimeFilterDesc::__set_is_broadcast_join(const bool val) {
  this->is_broadcast_join = val;
}

void TRuntimeFilterDesc::__set_has_local_targets(const bool val) {
  this->has_local_targets = val;
}

void TRuntimeFilterDesc::__set_has_remote_targets(const bool val) {
  this->has_remote_targets = val;
}

void TRuntimeFilterDesc::__set_applied_on_partition_columns(const bool val) {
  this->applied_on_partition_columns = val;
}

void TRuntimeFilterDesc::__set_ndv_estimate(const int64_t val) {
  this->ndv_estimate = val;
__isset.ndv_estimate = true;
}

void TRuntimeFilterDesc::__set_type(const TRuntimeFilterType::type val) {
  this->type = val;
}

void TRuntimeFilterDesc::__set_compareOp(const  ::impala::extdatasource::TComparisonOp::type val) {
  this->compareOp = val;
}

void TRuntimeFilterDesc::__set_filter_size_bytes(const int64_t val) {
  this->filter_size_bytes = val;
__isset.filter_size_bytes = true;
}

void TRuntimeFilterDesc::__set_src_node_id(const  ::impala::TPlanNodeId val) {
  this->src_node_id = val;
__isset.src_node_id = true;
}
std::ostream& operator<<(std::ostream& out, const TRuntimeFilterDesc& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TRuntimeFilterDesc &a, TRuntimeFilterDesc &b) {
  using ::std::swap;
  swap(a.filter_id, b.filter_id);
  swap(a.src_expr, b.src_expr);
  swap(a.targets, b.targets);
  swap(a.planid_to_target_ndx, b.planid_to_target_ndx);
  swap(a.is_broadcast_join, b.is_broadcast_join);
  swap(a.has_local_targets, b.has_local_targets);
  swap(a.has_remote_targets, b.has_remote_targets);
  swap(a.applied_on_partition_columns, b.applied_on_partition_columns);
  swap(a.ndv_estimate, b.ndv_estimate);
  swap(a.type, b.type);
  swap(a.compareOp, b.compareOp);
  swap(a.filter_size_bytes, b.filter_size_bytes);
  swap(a.src_node_id, b.src_node_id);
  swap(a.__isset, b.__isset);
}

TRuntimeFilterDesc::TRuntimeFilterDesc(const TRuntimeFilterDesc& other26) {
  filter_id = other26.filter_id;
  src_expr = other26.src_expr;
  targets = other26.targets;
  planid_to_target_ndx = other26.planid_to_target_ndx;
  is_broadcast_join = other26.is_broadcast_join;
  has_local_targets = other26.has_local_targets;
  has_remote_targets = other26.has_remote_targets;
  applied_on_partition_columns = other26.applied_on_partition_columns;
  ndv_estimate = other26.ndv_estimate;
  type = other26.type;
  compareOp = other26.compareOp;
  filter_size_bytes = other26.filter_size_bytes;
  src_node_id = other26.src_node_id;
  __isset = other26.__isset;
}
TRuntimeFilterDesc::TRuntimeFilterDesc( TRuntimeFilterDesc&& other27) {
  filter_id = std::move(other27.filter_id);
  src_expr = std::move(other27.src_expr);
  targets = std::move(other27.targets);
  planid_to_target_ndx = std::move(other27.planid_to_target_ndx);
  is_broadcast_join = std::move(other27.is_broadcast_join);
  has_local_targets = std::move(other27.has_local_targets);
  has_remote_targets = std::move(other27.has_remote_targets);
  applied_on_partition_columns = std::move(other27.applied_on_partition_columns);
  ndv_estimate = std::move(other27.ndv_estimate);
  type = std::move(other27.type);
  compareOp = std::move(other27.compareOp);
  filter_size_bytes = std::move(other27.filter_size_bytes);
  src_node_id = std::move(other27.src_node_id);
  __isset = std::move(other27.__isset);
}
TRuntimeFilterDesc& TRuntimeFilterDesc::operator=(const TRuntimeFilterDesc& other28) {
  filter_id = other28.filter_id;
  src_expr = other28.src_expr;
  targets = other28.targets;
  planid_to_target_ndx = other28.planid_to_target_ndx;
  is_broadcast_join = other28.is_broadcast_join;
  has_local_targets = other28.has_local_targets;
  has_remote_targets = other28.has_remote_targets;
  applied_on_partition_columns = other28.applied_on_partition_columns;
  ndv_estimate = other28.ndv_estimate;
  type = other28.type;
  compareOp = other28.compareOp;
  filter_size_bytes = other28.filter_size_bytes;
  src_node_id = other28.src_node_id;
  __isset = other28.__isset;
  return *this;
}
TRuntimeFilterDesc& TRuntimeFilterDesc::operator=(TRuntimeFilterDesc&& other29) {
  filter_id = std::move(other29.filter_id);
  src_expr = std::move(other29.src_expr);
  targets = std::move(other29.targets);
  planid_to_target_ndx = std::move(other29.planid_to_target_ndx);
  is_broadcast_join = std::move(other29.is_broadcast_join);
  has_local_targets = std::move(other29.has_local_targets);
  has_remote_targets = std::move(other29.has_remote_targets);
  applied_on_partition_columns = std::move(other29.applied_on_partition_columns);
  ndv_estimate = std::move(other29.ndv_estimate);
  type = std::move(other29.type);
  compareOp = std::move(other29.compareOp);
  filter_size_bytes = std::move(other29.filter_size_bytes);
  src_node_id = std::move(other29.src_node_id);
  __isset = std::move(other29.__isset);
  return *this;
}
void TRuntimeFilterDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRuntimeFilterDesc(";
  out << "filter_id=" << to_string(filter_id);
  out << ", " << "src_expr=" << to_string(src_expr);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "planid_to_target_ndx=" << to_string(planid_to_target_ndx);
  out << ", " << "is_broadcast_join=" << to_string(is_broadcast_join);
  out << ", " << "has_local_targets=" << to_string(has_local_targets);
  out << ", " << "has_remote_targets=" << to_string(has_remote_targets);
  out << ", " << "applied_on_partition_columns=" << to_string(applied_on_partition_columns);
  out << ", " << "ndv_estimate="; (__isset.ndv_estimate ? (out << to_string(ndv_estimate)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "compareOp=" << to_string(compareOp);
  out << ", " << "filter_size_bytes="; (__isset.filter_size_bytes ? (out << to_string(filter_size_bytes)) : (out << "<null>"));
  out << ", " << "src_node_id="; (__isset.src_node_id ? (out << to_string(src_node_id)) : (out << "<null>"));
  out << ")";
}


THdfsFileSplit::~THdfsFileSplit() throw() {
}


void THdfsFileSplit::__set_relative_path(const std::string& val) {
  this->relative_path = val;
}

void THdfsFileSplit::__set_offset(const int64_t val) {
  this->offset = val;
}

void THdfsFileSplit::__set_length(const int64_t val) {
  this->length = val;
}

void THdfsFileSplit::__set_partition_id(const int64_t val) {
  this->partition_id = val;
}

void THdfsFileSplit::__set_file_length(const int64_t val) {
  this->file_length = val;
}

void THdfsFileSplit::__set_file_compression(const  ::impala::THdfsCompression::type val) {
  this->file_compression = val;
}

void THdfsFileSplit::__set_mtime(const int64_t val) {
  this->mtime = val;
}

void THdfsFileSplit::__set_partition_path_hash(const int32_t val) {
  this->partition_path_hash = val;
}
std::ostream& operator<<(std::ostream& out, const THdfsFileSplit& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsFileSplit &a, THdfsFileSplit &b) {
  using ::std::swap;
  swap(a.relative_path, b.relative_path);
  swap(a.offset, b.offset);
  swap(a.length, b.length);
  swap(a.partition_id, b.partition_id);
  swap(a.file_length, b.file_length);
  swap(a.file_compression, b.file_compression);
  swap(a.mtime, b.mtime);
  swap(a.partition_path_hash, b.partition_path_hash);
}

THdfsFileSplit::THdfsFileSplit(const THdfsFileSplit& other31) {
  relative_path = other31.relative_path;
  offset = other31.offset;
  length = other31.length;
  partition_id = other31.partition_id;
  file_length = other31.file_length;
  file_compression = other31.file_compression;
  mtime = other31.mtime;
  partition_path_hash = other31.partition_path_hash;
}
THdfsFileSplit::THdfsFileSplit( THdfsFileSplit&& other32) {
  relative_path = std::move(other32.relative_path);
  offset = std::move(other32.offset);
  length = std::move(other32.length);
  partition_id = std::move(other32.partition_id);
  file_length = std::move(other32.file_length);
  file_compression = std::move(other32.file_compression);
  mtime = std::move(other32.mtime);
  partition_path_hash = std::move(other32.partition_path_hash);
}
THdfsFileSplit& THdfsFileSplit::operator=(const THdfsFileSplit& other33) {
  relative_path = other33.relative_path;
  offset = other33.offset;
  length = other33.length;
  partition_id = other33.partition_id;
  file_length = other33.file_length;
  file_compression = other33.file_compression;
  mtime = other33.mtime;
  partition_path_hash = other33.partition_path_hash;
  return *this;
}
THdfsFileSplit& THdfsFileSplit::operator=(THdfsFileSplit&& other34) {
  relative_path = std::move(other34.relative_path);
  offset = std::move(other34.offset);
  length = std::move(other34.length);
  partition_id = std::move(other34.partition_id);
  file_length = std::move(other34.file_length);
  file_compression = std::move(other34.file_compression);
  mtime = std::move(other34.mtime);
  partition_path_hash = std::move(other34.partition_path_hash);
  return *this;
}
void THdfsFileSplit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsFileSplit(";
  out << "relative_path=" << to_string(relative_path);
  out << ", " << "offset=" << to_string(offset);
  out << ", " << "length=" << to_string(length);
  out << ", " << "partition_id=" << to_string(partition_id);
  out << ", " << "file_length=" << to_string(file_length);
  out << ", " << "file_compression=" << to_string(file_compression);
  out << ", " << "mtime=" << to_string(mtime);
  out << ", " << "partition_path_hash=" << to_string(partition_path_hash);
  out << ")";
}


THBaseKeyRange::~THBaseKeyRange() throw() {
}


void THBaseKeyRange::__set_startKey(const std::string& val) {
  this->startKey = val;
__isset.startKey = true;
}

void THBaseKeyRange::__set_stopKey(const std::string& val) {
  this->stopKey = val;
__isset.stopKey = true;
}
std::ostream& operator<<(std::ostream& out, const THBaseKeyRange& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THBaseKeyRange &a, THBaseKeyRange &b) {
  using ::std::swap;
  swap(a.startKey, b.startKey);
  swap(a.stopKey, b.stopKey);
  swap(a.__isset, b.__isset);
}

THBaseKeyRange::THBaseKeyRange(const THBaseKeyRange& other35) {
  startKey = other35.startKey;
  stopKey = other35.stopKey;
  __isset = other35.__isset;
}
THBaseKeyRange::THBaseKeyRange( THBaseKeyRange&& other36) {
  startKey = std::move(other36.startKey);
  stopKey = std::move(other36.stopKey);
  __isset = std::move(other36.__isset);
}
THBaseKeyRange& THBaseKeyRange::operator=(const THBaseKeyRange& other37) {
  startKey = other37.startKey;
  stopKey = other37.stopKey;
  __isset = other37.__isset;
  return *this;
}
THBaseKeyRange& THBaseKeyRange::operator=(THBaseKeyRange&& other38) {
  startKey = std::move(other38.startKey);
  stopKey = std::move(other38.stopKey);
  __isset = std::move(other38.__isset);
  return *this;
}
void THBaseKeyRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THBaseKeyRange(";
  out << "startKey="; (__isset.startKey ? (out << to_string(startKey)) : (out << "<null>"));
  out << ", " << "stopKey="; (__isset.stopKey ? (out << to_string(stopKey)) : (out << "<null>"));
  out << ")";
}


TFileSplitGeneratorSpec::~TFileSplitGeneratorSpec() throw() {
}


void TFileSplitGeneratorSpec::__set_file_desc(const  ::impala::THdfsFileDesc& val) {
  this->file_desc = val;
}

void TFileSplitGeneratorSpec::__set_max_block_size(const int64_t val) {
  this->max_block_size = val;
}

void TFileSplitGeneratorSpec::__set_is_splittable(const bool val) {
  this->is_splittable = val;
}

void TFileSplitGeneratorSpec::__set_partition_id(const int64_t val) {
  this->partition_id = val;
}

void TFileSplitGeneratorSpec::__set_partition_path_hash(const int32_t val) {
  this->partition_path_hash = val;
}
std::ostream& operator<<(std::ostream& out, const TFileSplitGeneratorSpec& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TFileSplitGeneratorSpec &a, TFileSplitGeneratorSpec &b) {
  using ::std::swap;
  swap(a.file_desc, b.file_desc);
  swap(a.max_block_size, b.max_block_size);
  swap(a.is_splittable, b.is_splittable);
  swap(a.partition_id, b.partition_id);
  swap(a.partition_path_hash, b.partition_path_hash);
}

TFileSplitGeneratorSpec::TFileSplitGeneratorSpec(const TFileSplitGeneratorSpec& other39) {
  file_desc = other39.file_desc;
  max_block_size = other39.max_block_size;
  is_splittable = other39.is_splittable;
  partition_id = other39.partition_id;
  partition_path_hash = other39.partition_path_hash;
}
TFileSplitGeneratorSpec::TFileSplitGeneratorSpec( TFileSplitGeneratorSpec&& other40) {
  file_desc = std::move(other40.file_desc);
  max_block_size = std::move(other40.max_block_size);
  is_splittable = std::move(other40.is_splittable);
  partition_id = std::move(other40.partition_id);
  partition_path_hash = std::move(other40.partition_path_hash);
}
TFileSplitGeneratorSpec& TFileSplitGeneratorSpec::operator=(const TFileSplitGeneratorSpec& other41) {
  file_desc = other41.file_desc;
  max_block_size = other41.max_block_size;
  is_splittable = other41.is_splittable;
  partition_id = other41.partition_id;
  partition_path_hash = other41.partition_path_hash;
  return *this;
}
TFileSplitGeneratorSpec& TFileSplitGeneratorSpec::operator=(TFileSplitGeneratorSpec&& other42) {
  file_desc = std::move(other42.file_desc);
  max_block_size = std::move(other42.max_block_size);
  is_splittable = std::move(other42.is_splittable);
  partition_id = std::move(other42.partition_id);
  partition_path_hash = std::move(other42.partition_path_hash);
  return *this;
}
void TFileSplitGeneratorSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFileSplitGeneratorSpec(";
  out << "file_desc=" << to_string(file_desc);
  out << ", " << "max_block_size=" << to_string(max_block_size);
  out << ", " << "is_splittable=" << to_string(is_splittable);
  out << ", " << "partition_id=" << to_string(partition_id);
  out << ", " << "partition_path_hash=" << to_string(partition_path_hash);
  out << ")";
}


TScanRange::~TScanRange() throw() {
}


void TScanRange::__set_hdfs_file_split(const THdfsFileSplit& val) {
  this->hdfs_file_split = val;
__isset.hdfs_file_split = true;
}

void TScanRange::__set_hbase_key_range(const THBaseKeyRange& val) {
  this->hbase_key_range = val;
__isset.hbase_key_range = true;
}

void TScanRange::__set_kudu_scan_token(const std::string& val) {
  this->kudu_scan_token = val;
__isset.kudu_scan_token = true;
}
std::ostream& operator<<(std::ostream& out, const TScanRange& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TScanRange &a, TScanRange &b) {
  using ::std::swap;
  swap(a.hdfs_file_split, b.hdfs_file_split);
  swap(a.hbase_key_range, b.hbase_key_range);
  swap(a.kudu_scan_token, b.kudu_scan_token);
  swap(a.__isset, b.__isset);
}

TScanRange::TScanRange(const TScanRange& other43) {
  hdfs_file_split = other43.hdfs_file_split;
  hbase_key_range = other43.hbase_key_range;
  kudu_scan_token = other43.kudu_scan_token;
  __isset = other43.__isset;
}
TScanRange::TScanRange( TScanRange&& other44) {
  hdfs_file_split = std::move(other44.hdfs_file_split);
  hbase_key_range = std::move(other44.hbase_key_range);
  kudu_scan_token = std::move(other44.kudu_scan_token);
  __isset = std::move(other44.__isset);
}
TScanRange& TScanRange::operator=(const TScanRange& other45) {
  hdfs_file_split = other45.hdfs_file_split;
  hbase_key_range = other45.hbase_key_range;
  kudu_scan_token = other45.kudu_scan_token;
  __isset = other45.__isset;
  return *this;
}
TScanRange& TScanRange::operator=(TScanRange&& other46) {
  hdfs_file_split = std::move(other46.hdfs_file_split);
  hbase_key_range = std::move(other46.hbase_key_range);
  kudu_scan_token = std::move(other46.kudu_scan_token);
  __isset = std::move(other46.__isset);
  return *this;
}
void TScanRange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScanRange(";
  out << "hdfs_file_split="; (__isset.hdfs_file_split ? (out << to_string(hdfs_file_split)) : (out << "<null>"));
  out << ", " << "hbase_key_range="; (__isset.hbase_key_range ? (out << to_string(hbase_key_range)) : (out << "<null>"));
  out << ", " << "kudu_scan_token="; (__isset.kudu_scan_token ? (out << to_string(kudu_scan_token)) : (out << "<null>"));
  out << ")";
}


TOverlapPredicateDesc::~TOverlapPredicateDesc() throw() {
}


void TOverlapPredicateDesc::__set_filter_id(const int32_t val) {
  this->filter_id = val;
}

void TOverlapPredicateDesc::__set_slot_index(const int32_t val) {
  this->slot_index = val;
}
std::ostream& operator<<(std::ostream& out, const TOverlapPredicateDesc& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TOverlapPredicateDesc &a, TOverlapPredicateDesc &b) {
  using ::std::swap;
  swap(a.filter_id, b.filter_id);
  swap(a.slot_index, b.slot_index);
}

TOverlapPredicateDesc::TOverlapPredicateDesc(const TOverlapPredicateDesc& other47) {
  filter_id = other47.filter_id;
  slot_index = other47.slot_index;
}
TOverlapPredicateDesc::TOverlapPredicateDesc( TOverlapPredicateDesc&& other48) {
  filter_id = std::move(other48.filter_id);
  slot_index = std::move(other48.slot_index);
}
TOverlapPredicateDesc& TOverlapPredicateDesc::operator=(const TOverlapPredicateDesc& other49) {
  filter_id = other49.filter_id;
  slot_index = other49.slot_index;
  return *this;
}
TOverlapPredicateDesc& TOverlapPredicateDesc::operator=(TOverlapPredicateDesc&& other50) {
  filter_id = std::move(other50.filter_id);
  slot_index = std::move(other50.slot_index);
  return *this;
}
void TOverlapPredicateDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOverlapPredicateDesc(";
  out << "filter_id=" << to_string(filter_id);
  out << ", " << "slot_index=" << to_string(slot_index);
  out << ")";
}


THdfsScanNode::~THdfsScanNode() throw() {
}


void THdfsScanNode::__set_tuple_id(const  ::impala::TTupleId val) {
  this->tuple_id = val;
}

void THdfsScanNode::__set_collection_conjuncts(const std::map< ::impala::TTupleId, std::vector< ::impala::TExpr> > & val) {
  this->collection_conjuncts = val;
__isset.collection_conjuncts = true;
}

void THdfsScanNode::__set_replica_preference(const TReplicaPreference::type val) {
  this->replica_preference = val;
__isset.replica_preference = true;
}

void THdfsScanNode::__set_random_replica(const bool val) {
  this->random_replica = val;
__isset.random_replica = true;
}

void THdfsScanNode::__set_skip_header_line_count(const int32_t val) {
  this->skip_header_line_count = val;
__isset.skip_header_line_count = true;
}

void THdfsScanNode::__set_use_mt_scan_node(const bool val) {
  this->use_mt_scan_node = val;
__isset.use_mt_scan_node = true;
}

void THdfsScanNode::__set_stats_conjuncts(const std::vector< ::impala::TExpr> & val) {
  this->stats_conjuncts = val;
__isset.stats_conjuncts = true;
}

void THdfsScanNode::__set_stats_tuple_id(const  ::impala::TTupleId val) {
  this->stats_tuple_id = val;
__isset.stats_tuple_id = true;
}

void THdfsScanNode::__set_dictionary_filter_conjuncts(const std::map< ::impala::TSlotId, std::vector<int32_t> > & val) {
  this->dictionary_filter_conjuncts = val;
__isset.dictionary_filter_conjuncts = true;
}

void THdfsScanNode::__set_parquet_count_star_slot_offset(const int32_t val) {
  this->parquet_count_star_slot_offset = val;
__isset.parquet_count_star_slot_offset = true;
}

void THdfsScanNode::__set_is_partition_key_scan(const bool val) {
  this->is_partition_key_scan = val;
__isset.is_partition_key_scan = true;
}

void THdfsScanNode::__set_file_formats(const std::set< ::impala::THdfsFileFormat::type> & val) {
  this->file_formats = val;
}

void THdfsScanNode::__set_overlap_predicate_descs(const std::vector<TOverlapPredicateDesc> & val) {
  this->overlap_predicate_descs = val;
__isset.overlap_predicate_descs = true;
}
std::ostream& operator<<(std::ostream& out, const THdfsScanNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsScanNode &a, THdfsScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.collection_conjuncts, b.collection_conjuncts);
  swap(a.replica_preference, b.replica_preference);
  swap(a.random_replica, b.random_replica);
  swap(a.skip_header_line_count, b.skip_header_line_count);
  swap(a.use_mt_scan_node, b.use_mt_scan_node);
  swap(a.stats_conjuncts, b.stats_conjuncts);
  swap(a.stats_tuple_id, b.stats_tuple_id);
  swap(a.dictionary_filter_conjuncts, b.dictionary_filter_conjuncts);
  swap(a.parquet_count_star_slot_offset, b.parquet_count_star_slot_offset);
  swap(a.is_partition_key_scan, b.is_partition_key_scan);
  swap(a.file_formats, b.file_formats);
  swap(a.overlap_predicate_descs, b.overlap_predicate_descs);
  swap(a.__isset, b.__isset);
}

THdfsScanNode::THdfsScanNode(const THdfsScanNode& other100) {
  tuple_id = other100.tuple_id;
  collection_conjuncts = other100.collection_conjuncts;
  replica_preference = other100.replica_preference;
  random_replica = other100.random_replica;
  skip_header_line_count = other100.skip_header_line_count;
  use_mt_scan_node = other100.use_mt_scan_node;
  stats_conjuncts = other100.stats_conjuncts;
  stats_tuple_id = other100.stats_tuple_id;
  dictionary_filter_conjuncts = other100.dictionary_filter_conjuncts;
  parquet_count_star_slot_offset = other100.parquet_count_star_slot_offset;
  is_partition_key_scan = other100.is_partition_key_scan;
  file_formats = other100.file_formats;
  overlap_predicate_descs = other100.overlap_predicate_descs;
  __isset = other100.__isset;
}
THdfsScanNode::THdfsScanNode( THdfsScanNode&& other101) {
  tuple_id = std::move(other101.tuple_id);
  collection_conjuncts = std::move(other101.collection_conjuncts);
  replica_preference = std::move(other101.replica_preference);
  random_replica = std::move(other101.random_replica);
  skip_header_line_count = std::move(other101.skip_header_line_count);
  use_mt_scan_node = std::move(other101.use_mt_scan_node);
  stats_conjuncts = std::move(other101.stats_conjuncts);
  stats_tuple_id = std::move(other101.stats_tuple_id);
  dictionary_filter_conjuncts = std::move(other101.dictionary_filter_conjuncts);
  parquet_count_star_slot_offset = std::move(other101.parquet_count_star_slot_offset);
  is_partition_key_scan = std::move(other101.is_partition_key_scan);
  file_formats = std::move(other101.file_formats);
  overlap_predicate_descs = std::move(other101.overlap_predicate_descs);
  __isset = std::move(other101.__isset);
}
THdfsScanNode& THdfsScanNode::operator=(const THdfsScanNode& other102) {
  tuple_id = other102.tuple_id;
  collection_conjuncts = other102.collection_conjuncts;
  replica_preference = other102.replica_preference;
  random_replica = other102.random_replica;
  skip_header_line_count = other102.skip_header_line_count;
  use_mt_scan_node = other102.use_mt_scan_node;
  stats_conjuncts = other102.stats_conjuncts;
  stats_tuple_id = other102.stats_tuple_id;
  dictionary_filter_conjuncts = other102.dictionary_filter_conjuncts;
  parquet_count_star_slot_offset = other102.parquet_count_star_slot_offset;
  is_partition_key_scan = other102.is_partition_key_scan;
  file_formats = other102.file_formats;
  overlap_predicate_descs = other102.overlap_predicate_descs;
  __isset = other102.__isset;
  return *this;
}
THdfsScanNode& THdfsScanNode::operator=(THdfsScanNode&& other103) {
  tuple_id = std::move(other103.tuple_id);
  collection_conjuncts = std::move(other103.collection_conjuncts);
  replica_preference = std::move(other103.replica_preference);
  random_replica = std::move(other103.random_replica);
  skip_header_line_count = std::move(other103.skip_header_line_count);
  use_mt_scan_node = std::move(other103.use_mt_scan_node);
  stats_conjuncts = std::move(other103.stats_conjuncts);
  stats_tuple_id = std::move(other103.stats_tuple_id);
  dictionary_filter_conjuncts = std::move(other103.dictionary_filter_conjuncts);
  parquet_count_star_slot_offset = std::move(other103.parquet_count_star_slot_offset);
  is_partition_key_scan = std::move(other103.is_partition_key_scan);
  file_formats = std::move(other103.file_formats);
  overlap_predicate_descs = std::move(other103.overlap_predicate_descs);
  __isset = std::move(other103.__isset);
  return *this;
}
void THdfsScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "collection_conjuncts="; (__isset.collection_conjuncts ? (out << to_string(collection_conjuncts)) : (out << "<null>"));
  out << ", " << "replica_preference="; (__isset.replica_preference ? (out << to_string(replica_preference)) : (out << "<null>"));
  out << ", " << "random_replica="; (__isset.random_replica ? (out << to_string(random_replica)) : (out << "<null>"));
  out << ", " << "skip_header_line_count="; (__isset.skip_header_line_count ? (out << to_string(skip_header_line_count)) : (out << "<null>"));
  out << ", " << "use_mt_scan_node="; (__isset.use_mt_scan_node ? (out << to_string(use_mt_scan_node)) : (out << "<null>"));
  out << ", " << "stats_conjuncts="; (__isset.stats_conjuncts ? (out << to_string(stats_conjuncts)) : (out << "<null>"));
  out << ", " << "stats_tuple_id="; (__isset.stats_tuple_id ? (out << to_string(stats_tuple_id)) : (out << "<null>"));
  out << ", " << "dictionary_filter_conjuncts="; (__isset.dictionary_filter_conjuncts ? (out << to_string(dictionary_filter_conjuncts)) : (out << "<null>"));
  out << ", " << "parquet_count_star_slot_offset="; (__isset.parquet_count_star_slot_offset ? (out << to_string(parquet_count_star_slot_offset)) : (out << "<null>"));
  out << ", " << "is_partition_key_scan="; (__isset.is_partition_key_scan ? (out << to_string(is_partition_key_scan)) : (out << "<null>"));
  out << ", " << "file_formats=" << to_string(file_formats);
  out << ", " << "overlap_predicate_descs="; (__isset.overlap_predicate_descs ? (out << to_string(overlap_predicate_descs)) : (out << "<null>"));
  out << ")";
}


TDataSourceScanNode::~TDataSourceScanNode() throw() {
}


void TDataSourceScanNode::__set_tuple_id(const  ::impala::TTupleId val) {
  this->tuple_id = val;
}

void TDataSourceScanNode::__set_data_source(const  ::impala::TDataSource& val) {
  this->data_source = val;
}

void TDataSourceScanNode::__set_init_string(const std::string& val) {
  this->init_string = val;
}

void TDataSourceScanNode::__set_accepted_predicates(const std::vector<std::vector< ::impala::extdatasource::TBinaryPredicate> > & val) {
  this->accepted_predicates = val;
}
std::ostream& operator<<(std::ostream& out, const TDataSourceScanNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDataSourceScanNode &a, TDataSourceScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.data_source, b.data_source);
  swap(a.init_string, b.init_string);
  swap(a.accepted_predicates, b.accepted_predicates);
}

TDataSourceScanNode::TDataSourceScanNode(const TDataSourceScanNode& other116) {
  tuple_id = other116.tuple_id;
  data_source = other116.data_source;
  init_string = other116.init_string;
  accepted_predicates = other116.accepted_predicates;
}
TDataSourceScanNode::TDataSourceScanNode( TDataSourceScanNode&& other117) {
  tuple_id = std::move(other117.tuple_id);
  data_source = std::move(other117.data_source);
  init_string = std::move(other117.init_string);
  accepted_predicates = std::move(other117.accepted_predicates);
}
TDataSourceScanNode& TDataSourceScanNode::operator=(const TDataSourceScanNode& other118) {
  tuple_id = other118.tuple_id;
  data_source = other118.data_source;
  init_string = other118.init_string;
  accepted_predicates = other118.accepted_predicates;
  return *this;
}
TDataSourceScanNode& TDataSourceScanNode::operator=(TDataSourceScanNode&& other119) {
  tuple_id = std::move(other119.tuple_id);
  data_source = std::move(other119.data_source);
  init_string = std::move(other119.init_string);
  accepted_predicates = std::move(other119.accepted_predicates);
  return *this;
}
void TDataSourceScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataSourceScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "data_source=" << to_string(data_source);
  out << ", " << "init_string=" << to_string(init_string);
  out << ", " << "accepted_predicates=" << to_string(accepted_predicates);
  out << ")";
}


THBaseFilter::~THBaseFilter() throw() {
}


void THBaseFilter::__set_family(const std::string& val) {
  this->family = val;
}

void THBaseFilter::__set_qualifier(const std::string& val) {
  this->qualifier = val;
__isset.qualifier = true;
}

void THBaseFilter::__set_op_ordinal(const int32_t val) {
  this->op_ordinal = val;
}

void THBaseFilter::__set_filter_constant(const std::string& val) {
  this->filter_constant = val;
}
std::ostream& operator<<(std::ostream& out, const THBaseFilter& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THBaseFilter &a, THBaseFilter &b) {
  using ::std::swap;
  swap(a.family, b.family);
  swap(a.qualifier, b.qualifier);
  swap(a.op_ordinal, b.op_ordinal);
  swap(a.filter_constant, b.filter_constant);
  swap(a.__isset, b.__isset);
}

THBaseFilter::THBaseFilter(const THBaseFilter& other120) {
  family = other120.family;
  qualifier = other120.qualifier;
  op_ordinal = other120.op_ordinal;
  filter_constant = other120.filter_constant;
  __isset = other120.__isset;
}
THBaseFilter::THBaseFilter( THBaseFilter&& other121) {
  family = std::move(other121.family);
  qualifier = std::move(other121.qualifier);
  op_ordinal = std::move(other121.op_ordinal);
  filter_constant = std::move(other121.filter_constant);
  __isset = std::move(other121.__isset);
}
THBaseFilter& THBaseFilter::operator=(const THBaseFilter& other122) {
  family = other122.family;
  qualifier = other122.qualifier;
  op_ordinal = other122.op_ordinal;
  filter_constant = other122.filter_constant;
  __isset = other122.__isset;
  return *this;
}
THBaseFilter& THBaseFilter::operator=(THBaseFilter&& other123) {
  family = std::move(other123.family);
  qualifier = std::move(other123.qualifier);
  op_ordinal = std::move(other123.op_ordinal);
  filter_constant = std::move(other123.filter_constant);
  __isset = std::move(other123.__isset);
  return *this;
}
void THBaseFilter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THBaseFilter(";
  out << "family=" << to_string(family);
  out << ", " << "qualifier="; (__isset.qualifier ? (out << to_string(qualifier)) : (out << "<null>"));
  out << ", " << "op_ordinal=" << to_string(op_ordinal);
  out << ", " << "filter_constant=" << to_string(filter_constant);
  out << ")";
}


THBaseScanNode::~THBaseScanNode() throw() {
}


void THBaseScanNode::__set_tuple_id(const  ::impala::TTupleId val) {
  this->tuple_id = val;
}

void THBaseScanNode::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void THBaseScanNode::__set_filters(const std::vector<THBaseFilter> & val) {
  this->filters = val;
__isset.filters = true;
}

void THBaseScanNode::__set_suggested_max_caching(const int32_t val) {
  this->suggested_max_caching = val;
__isset.suggested_max_caching = true;
}
std::ostream& operator<<(std::ostream& out, const THBaseScanNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THBaseScanNode &a, THBaseScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.table_name, b.table_name);
  swap(a.filters, b.filters);
  swap(a.suggested_max_caching, b.suggested_max_caching);
  swap(a.__isset, b.__isset);
}

THBaseScanNode::THBaseScanNode(const THBaseScanNode& other130) {
  tuple_id = other130.tuple_id;
  table_name = other130.table_name;
  filters = other130.filters;
  suggested_max_caching = other130.suggested_max_caching;
  __isset = other130.__isset;
}
THBaseScanNode::THBaseScanNode( THBaseScanNode&& other131) {
  tuple_id = std::move(other131.tuple_id);
  table_name = std::move(other131.table_name);
  filters = std::move(other131.filters);
  suggested_max_caching = std::move(other131.suggested_max_caching);
  __isset = std::move(other131.__isset);
}
THBaseScanNode& THBaseScanNode::operator=(const THBaseScanNode& other132) {
  tuple_id = other132.tuple_id;
  table_name = other132.table_name;
  filters = other132.filters;
  suggested_max_caching = other132.suggested_max_caching;
  __isset = other132.__isset;
  return *this;
}
THBaseScanNode& THBaseScanNode::operator=(THBaseScanNode&& other133) {
  tuple_id = std::move(other133.tuple_id);
  table_name = std::move(other133.table_name);
  filters = std::move(other133.filters);
  suggested_max_caching = std::move(other133.suggested_max_caching);
  __isset = std::move(other133.__isset);
  return *this;
}
void THBaseScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THBaseScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "filters="; (__isset.filters ? (out << to_string(filters)) : (out << "<null>"));
  out << ", " << "suggested_max_caching="; (__isset.suggested_max_caching ? (out << to_string(suggested_max_caching)) : (out << "<null>"));
  out << ")";
}


TKuduScanNode::~TKuduScanNode() throw() {
}


void TKuduScanNode::__set_tuple_id(const  ::impala::TTupleId val) {
  this->tuple_id = val;
}

void TKuduScanNode::__set_use_mt_scan_node(const bool val) {
  this->use_mt_scan_node = val;
__isset.use_mt_scan_node = true;
}

void TKuduScanNode::__set_count_star_slot_offset(const int32_t val) {
  this->count_star_slot_offset = val;
__isset.count_star_slot_offset = true;
}
std::ostream& operator<<(std::ostream& out, const TKuduScanNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TKuduScanNode &a, TKuduScanNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.use_mt_scan_node, b.use_mt_scan_node);
  swap(a.count_star_slot_offset, b.count_star_slot_offset);
  swap(a.__isset, b.__isset);
}

TKuduScanNode::TKuduScanNode(const TKuduScanNode& other134) {
  tuple_id = other134.tuple_id;
  use_mt_scan_node = other134.use_mt_scan_node;
  count_star_slot_offset = other134.count_star_slot_offset;
  __isset = other134.__isset;
}
TKuduScanNode::TKuduScanNode( TKuduScanNode&& other135) {
  tuple_id = std::move(other135.tuple_id);
  use_mt_scan_node = std::move(other135.use_mt_scan_node);
  count_star_slot_offset = std::move(other135.count_star_slot_offset);
  __isset = std::move(other135.__isset);
}
TKuduScanNode& TKuduScanNode::operator=(const TKuduScanNode& other136) {
  tuple_id = other136.tuple_id;
  use_mt_scan_node = other136.use_mt_scan_node;
  count_star_slot_offset = other136.count_star_slot_offset;
  __isset = other136.__isset;
  return *this;
}
TKuduScanNode& TKuduScanNode::operator=(TKuduScanNode&& other137) {
  tuple_id = std::move(other137.tuple_id);
  use_mt_scan_node = std::move(other137.use_mt_scan_node);
  count_star_slot_offset = std::move(other137.count_star_slot_offset);
  __isset = std::move(other137.__isset);
  return *this;
}
void TKuduScanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduScanNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "use_mt_scan_node="; (__isset.use_mt_scan_node ? (out << to_string(use_mt_scan_node)) : (out << "<null>"));
  out << ", " << "count_star_slot_offset="; (__isset.count_star_slot_offset ? (out << to_string(count_star_slot_offset)) : (out << "<null>"));
  out << ")";
}


TEqJoinCondition::~TEqJoinCondition() throw() {
}


void TEqJoinCondition::__set_left(const  ::impala::TExpr& val) {
  this->left = val;
}

void TEqJoinCondition::__set_right(const  ::impala::TExpr& val) {
  this->right = val;
}

void TEqJoinCondition::__set_is_not_distinct_from(const bool val) {
  this->is_not_distinct_from = val;
}
std::ostream& operator<<(std::ostream& out, const TEqJoinCondition& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TEqJoinCondition &a, TEqJoinCondition &b) {
  using ::std::swap;
  swap(a.left, b.left);
  swap(a.right, b.right);
  swap(a.is_not_distinct_from, b.is_not_distinct_from);
}

TEqJoinCondition::TEqJoinCondition(const TEqJoinCondition& other138) {
  left = other138.left;
  right = other138.right;
  is_not_distinct_from = other138.is_not_distinct_from;
}
TEqJoinCondition::TEqJoinCondition( TEqJoinCondition&& other139) {
  left = std::move(other139.left);
  right = std::move(other139.right);
  is_not_distinct_from = std::move(other139.is_not_distinct_from);
}
TEqJoinCondition& TEqJoinCondition::operator=(const TEqJoinCondition& other140) {
  left = other140.left;
  right = other140.right;
  is_not_distinct_from = other140.is_not_distinct_from;
  return *this;
}
TEqJoinCondition& TEqJoinCondition::operator=(TEqJoinCondition&& other141) {
  left = std::move(other141.left);
  right = std::move(other141.right);
  is_not_distinct_from = std::move(other141.is_not_distinct_from);
  return *this;
}
void TEqJoinCondition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TEqJoinCondition(";
  out << "left=" << to_string(left);
  out << ", " << "right=" << to_string(right);
  out << ", " << "is_not_distinct_from=" << to_string(is_not_distinct_from);
  out << ")";
}


THashJoinNode::~THashJoinNode() throw() {
}


void THashJoinNode::__set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val) {
  this->eq_join_conjuncts = val;
}

void THashJoinNode::__set_other_join_conjuncts(const std::vector< ::impala::TExpr> & val) {
  this->other_join_conjuncts = val;
__isset.other_join_conjuncts = true;
}

void THashJoinNode::__set_hash_seed(const int32_t val) {
  this->hash_seed = val;
__isset.hash_seed = true;
}
std::ostream& operator<<(std::ostream& out, const THashJoinNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THashJoinNode &a, THashJoinNode &b) {
  using ::std::swap;
  swap(a.eq_join_conjuncts, b.eq_join_conjuncts);
  swap(a.other_join_conjuncts, b.other_join_conjuncts);
  swap(a.hash_seed, b.hash_seed);
  swap(a.__isset, b.__isset);
}

THashJoinNode::THashJoinNode(const THashJoinNode& other154) {
  eq_join_conjuncts = other154.eq_join_conjuncts;
  other_join_conjuncts = other154.other_join_conjuncts;
  hash_seed = other154.hash_seed;
  __isset = other154.__isset;
}
THashJoinNode::THashJoinNode( THashJoinNode&& other155) {
  eq_join_conjuncts = std::move(other155.eq_join_conjuncts);
  other_join_conjuncts = std::move(other155.other_join_conjuncts);
  hash_seed = std::move(other155.hash_seed);
  __isset = std::move(other155.__isset);
}
THashJoinNode& THashJoinNode::operator=(const THashJoinNode& other156) {
  eq_join_conjuncts = other156.eq_join_conjuncts;
  other_join_conjuncts = other156.other_join_conjuncts;
  hash_seed = other156.hash_seed;
  __isset = other156.__isset;
  return *this;
}
THashJoinNode& THashJoinNode::operator=(THashJoinNode&& other157) {
  eq_join_conjuncts = std::move(other157.eq_join_conjuncts);
  other_join_conjuncts = std::move(other157.other_join_conjuncts);
  hash_seed = std::move(other157.hash_seed);
  __isset = std::move(other157.__isset);
  return *this;
}
void THashJoinNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THashJoinNode(";
  out << "eq_join_conjuncts=" << to_string(eq_join_conjuncts);
  out << ", " << "other_join_conjuncts="; (__isset.other_join_conjuncts ? (out << to_string(other_join_conjuncts)) : (out << "<null>"));
  out << ", " << "hash_seed="; (__isset.hash_seed ? (out << to_string(hash_seed)) : (out << "<null>"));
  out << ")";
}


TNestedLoopJoinNode::~TNestedLoopJoinNode() throw() {
}


void TNestedLoopJoinNode::__set_join_conjuncts(const std::vector< ::impala::TExpr> & val) {
  this->join_conjuncts = val;
__isset.join_conjuncts = true;
}
std::ostream& operator<<(std::ostream& out, const TNestedLoopJoinNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TNestedLoopJoinNode &a, TNestedLoopJoinNode &b) {
  using ::std::swap;
  swap(a.join_conjuncts, b.join_conjuncts);
  swap(a.__isset, b.__isset);
}

TNestedLoopJoinNode::TNestedLoopJoinNode(const TNestedLoopJoinNode& other164) {
  join_conjuncts = other164.join_conjuncts;
  __isset = other164.__isset;
}
TNestedLoopJoinNode::TNestedLoopJoinNode( TNestedLoopJoinNode&& other165) {
  join_conjuncts = std::move(other165.join_conjuncts);
  __isset = std::move(other165.__isset);
}
TNestedLoopJoinNode& TNestedLoopJoinNode::operator=(const TNestedLoopJoinNode& other166) {
  join_conjuncts = other166.join_conjuncts;
  __isset = other166.__isset;
  return *this;
}
TNestedLoopJoinNode& TNestedLoopJoinNode::operator=(TNestedLoopJoinNode&& other167) {
  join_conjuncts = std::move(other167.join_conjuncts);
  __isset = std::move(other167.__isset);
  return *this;
}
void TNestedLoopJoinNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNestedLoopJoinNode(";
  out << "join_conjuncts="; (__isset.join_conjuncts ? (out << to_string(join_conjuncts)) : (out << "<null>"));
  out << ")";
}


TJoinNode::~TJoinNode() throw() {
}


void TJoinNode::__set_join_op(const TJoinOp::type val) {
  this->join_op = val;
}

void TJoinNode::__set_build_tuples(const std::vector< ::impala::TTupleId> & val) {
  this->build_tuples = val;
__isset.build_tuples = true;
}

void TJoinNode::__set_nullable_build_tuples(const std::vector<bool> & val) {
  this->nullable_build_tuples = val;
__isset.nullable_build_tuples = true;
}

void TJoinNode::__set_hash_join_node(const THashJoinNode& val) {
  this->hash_join_node = val;
__isset.hash_join_node = true;
}

void TJoinNode::__set_nested_loop_join_node(const TNestedLoopJoinNode& val) {
  this->nested_loop_join_node = val;
__isset.nested_loop_join_node = true;
}
std::ostream& operator<<(std::ostream& out, const TJoinNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TJoinNode &a, TJoinNode &b) {
  using ::std::swap;
  swap(a.join_op, b.join_op);
  swap(a.build_tuples, b.build_tuples);
  swap(a.nullable_build_tuples, b.nullable_build_tuples);
  swap(a.hash_join_node, b.hash_join_node);
  swap(a.nested_loop_join_node, b.nested_loop_join_node);
  swap(a.__isset, b.__isset);
}

TJoinNode::TJoinNode(const TJoinNode& other181) {
  join_op = other181.join_op;
  build_tuples = other181.build_tuples;
  nullable_build_tuples = other181.nullable_build_tuples;
  hash_join_node = other181.hash_join_node;
  nested_loop_join_node = other181.nested_loop_join_node;
  __isset = other181.__isset;
}
TJoinNode::TJoinNode( TJoinNode&& other182) {
  join_op = std::move(other182.join_op);
  build_tuples = std::move(other182.build_tuples);
  nullable_build_tuples = std::move(other182.nullable_build_tuples);
  hash_join_node = std::move(other182.hash_join_node);
  nested_loop_join_node = std::move(other182.nested_loop_join_node);
  __isset = std::move(other182.__isset);
}
TJoinNode& TJoinNode::operator=(const TJoinNode& other183) {
  join_op = other183.join_op;
  build_tuples = other183.build_tuples;
  nullable_build_tuples = other183.nullable_build_tuples;
  hash_join_node = other183.hash_join_node;
  nested_loop_join_node = other183.nested_loop_join_node;
  __isset = other183.__isset;
  return *this;
}
TJoinNode& TJoinNode::operator=(TJoinNode&& other184) {
  join_op = std::move(other184.join_op);
  build_tuples = std::move(other184.build_tuples);
  nullable_build_tuples = std::move(other184.nullable_build_tuples);
  hash_join_node = std::move(other184.hash_join_node);
  nested_loop_join_node = std::move(other184.nested_loop_join_node);
  __isset = std::move(other184.__isset);
  return *this;
}
void TJoinNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TJoinNode(";
  out << "join_op=" << to_string(join_op);
  out << ", " << "build_tuples="; (__isset.build_tuples ? (out << to_string(build_tuples)) : (out << "<null>"));
  out << ", " << "nullable_build_tuples="; (__isset.nullable_build_tuples ? (out << to_string(nullable_build_tuples)) : (out << "<null>"));
  out << ", " << "hash_join_node="; (__isset.hash_join_node ? (out << to_string(hash_join_node)) : (out << "<null>"));
  out << ", " << "nested_loop_join_node="; (__isset.nested_loop_join_node ? (out << to_string(nested_loop_join_node)) : (out << "<null>"));
  out << ")";
}


TAggregator::~TAggregator() throw() {
}


void TAggregator::__set_grouping_exprs(const std::vector< ::impala::TExpr> & val) {
  this->grouping_exprs = val;
__isset.grouping_exprs = true;
}

void TAggregator::__set_aggregate_functions(const std::vector< ::impala::TExpr> & val) {
  this->aggregate_functions = val;
}

void TAggregator::__set_intermediate_tuple_id(const  ::impala::TTupleId val) {
  this->intermediate_tuple_id = val;
}

void TAggregator::__set_output_tuple_id(const  ::impala::TTupleId val) {
  this->output_tuple_id = val;
}

void TAggregator::__set_need_finalize(const bool val) {
  this->need_finalize = val;
}

void TAggregator::__set_use_streaming_preaggregation(const bool val) {
  this->use_streaming_preaggregation = val;
}

void TAggregator::__set_resource_profile(const  ::impala::TBackendResourceProfile& val) {
  this->resource_profile = val;
}
std::ostream& operator<<(std::ostream& out, const TAggregator& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAggregator &a, TAggregator &b) {
  using ::std::swap;
  swap(a.grouping_exprs, b.grouping_exprs);
  swap(a.aggregate_functions, b.aggregate_functions);
  swap(a.intermediate_tuple_id, b.intermediate_tuple_id);
  swap(a.output_tuple_id, b.output_tuple_id);
  swap(a.need_finalize, b.need_finalize);
  swap(a.use_streaming_preaggregation, b.use_streaming_preaggregation);
  swap(a.resource_profile, b.resource_profile);
  swap(a.__isset, b.__isset);
}

TAggregator::TAggregator(const TAggregator& other197) {
  grouping_exprs = other197.grouping_exprs;
  aggregate_functions = other197.aggregate_functions;
  intermediate_tuple_id = other197.intermediate_tuple_id;
  output_tuple_id = other197.output_tuple_id;
  need_finalize = other197.need_finalize;
  use_streaming_preaggregation = other197.use_streaming_preaggregation;
  resource_profile = other197.resource_profile;
  __isset = other197.__isset;
}
TAggregator::TAggregator( TAggregator&& other198) {
  grouping_exprs = std::move(other198.grouping_exprs);
  aggregate_functions = std::move(other198.aggregate_functions);
  intermediate_tuple_id = std::move(other198.intermediate_tuple_id);
  output_tuple_id = std::move(other198.output_tuple_id);
  need_finalize = std::move(other198.need_finalize);
  use_streaming_preaggregation = std::move(other198.use_streaming_preaggregation);
  resource_profile = std::move(other198.resource_profile);
  __isset = std::move(other198.__isset);
}
TAggregator& TAggregator::operator=(const TAggregator& other199) {
  grouping_exprs = other199.grouping_exprs;
  aggregate_functions = other199.aggregate_functions;
  intermediate_tuple_id = other199.intermediate_tuple_id;
  output_tuple_id = other199.output_tuple_id;
  need_finalize = other199.need_finalize;
  use_streaming_preaggregation = other199.use_streaming_preaggregation;
  resource_profile = other199.resource_profile;
  __isset = other199.__isset;
  return *this;
}
TAggregator& TAggregator::operator=(TAggregator&& other200) {
  grouping_exprs = std::move(other200.grouping_exprs);
  aggregate_functions = std::move(other200.aggregate_functions);
  intermediate_tuple_id = std::move(other200.intermediate_tuple_id);
  output_tuple_id = std::move(other200.output_tuple_id);
  need_finalize = std::move(other200.need_finalize);
  use_streaming_preaggregation = std::move(other200.use_streaming_preaggregation);
  resource_profile = std::move(other200.resource_profile);
  __isset = std::move(other200.__isset);
  return *this;
}
void TAggregator::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregator(";
  out << "grouping_exprs="; (__isset.grouping_exprs ? (out << to_string(grouping_exprs)) : (out << "<null>"));
  out << ", " << "aggregate_functions=" << to_string(aggregate_functions);
  out << ", " << "intermediate_tuple_id=" << to_string(intermediate_tuple_id);
  out << ", " << "output_tuple_id=" << to_string(output_tuple_id);
  out << ", " << "need_finalize=" << to_string(need_finalize);
  out << ", " << "use_streaming_preaggregation=" << to_string(use_streaming_preaggregation);
  out << ", " << "resource_profile=" << to_string(resource_profile);
  out << ")";
}


TAggregationNode::~TAggregationNode() throw() {
}


void TAggregationNode::__set_aggregators(const std::vector<TAggregator> & val) {
  this->aggregators = val;
}

void TAggregationNode::__set_estimated_input_cardinality(const int64_t val) {
  this->estimated_input_cardinality = val;
}

void TAggregationNode::__set_replicate_input(const bool val) {
  this->replicate_input = val;
}

void TAggregationNode::__set_fast_limit_check(const bool val) {
  this->fast_limit_check = val;
}
std::ostream& operator<<(std::ostream& out, const TAggregationNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAggregationNode &a, TAggregationNode &b) {
  using ::std::swap;
  swap(a.aggregators, b.aggregators);
  swap(a.estimated_input_cardinality, b.estimated_input_cardinality);
  swap(a.replicate_input, b.replicate_input);
  swap(a.fast_limit_check, b.fast_limit_check);
}

TAggregationNode::TAggregationNode(const TAggregationNode& other207) {
  aggregators = other207.aggregators;
  estimated_input_cardinality = other207.estimated_input_cardinality;
  replicate_input = other207.replicate_input;
  fast_limit_check = other207.fast_limit_check;
}
TAggregationNode::TAggregationNode( TAggregationNode&& other208) {
  aggregators = std::move(other208.aggregators);
  estimated_input_cardinality = std::move(other208.estimated_input_cardinality);
  replicate_input = std::move(other208.replicate_input);
  fast_limit_check = std::move(other208.fast_limit_check);
}
TAggregationNode& TAggregationNode::operator=(const TAggregationNode& other209) {
  aggregators = other209.aggregators;
  estimated_input_cardinality = other209.estimated_input_cardinality;
  replicate_input = other209.replicate_input;
  fast_limit_check = other209.fast_limit_check;
  return *this;
}
TAggregationNode& TAggregationNode::operator=(TAggregationNode&& other210) {
  aggregators = std::move(other210.aggregators);
  estimated_input_cardinality = std::move(other210.estimated_input_cardinality);
  replicate_input = std::move(other210.replicate_input);
  fast_limit_check = std::move(other210.fast_limit_check);
  return *this;
}
void TAggregationNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregationNode(";
  out << "aggregators=" << to_string(aggregators);
  out << ", " << "estimated_input_cardinality=" << to_string(estimated_input_cardinality);
  out << ", " << "replicate_input=" << to_string(replicate_input);
  out << ", " << "fast_limit_check=" << to_string(fast_limit_check);
  out << ")";
}


TSortInfo::~TSortInfo() throw() {
}


void TSortInfo::__set_ordering_exprs(const std::vector< ::impala::TExpr> & val) {
  this->ordering_exprs = val;
}

void TSortInfo::__set_is_asc_order(const std::vector<bool> & val) {
  this->is_asc_order = val;
}

void TSortInfo::__set_nulls_first(const std::vector<bool> & val) {
  this->nulls_first = val;
}

void TSortInfo::__set_sort_tuple_slot_exprs(const std::vector< ::impala::TExpr> & val) {
  this->sort_tuple_slot_exprs = val;
__isset.sort_tuple_slot_exprs = true;
}

void TSortInfo::__set_sorting_order(const  ::impala::TSortingOrder::type val) {
  this->sorting_order = val;
}

void TSortInfo::__set_num_lexical_keys_in_zorder(const int32_t val) {
  this->num_lexical_keys_in_zorder = val;
__isset.num_lexical_keys_in_zorder = true;
}
std::ostream& operator<<(std::ostream& out, const TSortInfo& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TSortInfo &a, TSortInfo &b) {
  using ::std::swap;
  swap(a.ordering_exprs, b.ordering_exprs);
  swap(a.is_asc_order, b.is_asc_order);
  swap(a.nulls_first, b.nulls_first);
  swap(a.sort_tuple_slot_exprs, b.sort_tuple_slot_exprs);
  swap(a.sorting_order, b.sorting_order);
  swap(a.num_lexical_keys_in_zorder, b.num_lexical_keys_in_zorder);
  swap(a.__isset, b.__isset);
}

TSortInfo::TSortInfo(const TSortInfo& other236) {
  ordering_exprs = other236.ordering_exprs;
  is_asc_order = other236.is_asc_order;
  nulls_first = other236.nulls_first;
  sort_tuple_slot_exprs = other236.sort_tuple_slot_exprs;
  sorting_order = other236.sorting_order;
  num_lexical_keys_in_zorder = other236.num_lexical_keys_in_zorder;
  __isset = other236.__isset;
}
TSortInfo::TSortInfo( TSortInfo&& other237) {
  ordering_exprs = std::move(other237.ordering_exprs);
  is_asc_order = std::move(other237.is_asc_order);
  nulls_first = std::move(other237.nulls_first);
  sort_tuple_slot_exprs = std::move(other237.sort_tuple_slot_exprs);
  sorting_order = std::move(other237.sorting_order);
  num_lexical_keys_in_zorder = std::move(other237.num_lexical_keys_in_zorder);
  __isset = std::move(other237.__isset);
}
TSortInfo& TSortInfo::operator=(const TSortInfo& other238) {
  ordering_exprs = other238.ordering_exprs;
  is_asc_order = other238.is_asc_order;
  nulls_first = other238.nulls_first;
  sort_tuple_slot_exprs = other238.sort_tuple_slot_exprs;
  sorting_order = other238.sorting_order;
  num_lexical_keys_in_zorder = other238.num_lexical_keys_in_zorder;
  __isset = other238.__isset;
  return *this;
}
TSortInfo& TSortInfo::operator=(TSortInfo&& other239) {
  ordering_exprs = std::move(other239.ordering_exprs);
  is_asc_order = std::move(other239.is_asc_order);
  nulls_first = std::move(other239.nulls_first);
  sort_tuple_slot_exprs = std::move(other239.sort_tuple_slot_exprs);
  sorting_order = std::move(other239.sorting_order);
  num_lexical_keys_in_zorder = std::move(other239.num_lexical_keys_in_zorder);
  __isset = std::move(other239.__isset);
  return *this;
}
void TSortInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSortInfo(";
  out << "ordering_exprs=" << to_string(ordering_exprs);
  out << ", " << "is_asc_order=" << to_string(is_asc_order);
  out << ", " << "nulls_first=" << to_string(nulls_first);
  out << ", " << "sort_tuple_slot_exprs="; (__isset.sort_tuple_slot_exprs ? (out << to_string(sort_tuple_slot_exprs)) : (out << "<null>"));
  out << ", " << "sorting_order=" << to_string(sorting_order);
  out << ", " << "num_lexical_keys_in_zorder="; (__isset.num_lexical_keys_in_zorder ? (out << to_string(num_lexical_keys_in_zorder)) : (out << "<null>"));
  out << ")";
}


TSortNode::~TSortNode() throw() {
}


void TSortNode::__set_sort_info(const TSortInfo& val) {
  this->sort_info = val;
}

void TSortNode::__set_type(const TSortType::type val) {
  this->type = val;
}

void TSortNode::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void TSortNode::__set_estimated_full_input_size(const int64_t val) {
  this->estimated_full_input_size = val;
__isset.estimated_full_input_size = true;
}

void TSortNode::__set_include_ties(const bool val) {
  this->include_ties = val;
__isset.include_ties = true;
}

void TSortNode::__set_limit_with_ties(const int64_t val) {
  this->limit_with_ties = val;
__isset.limit_with_ties = true;
}

void TSortNode::__set_per_partition_limit(const int64_t val) {
  this->per_partition_limit = val;
__isset.per_partition_limit = true;
}

void TSortNode::__set_partition_exprs(const std::vector< ::impala::TExpr> & val) {
  this->partition_exprs = val;
__isset.partition_exprs = true;
}

void TSortNode::__set_intra_partition_sort_info(const TSortInfo& val) {
  this->intra_partition_sort_info = val;
__isset.intra_partition_sort_info = true;
}
std::ostream& operator<<(std::ostream& out, const TSortNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TSortNode &a, TSortNode &b) {
  using ::std::swap;
  swap(a.sort_info, b.sort_info);
  swap(a.type, b.type);
  swap(a.offset, b.offset);
  swap(a.estimated_full_input_size, b.estimated_full_input_size);
  swap(a.include_ties, b.include_ties);
  swap(a.limit_with_ties, b.limit_with_ties);
  swap(a.per_partition_limit, b.per_partition_limit);
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.intra_partition_sort_info, b.intra_partition_sort_info);
  swap(a.__isset, b.__isset);
}

TSortNode::TSortNode(const TSortNode& other247) {
  sort_info = other247.sort_info;
  type = other247.type;
  offset = other247.offset;
  estimated_full_input_size = other247.estimated_full_input_size;
  include_ties = other247.include_ties;
  limit_with_ties = other247.limit_with_ties;
  per_partition_limit = other247.per_partition_limit;
  partition_exprs = other247.partition_exprs;
  intra_partition_sort_info = other247.intra_partition_sort_info;
  __isset = other247.__isset;
}
TSortNode::TSortNode( TSortNode&& other248) {
  sort_info = std::move(other248.sort_info);
  type = std::move(other248.type);
  offset = std::move(other248.offset);
  estimated_full_input_size = std::move(other248.estimated_full_input_size);
  include_ties = std::move(other248.include_ties);
  limit_with_ties = std::move(other248.limit_with_ties);
  per_partition_limit = std::move(other248.per_partition_limit);
  partition_exprs = std::move(other248.partition_exprs);
  intra_partition_sort_info = std::move(other248.intra_partition_sort_info);
  __isset = std::move(other248.__isset);
}
TSortNode& TSortNode::operator=(const TSortNode& other249) {
  sort_info = other249.sort_info;
  type = other249.type;
  offset = other249.offset;
  estimated_full_input_size = other249.estimated_full_input_size;
  include_ties = other249.include_ties;
  limit_with_ties = other249.limit_with_ties;
  per_partition_limit = other249.per_partition_limit;
  partition_exprs = other249.partition_exprs;
  intra_partition_sort_info = other249.intra_partition_sort_info;
  __isset = other249.__isset;
  return *this;
}
TSortNode& TSortNode::operator=(TSortNode&& other250) {
  sort_info = std::move(other250.sort_info);
  type = std::move(other250.type);
  offset = std::move(other250.offset);
  estimated_full_input_size = std::move(other250.estimated_full_input_size);
  include_ties = std::move(other250.include_ties);
  limit_with_ties = std::move(other250.limit_with_ties);
  per_partition_limit = std::move(other250.per_partition_limit);
  partition_exprs = std::move(other250.partition_exprs);
  intra_partition_sort_info = std::move(other250.intra_partition_sort_info);
  __isset = std::move(other250.__isset);
  return *this;
}
void TSortNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSortNode(";
  out << "sort_info=" << to_string(sort_info);
  out << ", " << "type=" << to_string(type);
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "estimated_full_input_size="; (__isset.estimated_full_input_size ? (out << to_string(estimated_full_input_size)) : (out << "<null>"));
  out << ", " << "include_ties="; (__isset.include_ties ? (out << to_string(include_ties)) : (out << "<null>"));
  out << ", " << "limit_with_ties="; (__isset.limit_with_ties ? (out << to_string(limit_with_ties)) : (out << "<null>"));
  out << ", " << "per_partition_limit="; (__isset.per_partition_limit ? (out << to_string(per_partition_limit)) : (out << "<null>"));
  out << ", " << "partition_exprs="; (__isset.partition_exprs ? (out << to_string(partition_exprs)) : (out << "<null>"));
  out << ", " << "intra_partition_sort_info="; (__isset.intra_partition_sort_info ? (out << to_string(intra_partition_sort_info)) : (out << "<null>"));
  out << ")";
}


TAnalyticWindowBoundary::~TAnalyticWindowBoundary() throw() {
}


void TAnalyticWindowBoundary::__set_type(const TAnalyticWindowBoundaryType::type val) {
  this->type = val;
}

void TAnalyticWindowBoundary::__set_range_offset_predicate(const  ::impala::TExpr& val) {
  this->range_offset_predicate = val;
__isset.range_offset_predicate = true;
}

void TAnalyticWindowBoundary::__set_rows_offset_value(const int64_t val) {
  this->rows_offset_value = val;
__isset.rows_offset_value = true;
}
std::ostream& operator<<(std::ostream& out, const TAnalyticWindowBoundary& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAnalyticWindowBoundary &a, TAnalyticWindowBoundary &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.range_offset_predicate, b.range_offset_predicate);
  swap(a.rows_offset_value, b.rows_offset_value);
  swap(a.__isset, b.__isset);
}

TAnalyticWindowBoundary::TAnalyticWindowBoundary(const TAnalyticWindowBoundary& other252) {
  type = other252.type;
  range_offset_predicate = other252.range_offset_predicate;
  rows_offset_value = other252.rows_offset_value;
  __isset = other252.__isset;
}
TAnalyticWindowBoundary::TAnalyticWindowBoundary( TAnalyticWindowBoundary&& other253) {
  type = std::move(other253.type);
  range_offset_predicate = std::move(other253.range_offset_predicate);
  rows_offset_value = std::move(other253.rows_offset_value);
  __isset = std::move(other253.__isset);
}
TAnalyticWindowBoundary& TAnalyticWindowBoundary::operator=(const TAnalyticWindowBoundary& other254) {
  type = other254.type;
  range_offset_predicate = other254.range_offset_predicate;
  rows_offset_value = other254.rows_offset_value;
  __isset = other254.__isset;
  return *this;
}
TAnalyticWindowBoundary& TAnalyticWindowBoundary::operator=(TAnalyticWindowBoundary&& other255) {
  type = std::move(other255.type);
  range_offset_predicate = std::move(other255.range_offset_predicate);
  rows_offset_value = std::move(other255.rows_offset_value);
  __isset = std::move(other255.__isset);
  return *this;
}
void TAnalyticWindowBoundary::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAnalyticWindowBoundary(";
  out << "type=" << to_string(type);
  out << ", " << "range_offset_predicate="; (__isset.range_offset_predicate ? (out << to_string(range_offset_predicate)) : (out << "<null>"));
  out << ", " << "rows_offset_value="; (__isset.rows_offset_value ? (out << to_string(rows_offset_value)) : (out << "<null>"));
  out << ")";
}


TAnalyticWindow::~TAnalyticWindow() throw() {
}


void TAnalyticWindow::__set_type(const TAnalyticWindowType::type val) {
  this->type = val;
}

void TAnalyticWindow::__set_window_start(const TAnalyticWindowBoundary& val) {
  this->window_start = val;
__isset.window_start = true;
}

void TAnalyticWindow::__set_window_end(const TAnalyticWindowBoundary& val) {
  this->window_end = val;
__isset.window_end = true;
}
std::ostream& operator<<(std::ostream& out, const TAnalyticWindow& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAnalyticWindow &a, TAnalyticWindow &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.window_start, b.window_start);
  swap(a.window_end, b.window_end);
  swap(a.__isset, b.__isset);
}

TAnalyticWindow::TAnalyticWindow(const TAnalyticWindow& other257) {
  type = other257.type;
  window_start = other257.window_start;
  window_end = other257.window_end;
  __isset = other257.__isset;
}
TAnalyticWindow::TAnalyticWindow( TAnalyticWindow&& other258) {
  type = std::move(other258.type);
  window_start = std::move(other258.window_start);
  window_end = std::move(other258.window_end);
  __isset = std::move(other258.__isset);
}
TAnalyticWindow& TAnalyticWindow::operator=(const TAnalyticWindow& other259) {
  type = other259.type;
  window_start = other259.window_start;
  window_end = other259.window_end;
  __isset = other259.__isset;
  return *this;
}
TAnalyticWindow& TAnalyticWindow::operator=(TAnalyticWindow&& other260) {
  type = std::move(other260.type);
  window_start = std::move(other260.window_start);
  window_end = std::move(other260.window_end);
  __isset = std::move(other260.__isset);
  return *this;
}
void TAnalyticWindow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAnalyticWindow(";
  out << "type=" << to_string(type);
  out << ", " << "window_start="; (__isset.window_start ? (out << to_string(window_start)) : (out << "<null>"));
  out << ", " << "window_end="; (__isset.window_end ? (out << to_string(window_end)) : (out << "<null>"));
  out << ")";
}


TAnalyticNode::~TAnalyticNode() throw() {
}


void TAnalyticNode::__set_partition_exprs(const std::vector< ::impala::TExpr> & val) {
  this->partition_exprs = val;
}

void TAnalyticNode::__set_order_by_exprs(const std::vector< ::impala::TExpr> & val) {
  this->order_by_exprs = val;
}

void TAnalyticNode::__set_analytic_functions(const std::vector< ::impala::TExpr> & val) {
  this->analytic_functions = val;
}

void TAnalyticNode::__set_window(const TAnalyticWindow& val) {
  this->window = val;
__isset.window = true;
}

void TAnalyticNode::__set_intermediate_tuple_id(const  ::impala::TTupleId val) {
  this->intermediate_tuple_id = val;
}

void TAnalyticNode::__set_output_tuple_id(const  ::impala::TTupleId val) {
  this->output_tuple_id = val;
}

void TAnalyticNode::__set_buffered_tuple_id(const  ::impala::TTupleId val) {
  this->buffered_tuple_id = val;
__isset.buffered_tuple_id = true;
}

void TAnalyticNode::__set_partition_by_eq(const  ::impala::TExpr& val) {
  this->partition_by_eq = val;
__isset.partition_by_eq = true;
}

void TAnalyticNode::__set_order_by_eq(const  ::impala::TExpr& val) {
  this->order_by_eq = val;
__isset.order_by_eq = true;
}
std::ostream& operator<<(std::ostream& out, const TAnalyticNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAnalyticNode &a, TAnalyticNode &b) {
  using ::std::swap;
  swap(a.partition_exprs, b.partition_exprs);
  swap(a.order_by_exprs, b.order_by_exprs);
  swap(a.analytic_functions, b.analytic_functions);
  swap(a.window, b.window);
  swap(a.intermediate_tuple_id, b.intermediate_tuple_id);
  swap(a.output_tuple_id, b.output_tuple_id);
  swap(a.buffered_tuple_id, b.buffered_tuple_id);
  swap(a.partition_by_eq, b.partition_by_eq);
  swap(a.order_by_eq, b.order_by_eq);
  swap(a.__isset, b.__isset);
}

TAnalyticNode::TAnalyticNode(const TAnalyticNode& other279) {
  partition_exprs = other279.partition_exprs;
  order_by_exprs = other279.order_by_exprs;
  analytic_functions = other279.analytic_functions;
  window = other279.window;
  intermediate_tuple_id = other279.intermediate_tuple_id;
  output_tuple_id = other279.output_tuple_id;
  buffered_tuple_id = other279.buffered_tuple_id;
  partition_by_eq = other279.partition_by_eq;
  order_by_eq = other279.order_by_eq;
  __isset = other279.__isset;
}
TAnalyticNode::TAnalyticNode( TAnalyticNode&& other280) {
  partition_exprs = std::move(other280.partition_exprs);
  order_by_exprs = std::move(other280.order_by_exprs);
  analytic_functions = std::move(other280.analytic_functions);
  window = std::move(other280.window);
  intermediate_tuple_id = std::move(other280.intermediate_tuple_id);
  output_tuple_id = std::move(other280.output_tuple_id);
  buffered_tuple_id = std::move(other280.buffered_tuple_id);
  partition_by_eq = std::move(other280.partition_by_eq);
  order_by_eq = std::move(other280.order_by_eq);
  __isset = std::move(other280.__isset);
}
TAnalyticNode& TAnalyticNode::operator=(const TAnalyticNode& other281) {
  partition_exprs = other281.partition_exprs;
  order_by_exprs = other281.order_by_exprs;
  analytic_functions = other281.analytic_functions;
  window = other281.window;
  intermediate_tuple_id = other281.intermediate_tuple_id;
  output_tuple_id = other281.output_tuple_id;
  buffered_tuple_id = other281.buffered_tuple_id;
  partition_by_eq = other281.partition_by_eq;
  order_by_eq = other281.order_by_eq;
  __isset = other281.__isset;
  return *this;
}
TAnalyticNode& TAnalyticNode::operator=(TAnalyticNode&& other282) {
  partition_exprs = std::move(other282.partition_exprs);
  order_by_exprs = std::move(other282.order_by_exprs);
  analytic_functions = std::move(other282.analytic_functions);
  window = std::move(other282.window);
  intermediate_tuple_id = std::move(other282.intermediate_tuple_id);
  output_tuple_id = std::move(other282.output_tuple_id);
  buffered_tuple_id = std::move(other282.buffered_tuple_id);
  partition_by_eq = std::move(other282.partition_by_eq);
  order_by_eq = std::move(other282.order_by_eq);
  __isset = std::move(other282.__isset);
  return *this;
}
void TAnalyticNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAnalyticNode(";
  out << "partition_exprs=" << to_string(partition_exprs);
  out << ", " << "order_by_exprs=" << to_string(order_by_exprs);
  out << ", " << "analytic_functions=" << to_string(analytic_functions);
  out << ", " << "window="; (__isset.window ? (out << to_string(window)) : (out << "<null>"));
  out << ", " << "intermediate_tuple_id=" << to_string(intermediate_tuple_id);
  out << ", " << "output_tuple_id=" << to_string(output_tuple_id);
  out << ", " << "buffered_tuple_id="; (__isset.buffered_tuple_id ? (out << to_string(buffered_tuple_id)) : (out << "<null>"));
  out << ", " << "partition_by_eq="; (__isset.partition_by_eq ? (out << to_string(partition_by_eq)) : (out << "<null>"));
  out << ", " << "order_by_eq="; (__isset.order_by_eq ? (out << to_string(order_by_eq)) : (out << "<null>"));
  out << ")";
}


TUnionNode::~TUnionNode() throw() {
}


void TUnionNode::__set_tuple_id(const  ::impala::TTupleId val) {
  this->tuple_id = val;
}

void TUnionNode::__set_result_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val) {
  this->result_expr_lists = val;
}

void TUnionNode::__set_const_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val) {
  this->const_expr_lists = val;
}

void TUnionNode::__set_first_materialized_child_idx(const int64_t val) {
  this->first_materialized_child_idx = val;
}
std::ostream& operator<<(std::ostream& out, const TUnionNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TUnionNode &a, TUnionNode &b) {
  using ::std::swap;
  swap(a.tuple_id, b.tuple_id);
  swap(a.result_expr_lists, b.result_expr_lists);
  swap(a.const_expr_lists, b.const_expr_lists);
  swap(a.first_materialized_child_idx, b.first_materialized_child_idx);
}

TUnionNode::TUnionNode(const TUnionNode& other307) {
  tuple_id = other307.tuple_id;
  result_expr_lists = other307.result_expr_lists;
  const_expr_lists = other307.const_expr_lists;
  first_materialized_child_idx = other307.first_materialized_child_idx;
}
TUnionNode::TUnionNode( TUnionNode&& other308) {
  tuple_id = std::move(other308.tuple_id);
  result_expr_lists = std::move(other308.result_expr_lists);
  const_expr_lists = std::move(other308.const_expr_lists);
  first_materialized_child_idx = std::move(other308.first_materialized_child_idx);
}
TUnionNode& TUnionNode::operator=(const TUnionNode& other309) {
  tuple_id = other309.tuple_id;
  result_expr_lists = other309.result_expr_lists;
  const_expr_lists = other309.const_expr_lists;
  first_materialized_child_idx = other309.first_materialized_child_idx;
  return *this;
}
TUnionNode& TUnionNode::operator=(TUnionNode&& other310) {
  tuple_id = std::move(other310.tuple_id);
  result_expr_lists = std::move(other310.result_expr_lists);
  const_expr_lists = std::move(other310.const_expr_lists);
  first_materialized_child_idx = std::move(other310.first_materialized_child_idx);
  return *this;
}
void TUnionNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUnionNode(";
  out << "tuple_id=" << to_string(tuple_id);
  out << ", " << "result_expr_lists=" << to_string(result_expr_lists);
  out << ", " << "const_expr_lists=" << to_string(const_expr_lists);
  out << ", " << "first_materialized_child_idx=" << to_string(first_materialized_child_idx);
  out << ")";
}


TExchangeNode::~TExchangeNode() throw() {
}


void TExchangeNode::__set_input_row_tuples(const std::vector< ::impala::TTupleId> & val) {
  this->input_row_tuples = val;
}

void TExchangeNode::__set_sort_info(const TSortInfo& val) {
  this->sort_info = val;
__isset.sort_info = true;
}

void TExchangeNode::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}
std::ostream& operator<<(std::ostream& out, const TExchangeNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TExchangeNode &a, TExchangeNode &b) {
  using ::std::swap;
  swap(a.input_row_tuples, b.input_row_tuples);
  swap(a.sort_info, b.sort_info);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

TExchangeNode::TExchangeNode(const TExchangeNode& other317) {
  input_row_tuples = other317.input_row_tuples;
  sort_info = other317.sort_info;
  offset = other317.offset;
  __isset = other317.__isset;
}
TExchangeNode::TExchangeNode( TExchangeNode&& other318) {
  input_row_tuples = std::move(other318.input_row_tuples);
  sort_info = std::move(other318.sort_info);
  offset = std::move(other318.offset);
  __isset = std::move(other318.__isset);
}
TExchangeNode& TExchangeNode::operator=(const TExchangeNode& other319) {
  input_row_tuples = other319.input_row_tuples;
  sort_info = other319.sort_info;
  offset = other319.offset;
  __isset = other319.__isset;
  return *this;
}
TExchangeNode& TExchangeNode::operator=(TExchangeNode&& other320) {
  input_row_tuples = std::move(other320.input_row_tuples);
  sort_info = std::move(other320.sort_info);
  offset = std::move(other320.offset);
  __isset = std::move(other320.__isset);
  return *this;
}
void TExchangeNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExchangeNode(";
  out << "input_row_tuples=" << to_string(input_row_tuples);
  out << ", " << "sort_info="; (__isset.sort_info ? (out << to_string(sort_info)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ")";
}


TUnnestNode::~TUnnestNode() throw() {
}


void TUnnestNode::__set_collection_exprs(const std::vector< ::impala::TExpr> & val) {
  this->collection_exprs = val;
}
std::ostream& operator<<(std::ostream& out, const TUnnestNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TUnnestNode &a, TUnnestNode &b) {
  using ::std::swap;
  swap(a.collection_exprs, b.collection_exprs);
}

TUnnestNode::TUnnestNode(const TUnnestNode& other327) {
  collection_exprs = other327.collection_exprs;
}
TUnnestNode::TUnnestNode( TUnnestNode&& other328) {
  collection_exprs = std::move(other328.collection_exprs);
}
TUnnestNode& TUnnestNode::operator=(const TUnnestNode& other329) {
  collection_exprs = other329.collection_exprs;
  return *this;
}
TUnnestNode& TUnnestNode::operator=(TUnnestNode&& other330) {
  collection_exprs = std::move(other330.collection_exprs);
  return *this;
}
void TUnnestNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUnnestNode(";
  out << "collection_exprs=" << to_string(collection_exprs);
  out << ")";
}


TCardinalityCheckNode::~TCardinalityCheckNode() throw() {
}


void TCardinalityCheckNode::__set_display_statement(const std::string& val) {
  this->display_statement = val;
}
std::ostream& operator<<(std::ostream& out, const TCardinalityCheckNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCardinalityCheckNode &a, TCardinalityCheckNode &b) {
  using ::std::swap;
  swap(a.display_statement, b.display_statement);
}

TCardinalityCheckNode::TCardinalityCheckNode(const TCardinalityCheckNode& other331) {
  display_statement = other331.display_statement;
}
TCardinalityCheckNode::TCardinalityCheckNode( TCardinalityCheckNode&& other332) {
  display_statement = std::move(other332.display_statement);
}
TCardinalityCheckNode& TCardinalityCheckNode::operator=(const TCardinalityCheckNode& other333) {
  display_statement = other333.display_statement;
  return *this;
}
TCardinalityCheckNode& TCardinalityCheckNode::operator=(TCardinalityCheckNode&& other334) {
  display_statement = std::move(other334.display_statement);
  return *this;
}
void TCardinalityCheckNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCardinalityCheckNode(";
  out << "display_statement=" << to_string(display_statement);
  out << ")";
}


TPipelineMembership::~TPipelineMembership() throw() {
}


void TPipelineMembership::__set_pipe_id(const  ::impala::TPlanNodeId val) {
  this->pipe_id = val;
}

void TPipelineMembership::__set_height(const int32_t val) {
  this->height = val;
}

void TPipelineMembership::__set_phase(const TExecNodePhase::type val) {
  this->phase = val;
}
std::ostream& operator<<(std::ostream& out, const TPipelineMembership& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPipelineMembership &a, TPipelineMembership &b) {
  using ::std::swap;
  swap(a.pipe_id, b.pipe_id);
  swap(a.height, b.height);
  swap(a.phase, b.phase);
}

TPipelineMembership::TPipelineMembership(const TPipelineMembership& other336) {
  pipe_id = other336.pipe_id;
  height = other336.height;
  phase = other336.phase;
}
TPipelineMembership::TPipelineMembership( TPipelineMembership&& other337) {
  pipe_id = std::move(other337.pipe_id);
  height = std::move(other337.height);
  phase = std::move(other337.phase);
}
TPipelineMembership& TPipelineMembership::operator=(const TPipelineMembership& other338) {
  pipe_id = other338.pipe_id;
  height = other338.height;
  phase = other338.phase;
  return *this;
}
TPipelineMembership& TPipelineMembership::operator=(TPipelineMembership&& other339) {
  pipe_id = std::move(other339.pipe_id);
  height = std::move(other339.height);
  phase = std::move(other339.phase);
  return *this;
}
void TPipelineMembership::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPipelineMembership(";
  out << "pipe_id=" << to_string(pipe_id);
  out << ", " << "height=" << to_string(height);
  out << ", " << "phase=" << to_string(phase);
  out << ")";
}


TPlanNode::~TPlanNode() throw() {
}


void TPlanNode::__set_node_id(const  ::impala::TPlanNodeId val) {
  this->node_id = val;
}

void TPlanNode::__set_node_type(const TPlanNodeType::type val) {
  this->node_type = val;
}

void TPlanNode::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TPlanNode::__set_limit(const int64_t val) {
  this->limit = val;
}

void TPlanNode::__set_row_tuples(const std::vector< ::impala::TTupleId> & val) {
  this->row_tuples = val;
}

void TPlanNode::__set_nullable_tuples(const std::vector<bool> & val) {
  this->nullable_tuples = val;
}

void TPlanNode::__set_conjuncts(const std::vector< ::impala::TExpr> & val) {
  this->conjuncts = val;
__isset.conjuncts = true;
}

void TPlanNode::__set_disable_codegen(const bool val) {
  this->disable_codegen = val;
}

void TPlanNode::__set_pipelines(const std::vector<TPipelineMembership> & val) {
  this->pipelines = val;
}

void TPlanNode::__set_hdfs_scan_node(const THdfsScanNode& val) {
  this->hdfs_scan_node = val;
__isset.hdfs_scan_node = true;
}

void TPlanNode::__set_hbase_scan_node(const THBaseScanNode& val) {
  this->hbase_scan_node = val;
__isset.hbase_scan_node = true;
}

void TPlanNode::__set_kudu_scan_node(const TKuduScanNode& val) {
  this->kudu_scan_node = val;
__isset.kudu_scan_node = true;
}

void TPlanNode::__set_data_source_node(const TDataSourceScanNode& val) {
  this->data_source_node = val;
__isset.data_source_node = true;
}

void TPlanNode::__set_join_node(const TJoinNode& val) {
  this->join_node = val;
__isset.join_node = true;
}

void TPlanNode::__set_agg_node(const TAggregationNode& val) {
  this->agg_node = val;
__isset.agg_node = true;
}

void TPlanNode::__set_sort_node(const TSortNode& val) {
  this->sort_node = val;
__isset.sort_node = true;
}

void TPlanNode::__set_union_node(const TUnionNode& val) {
  this->union_node = val;
__isset.union_node = true;
}

void TPlanNode::__set_exchange_node(const TExchangeNode& val) {
  this->exchange_node = val;
__isset.exchange_node = true;
}

void TPlanNode::__set_analytic_node(const TAnalyticNode& val) {
  this->analytic_node = val;
__isset.analytic_node = true;
}

void TPlanNode::__set_unnest_node(const TUnnestNode& val) {
  this->unnest_node = val;
__isset.unnest_node = true;
}

void TPlanNode::__set_label(const std::string& val) {
  this->label = val;
__isset.label = true;
}

void TPlanNode::__set_label_detail(const std::string& val) {
  this->label_detail = val;
__isset.label_detail = true;
}

void TPlanNode::__set_estimated_stats(const  ::impala::TExecStats& val) {
  this->estimated_stats = val;
__isset.estimated_stats = true;
}

void TPlanNode::__set_runtime_filters(const std::vector<TRuntimeFilterDesc> & val) {
  this->runtime_filters = val;
__isset.runtime_filters = true;
}

void TPlanNode::__set_resource_profile(const  ::impala::TBackendResourceProfile& val) {
  this->resource_profile = val;
}

void TPlanNode::__set_cardinality_check_node(const TCardinalityCheckNode& val) {
  this->cardinality_check_node = val;
__isset.cardinality_check_node = true;
}
std::ostream& operator<<(std::ostream& out, const TPlanNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPlanNode &a, TPlanNode &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.node_type, b.node_type);
  swap(a.num_children, b.num_children);
  swap(a.limit, b.limit);
  swap(a.row_tuples, b.row_tuples);
  swap(a.nullable_tuples, b.nullable_tuples);
  swap(a.conjuncts, b.conjuncts);
  swap(a.disable_codegen, b.disable_codegen);
  swap(a.pipelines, b.pipelines);
  swap(a.hdfs_scan_node, b.hdfs_scan_node);
  swap(a.hbase_scan_node, b.hbase_scan_node);
  swap(a.kudu_scan_node, b.kudu_scan_node);
  swap(a.data_source_node, b.data_source_node);
  swap(a.join_node, b.join_node);
  swap(a.agg_node, b.agg_node);
  swap(a.sort_node, b.sort_node);
  swap(a.union_node, b.union_node);
  swap(a.exchange_node, b.exchange_node);
  swap(a.analytic_node, b.analytic_node);
  swap(a.unnest_node, b.unnest_node);
  swap(a.label, b.label);
  swap(a.label_detail, b.label_detail);
  swap(a.estimated_stats, b.estimated_stats);
  swap(a.runtime_filters, b.runtime_filters);
  swap(a.resource_profile, b.resource_profile);
  swap(a.cardinality_check_node, b.cardinality_check_node);
  swap(a.__isset, b.__isset);
}

TPlanNode::TPlanNode(const TPlanNode& other371) {
  node_id = other371.node_id;
  node_type = other371.node_type;
  num_children = other371.num_children;
  limit = other371.limit;
  row_tuples = other371.row_tuples;
  nullable_tuples = other371.nullable_tuples;
  conjuncts = other371.conjuncts;
  disable_codegen = other371.disable_codegen;
  pipelines = other371.pipelines;
  hdfs_scan_node = other371.hdfs_scan_node;
  hbase_scan_node = other371.hbase_scan_node;
  kudu_scan_node = other371.kudu_scan_node;
  data_source_node = other371.data_source_node;
  join_node = other371.join_node;
  agg_node = other371.agg_node;
  sort_node = other371.sort_node;
  union_node = other371.union_node;
  exchange_node = other371.exchange_node;
  analytic_node = other371.analytic_node;
  unnest_node = other371.unnest_node;
  label = other371.label;
  label_detail = other371.label_detail;
  estimated_stats = other371.estimated_stats;
  runtime_filters = other371.runtime_filters;
  resource_profile = other371.resource_profile;
  cardinality_check_node = other371.cardinality_check_node;
  __isset = other371.__isset;
}
TPlanNode::TPlanNode( TPlanNode&& other372) {
  node_id = std::move(other372.node_id);
  node_type = std::move(other372.node_type);
  num_children = std::move(other372.num_children);
  limit = std::move(other372.limit);
  row_tuples = std::move(other372.row_tuples);
  nullable_tuples = std::move(other372.nullable_tuples);
  conjuncts = std::move(other372.conjuncts);
  disable_codegen = std::move(other372.disable_codegen);
  pipelines = std::move(other372.pipelines);
  hdfs_scan_node = std::move(other372.hdfs_scan_node);
  hbase_scan_node = std::move(other372.hbase_scan_node);
  kudu_scan_node = std::move(other372.kudu_scan_node);
  data_source_node = std::move(other372.data_source_node);
  join_node = std::move(other372.join_node);
  agg_node = std::move(other372.agg_node);
  sort_node = std::move(other372.sort_node);
  union_node = std::move(other372.union_node);
  exchange_node = std::move(other372.exchange_node);
  analytic_node = std::move(other372.analytic_node);
  unnest_node = std::move(other372.unnest_node);
  label = std::move(other372.label);
  label_detail = std::move(other372.label_detail);
  estimated_stats = std::move(other372.estimated_stats);
  runtime_filters = std::move(other372.runtime_filters);
  resource_profile = std::move(other372.resource_profile);
  cardinality_check_node = std::move(other372.cardinality_check_node);
  __isset = std::move(other372.__isset);
}
TPlanNode& TPlanNode::operator=(const TPlanNode& other373) {
  node_id = other373.node_id;
  node_type = other373.node_type;
  num_children = other373.num_children;
  limit = other373.limit;
  row_tuples = other373.row_tuples;
  nullable_tuples = other373.nullable_tuples;
  conjuncts = other373.conjuncts;
  disable_codegen = other373.disable_codegen;
  pipelines = other373.pipelines;
  hdfs_scan_node = other373.hdfs_scan_node;
  hbase_scan_node = other373.hbase_scan_node;
  kudu_scan_node = other373.kudu_scan_node;
  data_source_node = other373.data_source_node;
  join_node = other373.join_node;
  agg_node = other373.agg_node;
  sort_node = other373.sort_node;
  union_node = other373.union_node;
  exchange_node = other373.exchange_node;
  analytic_node = other373.analytic_node;
  unnest_node = other373.unnest_node;
  label = other373.label;
  label_detail = other373.label_detail;
  estimated_stats = other373.estimated_stats;
  runtime_filters = other373.runtime_filters;
  resource_profile = other373.resource_profile;
  cardinality_check_node = other373.cardinality_check_node;
  __isset = other373.__isset;
  return *this;
}
TPlanNode& TPlanNode::operator=(TPlanNode&& other374) {
  node_id = std::move(other374.node_id);
  node_type = std::move(other374.node_type);
  num_children = std::move(other374.num_children);
  limit = std::move(other374.limit);
  row_tuples = std::move(other374.row_tuples);
  nullable_tuples = std::move(other374.nullable_tuples);
  conjuncts = std::move(other374.conjuncts);
  disable_codegen = std::move(other374.disable_codegen);
  pipelines = std::move(other374.pipelines);
  hdfs_scan_node = std::move(other374.hdfs_scan_node);
  hbase_scan_node = std::move(other374.hbase_scan_node);
  kudu_scan_node = std::move(other374.kudu_scan_node);
  data_source_node = std::move(other374.data_source_node);
  join_node = std::move(other374.join_node);
  agg_node = std::move(other374.agg_node);
  sort_node = std::move(other374.sort_node);
  union_node = std::move(other374.union_node);
  exchange_node = std::move(other374.exchange_node);
  analytic_node = std::move(other374.analytic_node);
  unnest_node = std::move(other374.unnest_node);
  label = std::move(other374.label);
  label_detail = std::move(other374.label_detail);
  estimated_stats = std::move(other374.estimated_stats);
  runtime_filters = std::move(other374.runtime_filters);
  resource_profile = std::move(other374.resource_profile);
  cardinality_check_node = std::move(other374.cardinality_check_node);
  __isset = std::move(other374.__isset);
  return *this;
}
void TPlanNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanNode(";
  out << "node_id=" << to_string(node_id);
  out << ", " << "node_type=" << to_string(node_type);
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "limit=" << to_string(limit);
  out << ", " << "row_tuples=" << to_string(row_tuples);
  out << ", " << "nullable_tuples=" << to_string(nullable_tuples);
  out << ", " << "conjuncts="; (__isset.conjuncts ? (out << to_string(conjuncts)) : (out << "<null>"));
  out << ", " << "disable_codegen=" << to_string(disable_codegen);
  out << ", " << "pipelines=" << to_string(pipelines);
  out << ", " << "hdfs_scan_node="; (__isset.hdfs_scan_node ? (out << to_string(hdfs_scan_node)) : (out << "<null>"));
  out << ", " << "hbase_scan_node="; (__isset.hbase_scan_node ? (out << to_string(hbase_scan_node)) : (out << "<null>"));
  out << ", " << "kudu_scan_node="; (__isset.kudu_scan_node ? (out << to_string(kudu_scan_node)) : (out << "<null>"));
  out << ", " << "data_source_node="; (__isset.data_source_node ? (out << to_string(data_source_node)) : (out << "<null>"));
  out << ", " << "join_node="; (__isset.join_node ? (out << to_string(join_node)) : (out << "<null>"));
  out << ", " << "agg_node="; (__isset.agg_node ? (out << to_string(agg_node)) : (out << "<null>"));
  out << ", " << "sort_node="; (__isset.sort_node ? (out << to_string(sort_node)) : (out << "<null>"));
  out << ", " << "union_node="; (__isset.union_node ? (out << to_string(union_node)) : (out << "<null>"));
  out << ", " << "exchange_node="; (__isset.exchange_node ? (out << to_string(exchange_node)) : (out << "<null>"));
  out << ", " << "analytic_node="; (__isset.analytic_node ? (out << to_string(analytic_node)) : (out << "<null>"));
  out << ", " << "unnest_node="; (__isset.unnest_node ? (out << to_string(unnest_node)) : (out << "<null>"));
  out << ", " << "label="; (__isset.label ? (out << to_string(label)) : (out << "<null>"));
  out << ", " << "label_detail="; (__isset.label_detail ? (out << to_string(label_detail)) : (out << "<null>"));
  out << ", " << "estimated_stats="; (__isset.estimated_stats ? (out << to_string(estimated_stats)) : (out << "<null>"));
  out << ", " << "runtime_filters="; (__isset.runtime_filters ? (out << to_string(runtime_filters)) : (out << "<null>"));
  out << ", " << "resource_profile=" << to_string(resource_profile);
  out << ", " << "cardinality_check_node="; (__isset.cardinality_check_node ? (out << to_string(cardinality_check_node)) : (out << "<null>"));
  out << ")";
}


TPlan::~TPlan() throw() {
}


void TPlan::__set_nodes(const std::vector<TPlanNode> & val) {
  this->nodes = val;
}
std::ostream& operator<<(std::ostream& out, const TPlan& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPlan &a, TPlan &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

TPlan::TPlan(const TPlan& other381) {
  nodes = other381.nodes;
}
TPlan::TPlan( TPlan&& other382) {
  nodes = std::move(other382.nodes);
}
TPlan& TPlan::operator=(const TPlan& other383) {
  nodes = other383.nodes;
  return *this;
}
TPlan& TPlan::operator=(TPlan&& other384) {
  nodes = std::move(other384.nodes);
  return *this;
}
void TPlan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlan(";
  out << "nodes=" << to_string(nodes);
  out << ")";
}

} // namespace
