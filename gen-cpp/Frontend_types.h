/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Frontend_TYPES_H
#define Frontend_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "Types_types.h"
#include "RuntimeProfile_types.h"
#include "Descriptors_types.h"
#include "Data_types.h"
#include "Results_types.h"
#include "TCLIService_types.h"
#include "Status_types.h"
#include "CatalogObjects_types.h"
#include "CatalogService_types.h"
#include "LineageGraph_types.h"
#include "Query_types.h"


namespace impala {

struct TDescribeOutputStyle {
  enum type {
    MINIMAL = 0,
    EXTENDED = 1,
    FORMATTED = 2
  };
};

extern const std::map<int, const char*> _TDescribeOutputStyle_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TDescribeOutputStyle::type& val);

struct TShowStatsOp {
  enum type {
    TABLE_STATS = 0,
    COLUMN_STATS = 1,
    PARTITIONS = 2,
    RANGE_PARTITIONS = 3
  };
};

extern const std::map<int, const char*> _TShowStatsOp_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TShowStatsOp::type& val);

struct TCatalogOpType {
  enum type {
    SHOW_TABLES = 0,
    SHOW_DBS = 1,
    SHOW_STATS = 2,
    USE = 3,
    DESCRIBE_TABLE = 4,
    DESCRIBE_DB = 5,
    SHOW_FUNCTIONS = 6,
    RESET_METADATA = 7,
    DDL = 8,
    SHOW_CREATE_TABLE = 9,
    SHOW_DATA_SRCS = 10,
    SHOW_ROLES = 11,
    SHOW_GRANT_PRINCIPAL = 12,
    SHOW_FILES = 13,
    SHOW_CREATE_FUNCTION = 14,
    DESCRIBE_HISTORY = 15
  };
};

extern const std::map<int, const char*> _TCatalogOpType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TCatalogOpType::type& val);

struct TAdminRequestType {
  enum type {
    SHUTDOWN = 0
  };
};

extern const std::map<int, const char*> _TAdminRequestType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAdminRequestType::type& val);

struct TMetadataOpcode {
  enum type {
    GET_TYPE_INFO = 0,
    GET_CATALOGS = 1,
    GET_SCHEMAS = 2,
    GET_TABLES = 3,
    GET_TABLE_TYPES = 4,
    GET_COLUMNS = 5,
    GET_FUNCTIONS = 6,
    GET_PRIMARY_KEYS = 7,
    GET_CROSS_REFERENCE = 8
  };
};

extern const std::map<int, const char*> _TMetadataOpcode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TMetadataOpcode::type& val);

struct TSymbolType {
  enum type {
    UDF_EVALUATE = 0,
    UDF_PREPARE = 1,
    UDF_CLOSE = 2
  };
};

extern const std::map<int, const char*> _TSymbolType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSymbolType::type& val);

struct TSymbolLookupResultCode {
  enum type {
    SYMBOL_FOUND = 0,
    BINARY_NOT_FOUND = 1,
    SYMBOL_NOT_FOUND = 2
  };
};

extern const std::map<int, const char*> _TSymbolLookupResultCode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSymbolLookupResultCode::type& val);

class THiveUdfExecutorCtorParams;

class TGetTablesParams;

class TGetTablesResult;

class TGetTableMetricsParams;

class TGetTableMetricsResponse;

class TGetCatalogMetricsResult;

class TGetDbsParams;

class TGetDbsResult;

class TGetDataSrcsParams;

class TGetDataSrcsResult;

class TDescribeDbParams;

class TDescribeTableParams;

class TDescribeResult;

class TShowDataSrcsParams;

class TShowDbsParams;

class TShowStatsParams;

class TDescribeHistoryParams;

class TShowFunctionsParams;

class TShowTablesParams;

class TShowFilesParams;

class TShowRolesParams;

class TShowRolesResult;

class TGetTableHistoryResultItem;

class TGetTableHistoryResult;

class TShowGrantPrincipalParams;

class TGetFunctionsParams;

class TGetFunctionsResult;

class TUseDbParams;

class TExplainResult;

class TLoadDataReq;

class TLoadDataResp;

class TCatalogOpRequest;

class TSetQueryOptionRequest;

class TShutdownParams;

class TAdminRequest;

class TMetadataOpRequest;

class TAccessEvent;

class TExecRequest;

class TCacheJarParams;

class TCacheJarResult;

class TSymbolLookupParams;

class TSymbolLookupResult;

class TUpdateCatalogCacheRequest;

class TUpdateCatalogCacheResponse;

class TUpdateExecutorMembershipRequest;

class TJvmMemoryPool;

class TGetJvmMemoryMetricsResponse;

class TJvmThreadInfo;

class TGetJvmThreadsInfoRequest;

class TGetJvmThreadsInfoResponse;

class TGetJMXJsonResponse;

class TGetHadoopConfigRequest;

class TGetHadoopConfigResponse;

class TGetAllHadoopConfigsResponse;

class TGetHadoopGroupsRequest;

class TGetHadoopGroupsResponse;

class TBuildTestDescriptorTableParams;

class TTestCaseData;

class TQueryCompleteContext;

class TWrappedHttpRequest;

class TWrappedHttpResponse;


class THiveUdfExecutorCtorParams {
 public:

  THiveUdfExecutorCtorParams(const THiveUdfExecutorCtorParams&);
  THiveUdfExecutorCtorParams(THiveUdfExecutorCtorParams&&);
  THiveUdfExecutorCtorParams& operator=(const THiveUdfExecutorCtorParams&);
  THiveUdfExecutorCtorParams& operator=(THiveUdfExecutorCtorParams&&);
  THiveUdfExecutorCtorParams() : local_location(), input_nulls_ptr(0), input_buffer_ptr(0), output_null_ptr(0), output_buffer_ptr(0) {
  }

  virtual ~THiveUdfExecutorCtorParams() throw();
   ::impala::TFunction fn;
  std::string local_location;
  std::vector<int32_t>  input_byte_offsets;
  int64_t input_nulls_ptr;
  int64_t input_buffer_ptr;
  int64_t output_null_ptr;
  int64_t output_buffer_ptr;

  void __set_fn(const  ::impala::TFunction& val);

  void __set_local_location(const std::string& val);

  void __set_input_byte_offsets(const std::vector<int32_t> & val);

  void __set_input_nulls_ptr(const int64_t val);

  void __set_input_buffer_ptr(const int64_t val);

  void __set_output_null_ptr(const int64_t val);

  void __set_output_buffer_ptr(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THiveUdfExecutorCtorParams &a, THiveUdfExecutorCtorParams &b);

std::ostream& operator<<(std::ostream& out, const THiveUdfExecutorCtorParams& obj);

typedef struct _TGetTablesParams__isset {
  _TGetTablesParams__isset() : db(false), pattern(false), session(false) {}
  bool db :1;
  bool pattern :1;
  bool session :1;
} _TGetTablesParams__isset;

class TGetTablesParams {
 public:

  TGetTablesParams(const TGetTablesParams&);
  TGetTablesParams(TGetTablesParams&&);
  TGetTablesParams& operator=(const TGetTablesParams&);
  TGetTablesParams& operator=(TGetTablesParams&&);
  TGetTablesParams() : db(), pattern() {
  }

  virtual ~TGetTablesParams() throw();
  std::string db;
  std::string pattern;
   ::impala::TSessionState session;

  _TGetTablesParams__isset __isset;

  void __set_db(const std::string& val);

  void __set_pattern(const std::string& val);

  void __set_session(const  ::impala::TSessionState& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTablesParams &a, TGetTablesParams &b);

std::ostream& operator<<(std::ostream& out, const TGetTablesParams& obj);

typedef struct _TGetTablesResult__isset {
  _TGetTablesResult__isset() : tables(false) {}
  bool tables :1;
} _TGetTablesResult__isset;

class TGetTablesResult {
 public:

  TGetTablesResult(const TGetTablesResult&);
  TGetTablesResult(TGetTablesResult&&);
  TGetTablesResult& operator=(const TGetTablesResult&);
  TGetTablesResult& operator=(TGetTablesResult&&);
  TGetTablesResult() {
  }

  virtual ~TGetTablesResult() throw();
  std::vector<std::string>  tables;

  _TGetTablesResult__isset __isset;

  void __set_tables(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTablesResult &a, TGetTablesResult &b);

std::ostream& operator<<(std::ostream& out, const TGetTablesResult& obj);


class TGetTableMetricsParams {
 public:

  TGetTableMetricsParams(const TGetTableMetricsParams&);
  TGetTableMetricsParams(TGetTableMetricsParams&&);
  TGetTableMetricsParams& operator=(const TGetTableMetricsParams&);
  TGetTableMetricsParams& operator=(TGetTableMetricsParams&&);
  TGetTableMetricsParams() {
  }

  virtual ~TGetTableMetricsParams() throw();
   ::impala::TTableName table_name;

  void __set_table_name(const  ::impala::TTableName& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTableMetricsParams &a, TGetTableMetricsParams &b);

std::ostream& operator<<(std::ostream& out, const TGetTableMetricsParams& obj);


class TGetTableMetricsResponse {
 public:

  TGetTableMetricsResponse(const TGetTableMetricsResponse&);
  TGetTableMetricsResponse(TGetTableMetricsResponse&&);
  TGetTableMetricsResponse& operator=(const TGetTableMetricsResponse&);
  TGetTableMetricsResponse& operator=(TGetTableMetricsResponse&&);
  TGetTableMetricsResponse() : metrics() {
  }

  virtual ~TGetTableMetricsResponse() throw();
  std::string metrics;

  void __set_metrics(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTableMetricsResponse &a, TGetTableMetricsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetTableMetricsResponse& obj);

typedef struct _TGetCatalogMetricsResult__isset {
  _TGetCatalogMetricsResult__isset() : cache_eviction_count(false), cache_hit_count(false), cache_load_count(false), cache_load_exception_count(false), cache_load_success_count(false), cache_miss_count(false), cache_request_count(false), cache_total_load_time(false), cache_avg_load_time(false), cache_hit_rate(false), cache_load_exception_rate(false), cache_miss_rate(false) {}
  bool cache_eviction_count :1;
  bool cache_hit_count :1;
  bool cache_load_count :1;
  bool cache_load_exception_count :1;
  bool cache_load_success_count :1;
  bool cache_miss_count :1;
  bool cache_request_count :1;
  bool cache_total_load_time :1;
  bool cache_avg_load_time :1;
  bool cache_hit_rate :1;
  bool cache_load_exception_rate :1;
  bool cache_miss_rate :1;
} _TGetCatalogMetricsResult__isset;

class TGetCatalogMetricsResult {
 public:

  TGetCatalogMetricsResult(const TGetCatalogMetricsResult&);
  TGetCatalogMetricsResult(TGetCatalogMetricsResult&&);
  TGetCatalogMetricsResult& operator=(const TGetCatalogMetricsResult&);
  TGetCatalogMetricsResult& operator=(TGetCatalogMetricsResult&&);
  TGetCatalogMetricsResult() : num_dbs(0), num_tables(0), cache_eviction_count(0), cache_hit_count(0), cache_load_count(0), cache_load_exception_count(0), cache_load_success_count(0), cache_miss_count(0), cache_request_count(0), cache_total_load_time(0), cache_avg_load_time(0), cache_hit_rate(0), cache_load_exception_rate(0), cache_miss_rate(0) {
  }

  virtual ~TGetCatalogMetricsResult() throw();
  int32_t num_dbs;
  int32_t num_tables;
  int64_t cache_eviction_count;
  int64_t cache_hit_count;
  int64_t cache_load_count;
  int64_t cache_load_exception_count;
  int64_t cache_load_success_count;
  int64_t cache_miss_count;
  int64_t cache_request_count;
  int64_t cache_total_load_time;
  double cache_avg_load_time;
  double cache_hit_rate;
  double cache_load_exception_rate;
  double cache_miss_rate;

  _TGetCatalogMetricsResult__isset __isset;

  void __set_num_dbs(const int32_t val);

  void __set_num_tables(const int32_t val);

  void __set_cache_eviction_count(const int64_t val);

  void __set_cache_hit_count(const int64_t val);

  void __set_cache_load_count(const int64_t val);

  void __set_cache_load_exception_count(const int64_t val);

  void __set_cache_load_success_count(const int64_t val);

  void __set_cache_miss_count(const int64_t val);

  void __set_cache_request_count(const int64_t val);

  void __set_cache_total_load_time(const int64_t val);

  void __set_cache_avg_load_time(const double val);

  void __set_cache_hit_rate(const double val);

  void __set_cache_load_exception_rate(const double val);

  void __set_cache_miss_rate(const double val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogMetricsResult &a, TGetCatalogMetricsResult &b);

std::ostream& operator<<(std::ostream& out, const TGetCatalogMetricsResult& obj);

typedef struct _TGetDbsParams__isset {
  _TGetDbsParams__isset() : pattern(false), session(false) {}
  bool pattern :1;
  bool session :1;
} _TGetDbsParams__isset;

class TGetDbsParams {
 public:

  TGetDbsParams(const TGetDbsParams&);
  TGetDbsParams(TGetDbsParams&&);
  TGetDbsParams& operator=(const TGetDbsParams&);
  TGetDbsParams& operator=(TGetDbsParams&&);
  TGetDbsParams() : pattern() {
  }

  virtual ~TGetDbsParams() throw();
  std::string pattern;
   ::impala::TSessionState session;

  _TGetDbsParams__isset __isset;

  void __set_pattern(const std::string& val);

  void __set_session(const  ::impala::TSessionState& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetDbsParams &a, TGetDbsParams &b);

std::ostream& operator<<(std::ostream& out, const TGetDbsParams& obj);

typedef struct _TGetDbsResult__isset {
  _TGetDbsResult__isset() : dbs(false) {}
  bool dbs :1;
} _TGetDbsResult__isset;

class TGetDbsResult {
 public:

  TGetDbsResult(const TGetDbsResult&);
  TGetDbsResult(TGetDbsResult&&);
  TGetDbsResult& operator=(const TGetDbsResult&);
  TGetDbsResult& operator=(TGetDbsResult&&);
  TGetDbsResult() {
  }

  virtual ~TGetDbsResult() throw();
  std::vector< ::impala::TDatabase>  dbs;

  _TGetDbsResult__isset __isset;

  void __set_dbs(const std::vector< ::impala::TDatabase> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetDbsResult &a, TGetDbsResult &b);

std::ostream& operator<<(std::ostream& out, const TGetDbsResult& obj);

typedef struct _TGetDataSrcsParams__isset {
  _TGetDataSrcsParams__isset() : pattern(false) {}
  bool pattern :1;
} _TGetDataSrcsParams__isset;

class TGetDataSrcsParams {
 public:

  TGetDataSrcsParams(const TGetDataSrcsParams&);
  TGetDataSrcsParams(TGetDataSrcsParams&&);
  TGetDataSrcsParams& operator=(const TGetDataSrcsParams&);
  TGetDataSrcsParams& operator=(TGetDataSrcsParams&&);
  TGetDataSrcsParams() : pattern() {
  }

  virtual ~TGetDataSrcsParams() throw();
  std::string pattern;

  _TGetDataSrcsParams__isset __isset;

  void __set_pattern(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetDataSrcsParams &a, TGetDataSrcsParams &b);

std::ostream& operator<<(std::ostream& out, const TGetDataSrcsParams& obj);


class TGetDataSrcsResult {
 public:

  TGetDataSrcsResult(const TGetDataSrcsResult&);
  TGetDataSrcsResult(TGetDataSrcsResult&&);
  TGetDataSrcsResult& operator=(const TGetDataSrcsResult&);
  TGetDataSrcsResult& operator=(TGetDataSrcsResult&&);
  TGetDataSrcsResult() {
  }

  virtual ~TGetDataSrcsResult() throw();
  std::vector<std::string>  data_src_names;
  std::vector<std::string>  locations;
  std::vector<std::string>  class_names;
  std::vector<std::string>  api_versions;

  void __set_data_src_names(const std::vector<std::string> & val);

  void __set_locations(const std::vector<std::string> & val);

  void __set_class_names(const std::vector<std::string> & val);

  void __set_api_versions(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetDataSrcsResult &a, TGetDataSrcsResult &b);

std::ostream& operator<<(std::ostream& out, const TGetDataSrcsResult& obj);


class TDescribeDbParams {
 public:

  TDescribeDbParams(const TDescribeDbParams&);
  TDescribeDbParams(TDescribeDbParams&&);
  TDescribeDbParams& operator=(const TDescribeDbParams&);
  TDescribeDbParams& operator=(TDescribeDbParams&&);
  TDescribeDbParams() : db(), output_style((TDescribeOutputStyle::type)0) {
  }

  virtual ~TDescribeDbParams() throw();
  std::string db;
  TDescribeOutputStyle::type output_style;

  void __set_db(const std::string& val);

  void __set_output_style(const TDescribeOutputStyle::type val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescribeDbParams &a, TDescribeDbParams &b);

std::ostream& operator<<(std::ostream& out, const TDescribeDbParams& obj);

typedef struct _TDescribeTableParams__isset {
  _TDescribeTableParams__isset() : table_name(false), result_struct(false), session(false) {}
  bool table_name :1;
  bool result_struct :1;
  bool session :1;
} _TDescribeTableParams__isset;

class TDescribeTableParams {
 public:

  TDescribeTableParams(const TDescribeTableParams&);
  TDescribeTableParams(TDescribeTableParams&&);
  TDescribeTableParams& operator=(const TDescribeTableParams&);
  TDescribeTableParams& operator=(TDescribeTableParams&&);
  TDescribeTableParams() : output_style((TDescribeOutputStyle::type)0) {
  }

  virtual ~TDescribeTableParams() throw();
  TDescribeOutputStyle::type output_style;
   ::impala::TTableName table_name;
   ::impala::TColumnType result_struct;
   ::impala::TSessionState session;

  _TDescribeTableParams__isset __isset;

  void __set_output_style(const TDescribeOutputStyle::type val);

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_result_struct(const  ::impala::TColumnType& val);

  void __set_session(const  ::impala::TSessionState& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescribeTableParams &a, TDescribeTableParams &b);

std::ostream& operator<<(std::ostream& out, const TDescribeTableParams& obj);


class TDescribeResult {
 public:

  TDescribeResult(const TDescribeResult&);
  TDescribeResult(TDescribeResult&&);
  TDescribeResult& operator=(const TDescribeResult&);
  TDescribeResult& operator=(TDescribeResult&&);
  TDescribeResult() {
  }

  virtual ~TDescribeResult() throw();
  std::vector< ::impala::TResultRow>  results;

  void __set_results(const std::vector< ::impala::TResultRow> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescribeResult &a, TDescribeResult &b);

std::ostream& operator<<(std::ostream& out, const TDescribeResult& obj);

typedef struct _TShowDataSrcsParams__isset {
  _TShowDataSrcsParams__isset() : show_pattern(false) {}
  bool show_pattern :1;
} _TShowDataSrcsParams__isset;

class TShowDataSrcsParams {
 public:

  TShowDataSrcsParams(const TShowDataSrcsParams&);
  TShowDataSrcsParams(TShowDataSrcsParams&&);
  TShowDataSrcsParams& operator=(const TShowDataSrcsParams&);
  TShowDataSrcsParams& operator=(TShowDataSrcsParams&&);
  TShowDataSrcsParams() : show_pattern() {
  }

  virtual ~TShowDataSrcsParams() throw();
  std::string show_pattern;

  _TShowDataSrcsParams__isset __isset;

  void __set_show_pattern(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowDataSrcsParams &a, TShowDataSrcsParams &b);

std::ostream& operator<<(std::ostream& out, const TShowDataSrcsParams& obj);

typedef struct _TShowDbsParams__isset {
  _TShowDbsParams__isset() : show_pattern(false) {}
  bool show_pattern :1;
} _TShowDbsParams__isset;

class TShowDbsParams {
 public:

  TShowDbsParams(const TShowDbsParams&);
  TShowDbsParams(TShowDbsParams&&);
  TShowDbsParams& operator=(const TShowDbsParams&);
  TShowDbsParams& operator=(TShowDbsParams&&);
  TShowDbsParams() : show_pattern() {
  }

  virtual ~TShowDbsParams() throw();
  std::string show_pattern;

  _TShowDbsParams__isset __isset;

  void __set_show_pattern(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowDbsParams &a, TShowDbsParams &b);

std::ostream& operator<<(std::ostream& out, const TShowDbsParams& obj);

typedef struct _TShowStatsParams__isset {
  _TShowStatsParams__isset() : op(false), table_name(false), show_column_minmax_stats(false) {}
  bool op :1;
  bool table_name :1;
  bool show_column_minmax_stats :1;
} _TShowStatsParams__isset;

class TShowStatsParams {
 public:

  TShowStatsParams(const TShowStatsParams&);
  TShowStatsParams(TShowStatsParams&&);
  TShowStatsParams& operator=(const TShowStatsParams&);
  TShowStatsParams& operator=(TShowStatsParams&&);
  TShowStatsParams() : op((TShowStatsOp::type)0), show_column_minmax_stats(0) {
  }

  virtual ~TShowStatsParams() throw();
  TShowStatsOp::type op;
   ::impala::TTableName table_name;
  bool show_column_minmax_stats;

  _TShowStatsParams__isset __isset;

  void __set_op(const TShowStatsOp::type val);

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_show_column_minmax_stats(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowStatsParams &a, TShowStatsParams &b);

std::ostream& operator<<(std::ostream& out, const TShowStatsParams& obj);

typedef struct _TDescribeHistoryParams__isset {
  _TDescribeHistoryParams__isset() : table_name(false) {}
  bool table_name :1;
} _TDescribeHistoryParams__isset;

class TDescribeHistoryParams {
 public:

  TDescribeHistoryParams(const TDescribeHistoryParams&);
  TDescribeHistoryParams(TDescribeHistoryParams&&);
  TDescribeHistoryParams& operator=(const TDescribeHistoryParams&);
  TDescribeHistoryParams& operator=(TDescribeHistoryParams&&);
  TDescribeHistoryParams() {
  }

  virtual ~TDescribeHistoryParams() throw();
   ::impala::TTableName table_name;

  _TDescribeHistoryParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDescribeHistoryParams &a, TDescribeHistoryParams &b);

std::ostream& operator<<(std::ostream& out, const TDescribeHistoryParams& obj);

typedef struct _TShowFunctionsParams__isset {
  _TShowFunctionsParams__isset() : category(false), db(false), show_pattern(false) {}
  bool category :1;
  bool db :1;
  bool show_pattern :1;
} _TShowFunctionsParams__isset;

class TShowFunctionsParams {
 public:

  TShowFunctionsParams(const TShowFunctionsParams&);
  TShowFunctionsParams(TShowFunctionsParams&&);
  TShowFunctionsParams& operator=(const TShowFunctionsParams&);
  TShowFunctionsParams& operator=(TShowFunctionsParams&&);
  TShowFunctionsParams() : category(( ::impala::TFunctionCategory::type)0), db(), show_pattern() {
  }

  virtual ~TShowFunctionsParams() throw();
   ::impala::TFunctionCategory::type category;
  std::string db;
  std::string show_pattern;

  _TShowFunctionsParams__isset __isset;

  void __set_category(const  ::impala::TFunctionCategory::type val);

  void __set_db(const std::string& val);

  void __set_show_pattern(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowFunctionsParams &a, TShowFunctionsParams &b);

std::ostream& operator<<(std::ostream& out, const TShowFunctionsParams& obj);

typedef struct _TShowTablesParams__isset {
  _TShowTablesParams__isset() : db(false), show_pattern(false) {}
  bool db :1;
  bool show_pattern :1;
} _TShowTablesParams__isset;

class TShowTablesParams {
 public:

  TShowTablesParams(const TShowTablesParams&);
  TShowTablesParams(TShowTablesParams&&);
  TShowTablesParams& operator=(const TShowTablesParams&);
  TShowTablesParams& operator=(TShowTablesParams&&);
  TShowTablesParams() : db(), show_pattern() {
  }

  virtual ~TShowTablesParams() throw();
  std::string db;
  std::string show_pattern;

  _TShowTablesParams__isset __isset;

  void __set_db(const std::string& val);

  void __set_show_pattern(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowTablesParams &a, TShowTablesParams &b);

std::ostream& operator<<(std::ostream& out, const TShowTablesParams& obj);

typedef struct _TShowFilesParams__isset {
  _TShowFilesParams__isset() : partition_set(false) {}
  bool partition_set :1;
} _TShowFilesParams__isset;

class TShowFilesParams {
 public:

  TShowFilesParams(const TShowFilesParams&);
  TShowFilesParams(TShowFilesParams&&);
  TShowFilesParams& operator=(const TShowFilesParams&);
  TShowFilesParams& operator=(TShowFilesParams&&);
  TShowFilesParams() {
  }

  virtual ~TShowFilesParams() throw();
   ::impala::TTableName table_name;
  std::vector<std::vector< ::impala::TPartitionKeyValue> >  partition_set;

  _TShowFilesParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_partition_set(const std::vector<std::vector< ::impala::TPartitionKeyValue> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowFilesParams &a, TShowFilesParams &b);

std::ostream& operator<<(std::ostream& out, const TShowFilesParams& obj);

typedef struct _TShowRolesParams__isset {
  _TShowRolesParams__isset() : requesting_user(false), grant_group(false) {}
  bool requesting_user :1;
  bool grant_group :1;
} _TShowRolesParams__isset;

class TShowRolesParams {
 public:

  TShowRolesParams(const TShowRolesParams&);
  TShowRolesParams(TShowRolesParams&&);
  TShowRolesParams& operator=(const TShowRolesParams&);
  TShowRolesParams& operator=(TShowRolesParams&&);
  TShowRolesParams() : requesting_user(), is_show_current_roles(0), grant_group() {
  }

  virtual ~TShowRolesParams() throw();
  std::string requesting_user;
  bool is_show_current_roles;
  std::string grant_group;

  _TShowRolesParams__isset __isset;

  void __set_requesting_user(const std::string& val);

  void __set_is_show_current_roles(const bool val);

  void __set_grant_group(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowRolesParams &a, TShowRolesParams &b);

std::ostream& operator<<(std::ostream& out, const TShowRolesParams& obj);


class TShowRolesResult {
 public:

  TShowRolesResult(const TShowRolesResult&);
  TShowRolesResult(TShowRolesResult&&);
  TShowRolesResult& operator=(const TShowRolesResult&);
  TShowRolesResult& operator=(TShowRolesResult&&);
  TShowRolesResult() {
  }

  virtual ~TShowRolesResult() throw();
  std::vector<std::string>  role_names;

  void __set_role_names(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowRolesResult &a, TShowRolesResult &b);

std::ostream& operator<<(std::ostream& out, const TShowRolesResult& obj);

typedef struct _TGetTableHistoryResultItem__isset {
  _TGetTableHistoryResultItem__isset() : parent_id(false) {}
  bool parent_id :1;
} _TGetTableHistoryResultItem__isset;

class TGetTableHistoryResultItem {
 public:

  TGetTableHistoryResultItem(const TGetTableHistoryResultItem&);
  TGetTableHistoryResultItem(TGetTableHistoryResultItem&&);
  TGetTableHistoryResultItem& operator=(const TGetTableHistoryResultItem&);
  TGetTableHistoryResultItem& operator=(TGetTableHistoryResultItem&&);
  TGetTableHistoryResultItem() : creation_time(0), snapshot_id(0), parent_id(0), is_current_ancestor(0) {
  }

  virtual ~TGetTableHistoryResultItem() throw();
  int64_t creation_time;
  int64_t snapshot_id;
  int64_t parent_id;
  bool is_current_ancestor;

  _TGetTableHistoryResultItem__isset __isset;

  void __set_creation_time(const int64_t val);

  void __set_snapshot_id(const int64_t val);

  void __set_parent_id(const int64_t val);

  void __set_is_current_ancestor(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTableHistoryResultItem &a, TGetTableHistoryResultItem &b);

std::ostream& operator<<(std::ostream& out, const TGetTableHistoryResultItem& obj);


class TGetTableHistoryResult {
 public:

  TGetTableHistoryResult(const TGetTableHistoryResult&);
  TGetTableHistoryResult(TGetTableHistoryResult&&);
  TGetTableHistoryResult& operator=(const TGetTableHistoryResult&);
  TGetTableHistoryResult& operator=(TGetTableHistoryResult&&);
  TGetTableHistoryResult() {
  }

  virtual ~TGetTableHistoryResult() throw();
  std::vector<TGetTableHistoryResultItem>  result;

  void __set_result(const std::vector<TGetTableHistoryResultItem> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetTableHistoryResult &a, TGetTableHistoryResult &b);

std::ostream& operator<<(std::ostream& out, const TGetTableHistoryResult& obj);

typedef struct _TShowGrantPrincipalParams__isset {
  _TShowGrantPrincipalParams__isset() : requesting_user(false), privilege(false) {}
  bool requesting_user :1;
  bool privilege :1;
} _TShowGrantPrincipalParams__isset;

class TShowGrantPrincipalParams {
 public:

  TShowGrantPrincipalParams(const TShowGrantPrincipalParams&);
  TShowGrantPrincipalParams(TShowGrantPrincipalParams&&);
  TShowGrantPrincipalParams& operator=(const TShowGrantPrincipalParams&);
  TShowGrantPrincipalParams& operator=(TShowGrantPrincipalParams&&);
  TShowGrantPrincipalParams() : requesting_user(), name(), principal_type(( ::impala::TPrincipalType::type)0) {
  }

  virtual ~TShowGrantPrincipalParams() throw();
  std::string requesting_user;
  std::string name;
   ::impala::TPrincipalType::type principal_type;
   ::impala::TPrivilege privilege;

  _TShowGrantPrincipalParams__isset __isset;

  void __set_requesting_user(const std::string& val);

  void __set_name(const std::string& val);

  void __set_principal_type(const  ::impala::TPrincipalType::type val);

  void __set_privilege(const  ::impala::TPrivilege& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShowGrantPrincipalParams &a, TShowGrantPrincipalParams &b);

std::ostream& operator<<(std::ostream& out, const TShowGrantPrincipalParams& obj);

typedef struct _TGetFunctionsParams__isset {
  _TGetFunctionsParams__isset() : db(false), pattern(false), session(false) {}
  bool db :1;
  bool pattern :1;
  bool session :1;
} _TGetFunctionsParams__isset;

class TGetFunctionsParams {
 public:

  TGetFunctionsParams(const TGetFunctionsParams&);
  TGetFunctionsParams(TGetFunctionsParams&&);
  TGetFunctionsParams& operator=(const TGetFunctionsParams&);
  TGetFunctionsParams& operator=(TGetFunctionsParams&&);
  TGetFunctionsParams() : category(( ::impala::TFunctionCategory::type)0), db(), pattern() {
  }

  virtual ~TGetFunctionsParams() throw();
   ::impala::TFunctionCategory::type category;
  std::string db;
  std::string pattern;
   ::impala::TSessionState session;

  _TGetFunctionsParams__isset __isset;

  void __set_category(const  ::impala::TFunctionCategory::type val);

  void __set_db(const std::string& val);

  void __set_pattern(const std::string& val);

  void __set_session(const  ::impala::TSessionState& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetFunctionsParams &a, TGetFunctionsParams &b);

std::ostream& operator<<(std::ostream& out, const TGetFunctionsParams& obj);

typedef struct _TGetFunctionsResult__isset {
  _TGetFunctionsResult__isset() : fn_signatures(false), fn_ret_types(false), fn_binary_types(false), fn_persistence(false) {}
  bool fn_signatures :1;
  bool fn_ret_types :1;
  bool fn_binary_types :1;
  bool fn_persistence :1;
} _TGetFunctionsResult__isset;

class TGetFunctionsResult {
 public:

  TGetFunctionsResult(const TGetFunctionsResult&);
  TGetFunctionsResult(TGetFunctionsResult&&);
  TGetFunctionsResult& operator=(const TGetFunctionsResult&);
  TGetFunctionsResult& operator=(TGetFunctionsResult&&);
  TGetFunctionsResult() {
  }

  virtual ~TGetFunctionsResult() throw();
  std::vector<std::string>  fn_signatures;
  std::vector<std::string>  fn_ret_types;
  std::vector<std::string>  fn_binary_types;
  std::vector<std::string>  fn_persistence;

  _TGetFunctionsResult__isset __isset;

  void __set_fn_signatures(const std::vector<std::string> & val);

  void __set_fn_ret_types(const std::vector<std::string> & val);

  void __set_fn_binary_types(const std::vector<std::string> & val);

  void __set_fn_persistence(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetFunctionsResult &a, TGetFunctionsResult &b);

std::ostream& operator<<(std::ostream& out, const TGetFunctionsResult& obj);


class TUseDbParams {
 public:

  TUseDbParams(const TUseDbParams&);
  TUseDbParams(TUseDbParams&&);
  TUseDbParams& operator=(const TUseDbParams&);
  TUseDbParams& operator=(TUseDbParams&&);
  TUseDbParams() : db() {
  }

  virtual ~TUseDbParams() throw();
  std::string db;

  void __set_db(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUseDbParams &a, TUseDbParams &b);

std::ostream& operator<<(std::ostream& out, const TUseDbParams& obj);


class TExplainResult {
 public:

  TExplainResult(const TExplainResult&);
  TExplainResult(TExplainResult&&);
  TExplainResult& operator=(const TExplainResult&);
  TExplainResult& operator=(TExplainResult&&);
  TExplainResult() {
  }

  virtual ~TExplainResult() throw();
  std::vector< ::impala::TResultRow>  results;

  void __set_results(const std::vector< ::impala::TResultRow> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExplainResult &a, TExplainResult &b);

std::ostream& operator<<(std::ostream& out, const TExplainResult& obj);

typedef struct _TLoadDataReq__isset {
  _TLoadDataReq__isset() : partition_spec(false) {}
  bool partition_spec :1;
} _TLoadDataReq__isset;

class TLoadDataReq {
 public:

  TLoadDataReq(const TLoadDataReq&);
  TLoadDataReq(TLoadDataReq&&);
  TLoadDataReq& operator=(const TLoadDataReq&);
  TLoadDataReq& operator=(TLoadDataReq&&);
  TLoadDataReq() : source_path(), overwrite(0) {
  }

  virtual ~TLoadDataReq() throw();
   ::impala::TTableName table_name;
  std::string source_path;
  bool overwrite;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TLoadDataReq__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_source_path(const std::string& val);

  void __set_overwrite(const bool val);

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLoadDataReq &a, TLoadDataReq &b);

std::ostream& operator<<(std::ostream& out, const TLoadDataReq& obj);


class TLoadDataResp {
 public:

  TLoadDataResp(const TLoadDataResp&);
  TLoadDataResp(TLoadDataResp&&);
  TLoadDataResp& operator=(const TLoadDataResp&);
  TLoadDataResp& operator=(TLoadDataResp&&);
  TLoadDataResp() {
  }

  virtual ~TLoadDataResp() throw();
   ::impala::TResultRow load_summary;

  void __set_load_summary(const  ::impala::TResultRow& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TLoadDataResp &a, TLoadDataResp &b);

std::ostream& operator<<(std::ostream& out, const TLoadDataResp& obj);

typedef struct _TCatalogOpRequest__isset {
  _TCatalogOpRequest__isset() : use_db_params(false), describe_db_params(false), describe_table_params(false), show_dbs_params(false), show_tables_params(false), show_fns_params(false), show_data_srcs_params(false), show_roles_params(false), show_grant_principal_params(false), ddl_params(false), reset_metadata_params(false), show_stats_params(false), show_create_table_params(false), show_files_params(false), lineage_graph(false), show_create_function_params(false), describe_history_params(false) {}
  bool use_db_params :1;
  bool describe_db_params :1;
  bool describe_table_params :1;
  bool show_dbs_params :1;
  bool show_tables_params :1;
  bool show_fns_params :1;
  bool show_data_srcs_params :1;
  bool show_roles_params :1;
  bool show_grant_principal_params :1;
  bool ddl_params :1;
  bool reset_metadata_params :1;
  bool show_stats_params :1;
  bool show_create_table_params :1;
  bool show_files_params :1;
  bool lineage_graph :1;
  bool show_create_function_params :1;
  bool describe_history_params :1;
} _TCatalogOpRequest__isset;

class TCatalogOpRequest {
 public:

  TCatalogOpRequest(const TCatalogOpRequest&);
  TCatalogOpRequest(TCatalogOpRequest&&);
  TCatalogOpRequest& operator=(const TCatalogOpRequest&);
  TCatalogOpRequest& operator=(TCatalogOpRequest&&);
  TCatalogOpRequest() : op_type((TCatalogOpType::type)0), sync_ddl(0) {
  }

  virtual ~TCatalogOpRequest() throw();
  TCatalogOpType::type op_type;
  bool sync_ddl;
  TUseDbParams use_db_params;
  TDescribeDbParams describe_db_params;
  TDescribeTableParams describe_table_params;
  TShowDbsParams show_dbs_params;
  TShowTablesParams show_tables_params;
  TShowFunctionsParams show_fns_params;
  TShowDataSrcsParams show_data_srcs_params;
  TShowRolesParams show_roles_params;
  TShowGrantPrincipalParams show_grant_principal_params;
   ::impala::TDdlExecRequest ddl_params;
   ::impala::TResetMetadataRequest reset_metadata_params;
  TShowStatsParams show_stats_params;
   ::impala::TTableName show_create_table_params;
  TShowFilesParams show_files_params;
   ::impala::TLineageGraph lineage_graph;
  TGetFunctionsParams show_create_function_params;
  TDescribeHistoryParams describe_history_params;

  _TCatalogOpRequest__isset __isset;

  void __set_op_type(const TCatalogOpType::type val);

  void __set_sync_ddl(const bool val);

  void __set_use_db_params(const TUseDbParams& val);

  void __set_describe_db_params(const TDescribeDbParams& val);

  void __set_describe_table_params(const TDescribeTableParams& val);

  void __set_show_dbs_params(const TShowDbsParams& val);

  void __set_show_tables_params(const TShowTablesParams& val);

  void __set_show_fns_params(const TShowFunctionsParams& val);

  void __set_show_data_srcs_params(const TShowDataSrcsParams& val);

  void __set_show_roles_params(const TShowRolesParams& val);

  void __set_show_grant_principal_params(const TShowGrantPrincipalParams& val);

  void __set_ddl_params(const  ::impala::TDdlExecRequest& val);

  void __set_reset_metadata_params(const  ::impala::TResetMetadataRequest& val);

  void __set_show_stats_params(const TShowStatsParams& val);

  void __set_show_create_table_params(const  ::impala::TTableName& val);

  void __set_show_files_params(const TShowFilesParams& val);

  void __set_lineage_graph(const  ::impala::TLineageGraph& val);

  void __set_show_create_function_params(const TGetFunctionsParams& val);

  void __set_describe_history_params(const TDescribeHistoryParams& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogOpRequest &a, TCatalogOpRequest &b);

std::ostream& operator<<(std::ostream& out, const TCatalogOpRequest& obj);

typedef struct _TSetQueryOptionRequest__isset {
  _TSetQueryOptionRequest__isset() : key(false), value(false), is_set_all(false) {}
  bool key :1;
  bool value :1;
  bool is_set_all :1;
} _TSetQueryOptionRequest__isset;

class TSetQueryOptionRequest {
 public:

  TSetQueryOptionRequest(const TSetQueryOptionRequest&);
  TSetQueryOptionRequest(TSetQueryOptionRequest&&);
  TSetQueryOptionRequest& operator=(const TSetQueryOptionRequest&);
  TSetQueryOptionRequest& operator=(TSetQueryOptionRequest&&);
  TSetQueryOptionRequest() : key(), value(), is_set_all(0) {
  }

  virtual ~TSetQueryOptionRequest() throw();
  std::string key;
  std::string value;
  bool is_set_all;

  _TSetQueryOptionRequest__isset __isset;

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  void __set_is_set_all(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSetQueryOptionRequest &a, TSetQueryOptionRequest &b);

std::ostream& operator<<(std::ostream& out, const TSetQueryOptionRequest& obj);

typedef struct _TShutdownParams__isset {
  _TShutdownParams__isset() : backend(false), deadline_s(false) {}
  bool backend :1;
  bool deadline_s :1;
} _TShutdownParams__isset;

class TShutdownParams {
 public:

  TShutdownParams(const TShutdownParams&);
  TShutdownParams(TShutdownParams&&);
  TShutdownParams& operator=(const TShutdownParams&);
  TShutdownParams& operator=(TShutdownParams&&);
  TShutdownParams() : deadline_s(0) {
  }

  virtual ~TShutdownParams() throw();
   ::impala::TNetworkAddress backend;
  int64_t deadline_s;

  _TShutdownParams__isset __isset;

  void __set_backend(const  ::impala::TNetworkAddress& val);

  void __set_deadline_s(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TShutdownParams &a, TShutdownParams &b);

std::ostream& operator<<(std::ostream& out, const TShutdownParams& obj);

typedef struct _TAdminRequest__isset {
  _TAdminRequest__isset() : shutdown_params(false) {}
  bool shutdown_params :1;
} _TAdminRequest__isset;

class TAdminRequest {
 public:

  TAdminRequest(const TAdminRequest&);
  TAdminRequest(TAdminRequest&&);
  TAdminRequest& operator=(const TAdminRequest&);
  TAdminRequest& operator=(TAdminRequest&&);
  TAdminRequest() : type((TAdminRequestType::type)0) {
  }

  virtual ~TAdminRequest() throw();
  TAdminRequestType::type type;
  TShutdownParams shutdown_params;

  _TAdminRequest__isset __isset;

  void __set_type(const TAdminRequestType::type val);

  void __set_shutdown_params(const TShutdownParams& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAdminRequest &a, TAdminRequest &b);

std::ostream& operator<<(std::ostream& out, const TAdminRequest& obj);

typedef struct _TMetadataOpRequest__isset {
  _TMetadataOpRequest__isset() : get_info_req(false), get_type_info_req(false), get_catalogs_req(false), get_schemas_req(false), get_tables_req(false), get_table_types_req(false), get_columns_req(false), get_functions_req(false), session(false), get_primary_keys_req(false), get_cross_reference_req(false) {}
  bool get_info_req :1;
  bool get_type_info_req :1;
  bool get_catalogs_req :1;
  bool get_schemas_req :1;
  bool get_tables_req :1;
  bool get_table_types_req :1;
  bool get_columns_req :1;
  bool get_functions_req :1;
  bool session :1;
  bool get_primary_keys_req :1;
  bool get_cross_reference_req :1;
} _TMetadataOpRequest__isset;

class TMetadataOpRequest {
 public:

  TMetadataOpRequest(const TMetadataOpRequest&);
  TMetadataOpRequest(TMetadataOpRequest&&);
  TMetadataOpRequest& operator=(const TMetadataOpRequest&);
  TMetadataOpRequest& operator=(TMetadataOpRequest&&);
  TMetadataOpRequest() : opcode((TMetadataOpcode::type)0) {
  }

  virtual ~TMetadataOpRequest() throw();
  TMetadataOpcode::type opcode;
   ::apache::hive::service::cli::thrift::TGetInfoReq get_info_req;
   ::apache::hive::service::cli::thrift::TGetTypeInfoReq get_type_info_req;
   ::apache::hive::service::cli::thrift::TGetCatalogsReq get_catalogs_req;
   ::apache::hive::service::cli::thrift::TGetSchemasReq get_schemas_req;
   ::apache::hive::service::cli::thrift::TGetTablesReq get_tables_req;
   ::apache::hive::service::cli::thrift::TGetTableTypesReq get_table_types_req;
   ::apache::hive::service::cli::thrift::TGetColumnsReq get_columns_req;
   ::apache::hive::service::cli::thrift::TGetFunctionsReq get_functions_req;
   ::impala::TSessionState session;
   ::apache::hive::service::cli::thrift::TGetPrimaryKeysReq get_primary_keys_req;
   ::apache::hive::service::cli::thrift::TGetCrossReferenceReq get_cross_reference_req;

  _TMetadataOpRequest__isset __isset;

  void __set_opcode(const TMetadataOpcode::type val);

  void __set_get_info_req(const  ::apache::hive::service::cli::thrift::TGetInfoReq& val);

  void __set_get_type_info_req(const  ::apache::hive::service::cli::thrift::TGetTypeInfoReq& val);

  void __set_get_catalogs_req(const  ::apache::hive::service::cli::thrift::TGetCatalogsReq& val);

  void __set_get_schemas_req(const  ::apache::hive::service::cli::thrift::TGetSchemasReq& val);

  void __set_get_tables_req(const  ::apache::hive::service::cli::thrift::TGetTablesReq& val);

  void __set_get_table_types_req(const  ::apache::hive::service::cli::thrift::TGetTableTypesReq& val);

  void __set_get_columns_req(const  ::apache::hive::service::cli::thrift::TGetColumnsReq& val);

  void __set_get_functions_req(const  ::apache::hive::service::cli::thrift::TGetFunctionsReq& val);

  void __set_session(const  ::impala::TSessionState& val);

  void __set_get_primary_keys_req(const  ::apache::hive::service::cli::thrift::TGetPrimaryKeysReq& val);

  void __set_get_cross_reference_req(const  ::apache::hive::service::cli::thrift::TGetCrossReferenceReq& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TMetadataOpRequest &a, TMetadataOpRequest &b);

std::ostream& operator<<(std::ostream& out, const TMetadataOpRequest& obj);


class TAccessEvent {
 public:

  TAccessEvent(const TAccessEvent&);
  TAccessEvent(TAccessEvent&&);
  TAccessEvent& operator=(const TAccessEvent&);
  TAccessEvent& operator=(TAccessEvent&&);
  TAccessEvent() : name(), object_type(( ::impala::TCatalogObjectType::type)0), privilege() {
  }

  virtual ~TAccessEvent() throw();
  std::string name;
   ::impala::TCatalogObjectType::type object_type;
  std::string privilege;

  void __set_name(const std::string& val);

  void __set_object_type(const  ::impala::TCatalogObjectType::type val);

  void __set_privilege(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAccessEvent &a, TAccessEvent &b);

std::ostream& operator<<(std::ostream& out, const TAccessEvent& obj);

typedef struct _TExecRequest__isset {
  _TExecRequest__isset() : query_exec_request(false), catalog_op_request(false), result_set_metadata(false), explain_result(false), load_data_request(false), access_events(false), set_query_option_request(false), timeline(false), user_has_profile_access(false), admin_request(false), profile(false), testcase_data_path(false), remote_submit_time(false) {}
  bool query_exec_request :1;
  bool catalog_op_request :1;
  bool result_set_metadata :1;
  bool explain_result :1;
  bool load_data_request :1;
  bool access_events :1;
  bool set_query_option_request :1;
  bool timeline :1;
  bool user_has_profile_access :1;
  bool admin_request :1;
  bool profile :1;
  bool testcase_data_path :1;
  bool remote_submit_time :1;
} _TExecRequest__isset;

class TExecRequest {
 public:

  TExecRequest(const TExecRequest&);
  TExecRequest(TExecRequest&&);
  TExecRequest& operator=(const TExecRequest&);
  TExecRequest& operator=(TExecRequest&&);
  TExecRequest() : stmt_type(( ::impala::TStmtType::type)0), user_has_profile_access(0), testcase_data_path(), remote_submit_time(0) {
  }

  virtual ~TExecRequest() throw();
   ::impala::TStmtType::type stmt_type;
   ::impala::TQueryOptions query_options;
   ::impala::TQueryExecRequest query_exec_request;
  TCatalogOpRequest catalog_op_request;
   ::impala::TResultSetMetadata result_set_metadata;
  TExplainResult explain_result;
  TLoadDataReq load_data_request;
  std::vector<TAccessEvent>  access_events;
  std::vector<std::string>  analysis_warnings;
  TSetQueryOptionRequest set_query_option_request;
   ::impala::TEventSequence timeline;
  bool user_has_profile_access;
  TAdminRequest admin_request;
   ::impala::TRuntimeProfileNode profile;
  std::string testcase_data_path;
  int64_t remote_submit_time;

  _TExecRequest__isset __isset;

  void __set_stmt_type(const  ::impala::TStmtType::type val);

  void __set_query_options(const  ::impala::TQueryOptions& val);

  void __set_query_exec_request(const  ::impala::TQueryExecRequest& val);

  void __set_catalog_op_request(const TCatalogOpRequest& val);

  void __set_result_set_metadata(const  ::impala::TResultSetMetadata& val);

  void __set_explain_result(const TExplainResult& val);

  void __set_load_data_request(const TLoadDataReq& val);

  void __set_access_events(const std::vector<TAccessEvent> & val);

  void __set_analysis_warnings(const std::vector<std::string> & val);

  void __set_set_query_option_request(const TSetQueryOptionRequest& val);

  void __set_timeline(const  ::impala::TEventSequence& val);

  void __set_user_has_profile_access(const bool val);

  void __set_admin_request(const TAdminRequest& val);

  void __set_profile(const  ::impala::TRuntimeProfileNode& val);

  void __set_testcase_data_path(const std::string& val);

  void __set_remote_submit_time(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExecRequest &a, TExecRequest &b);

std::ostream& operator<<(std::ostream& out, const TExecRequest& obj);


class TCacheJarParams {
 public:

  TCacheJarParams(const TCacheJarParams&);
  TCacheJarParams(TCacheJarParams&&);
  TCacheJarParams& operator=(const TCacheJarParams&);
  TCacheJarParams& operator=(TCacheJarParams&&);
  TCacheJarParams() : hdfs_location() {
  }

  virtual ~TCacheJarParams() throw();
  std::string hdfs_location;

  void __set_hdfs_location(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCacheJarParams &a, TCacheJarParams &b);

std::ostream& operator<<(std::ostream& out, const TCacheJarParams& obj);

typedef struct _TCacheJarResult__isset {
  _TCacheJarResult__isset() : local_path(false) {}
  bool local_path :1;
} _TCacheJarResult__isset;

class TCacheJarResult {
 public:

  TCacheJarResult(const TCacheJarResult&);
  TCacheJarResult(TCacheJarResult&&);
  TCacheJarResult& operator=(const TCacheJarResult&);
  TCacheJarResult& operator=(TCacheJarResult&&);
  TCacheJarResult() : local_path() {
  }

  virtual ~TCacheJarResult() throw();
   ::impala::TStatus status;
  std::string local_path;

  _TCacheJarResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val);

  void __set_local_path(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCacheJarResult &a, TCacheJarResult &b);

std::ostream& operator<<(std::ostream& out, const TCacheJarResult& obj);

typedef struct _TSymbolLookupParams__isset {
  _TSymbolLookupParams__isset() : ret_arg_type(false) {}
  bool ret_arg_type :1;
} _TSymbolLookupParams__isset;

class TSymbolLookupParams {
 public:

  TSymbolLookupParams(const TSymbolLookupParams&);
  TSymbolLookupParams(TSymbolLookupParams&&);
  TSymbolLookupParams& operator=(const TSymbolLookupParams&);
  TSymbolLookupParams& operator=(TSymbolLookupParams&&);
  TSymbolLookupParams() : location(), symbol(), fn_binary_type(( ::impala::TFunctionBinaryType::type)0), has_var_args(0), symbol_type((TSymbolType::type)0), needs_refresh(0) {
  }

  virtual ~TSymbolLookupParams() throw();
  std::string location;
  std::string symbol;
   ::impala::TFunctionBinaryType::type fn_binary_type;
  std::vector< ::impala::TColumnType>  arg_types;
  bool has_var_args;
   ::impala::TColumnType ret_arg_type;
  TSymbolType::type symbol_type;
  bool needs_refresh;

  _TSymbolLookupParams__isset __isset;

  void __set_location(const std::string& val);

  void __set_symbol(const std::string& val);

  void __set_fn_binary_type(const  ::impala::TFunctionBinaryType::type val);

  void __set_arg_types(const std::vector< ::impala::TColumnType> & val);

  void __set_has_var_args(const bool val);

  void __set_ret_arg_type(const  ::impala::TColumnType& val);

  void __set_symbol_type(const TSymbolType::type val);

  void __set_needs_refresh(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSymbolLookupParams &a, TSymbolLookupParams &b);

std::ostream& operator<<(std::ostream& out, const TSymbolLookupParams& obj);

typedef struct _TSymbolLookupResult__isset {
  _TSymbolLookupResult__isset() : symbol(false), error_msg(false), last_modified_time(false) {}
  bool symbol :1;
  bool error_msg :1;
  bool last_modified_time :1;
} _TSymbolLookupResult__isset;

class TSymbolLookupResult {
 public:

  TSymbolLookupResult(const TSymbolLookupResult&);
  TSymbolLookupResult(TSymbolLookupResult&&);
  TSymbolLookupResult& operator=(const TSymbolLookupResult&);
  TSymbolLookupResult& operator=(TSymbolLookupResult&&);
  TSymbolLookupResult() : result_code((TSymbolLookupResultCode::type)0), symbol(), error_msg(), last_modified_time(0) {
  }

  virtual ~TSymbolLookupResult() throw();
  TSymbolLookupResultCode::type result_code;
  std::string symbol;
  std::string error_msg;
  int64_t last_modified_time;

  _TSymbolLookupResult__isset __isset;

  void __set_result_code(const TSymbolLookupResultCode::type val);

  void __set_symbol(const std::string& val);

  void __set_error_msg(const std::string& val);

  void __set_last_modified_time(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSymbolLookupResult &a, TSymbolLookupResult &b);

std::ostream& operator<<(std::ostream& out, const TSymbolLookupResult& obj);

typedef struct _TUpdateCatalogCacheRequest__isset {
  _TUpdateCatalogCacheRequest__isset() : catalog_service_id(false), updated_objects_deprecated(false), removed_objects_deprecated(false) {}
  bool catalog_service_id :1;
  bool updated_objects_deprecated :1;
  bool removed_objects_deprecated :1;
} _TUpdateCatalogCacheRequest__isset;

class TUpdateCatalogCacheRequest {
 public:

  TUpdateCatalogCacheRequest(const TUpdateCatalogCacheRequest&);
  TUpdateCatalogCacheRequest(TUpdateCatalogCacheRequest&&);
  TUpdateCatalogCacheRequest& operator=(const TUpdateCatalogCacheRequest&);
  TUpdateCatalogCacheRequest& operator=(TUpdateCatalogCacheRequest&&);
  TUpdateCatalogCacheRequest() : is_delta(0), native_iterator_ptr(0) {
  }

  virtual ~TUpdateCatalogCacheRequest() throw();
  bool is_delta;
   ::impala::TUniqueId catalog_service_id;
  std::vector< ::impala::TCatalogObject>  updated_objects_deprecated;
  std::vector< ::impala::TCatalogObject>  removed_objects_deprecated;
  int64_t native_iterator_ptr;

  _TUpdateCatalogCacheRequest__isset __isset;

  void __set_is_delta(const bool val);

  void __set_catalog_service_id(const  ::impala::TUniqueId& val);

  void __set_updated_objects_deprecated(const std::vector< ::impala::TCatalogObject> & val);

  void __set_removed_objects_deprecated(const std::vector< ::impala::TCatalogObject> & val);

  void __set_native_iterator_ptr(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateCatalogCacheRequest &a, TUpdateCatalogCacheRequest &b);

std::ostream& operator<<(std::ostream& out, const TUpdateCatalogCacheRequest& obj);


class TUpdateCatalogCacheResponse {
 public:

  TUpdateCatalogCacheResponse(const TUpdateCatalogCacheResponse&);
  TUpdateCatalogCacheResponse(TUpdateCatalogCacheResponse&&);
  TUpdateCatalogCacheResponse& operator=(const TUpdateCatalogCacheResponse&);
  TUpdateCatalogCacheResponse& operator=(TUpdateCatalogCacheResponse&&);
  TUpdateCatalogCacheResponse() : catalog_object_version_lower_bound(0), new_catalog_version(0) {
  }

  virtual ~TUpdateCatalogCacheResponse() throw();
   ::impala::TUniqueId catalog_service_id;
  int64_t catalog_object_version_lower_bound;
  int64_t new_catalog_version;

  void __set_catalog_service_id(const  ::impala::TUniqueId& val);

  void __set_catalog_object_version_lower_bound(const int64_t val);

  void __set_new_catalog_version(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateCatalogCacheResponse &a, TUpdateCatalogCacheResponse &b);

std::ostream& operator<<(std::ostream& out, const TUpdateCatalogCacheResponse& obj);

typedef struct _TUpdateExecutorMembershipRequest__isset {
  _TUpdateExecutorMembershipRequest__isset() : num_executors(false) {}
  bool num_executors :1;
} _TUpdateExecutorMembershipRequest__isset;

class TUpdateExecutorMembershipRequest {
 public:

  TUpdateExecutorMembershipRequest(const TUpdateExecutorMembershipRequest&);
  TUpdateExecutorMembershipRequest(TUpdateExecutorMembershipRequest&&);
  TUpdateExecutorMembershipRequest& operator=(const TUpdateExecutorMembershipRequest&);
  TUpdateExecutorMembershipRequest& operator=(TUpdateExecutorMembershipRequest&&);
  TUpdateExecutorMembershipRequest() : num_executors(0) {
  }

  virtual ~TUpdateExecutorMembershipRequest() throw();
  std::set<std::string>  hostnames;
  std::set<std::string>  ip_addresses;
  int32_t num_executors;

  _TUpdateExecutorMembershipRequest__isset __isset;

  void __set_hostnames(const std::set<std::string> & val);

  void __set_ip_addresses(const std::set<std::string> & val);

  void __set_num_executors(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateExecutorMembershipRequest &a, TUpdateExecutorMembershipRequest &b);

std::ostream& operator<<(std::ostream& out, const TUpdateExecutorMembershipRequest& obj);


class TJvmMemoryPool {
 public:

  TJvmMemoryPool(const TJvmMemoryPool&);
  TJvmMemoryPool(TJvmMemoryPool&&);
  TJvmMemoryPool& operator=(const TJvmMemoryPool&);
  TJvmMemoryPool& operator=(TJvmMemoryPool&&);
  TJvmMemoryPool() : committed(0), init(0), max(0), used(0), peak_committed(0), peak_init(0), peak_max(0), peak_used(0), name() {
  }

  virtual ~TJvmMemoryPool() throw();
  int64_t committed;
  int64_t init;
  int64_t max;
  int64_t used;
  int64_t peak_committed;
  int64_t peak_init;
  int64_t peak_max;
  int64_t peak_used;
  std::string name;

  void __set_committed(const int64_t val);

  void __set_init(const int64_t val);

  void __set_max(const int64_t val);

  void __set_used(const int64_t val);

  void __set_peak_committed(const int64_t val);

  void __set_peak_init(const int64_t val);

  void __set_peak_max(const int64_t val);

  void __set_peak_used(const int64_t val);

  void __set_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TJvmMemoryPool &a, TJvmMemoryPool &b);

std::ostream& operator<<(std::ostream& out, const TJvmMemoryPool& obj);


class TGetJvmMemoryMetricsResponse {
 public:

  TGetJvmMemoryMetricsResponse(const TGetJvmMemoryMetricsResponse&);
  TGetJvmMemoryMetricsResponse(TGetJvmMemoryMetricsResponse&&);
  TGetJvmMemoryMetricsResponse& operator=(const TGetJvmMemoryMetricsResponse&);
  TGetJvmMemoryMetricsResponse& operator=(TGetJvmMemoryMetricsResponse&&);
  TGetJvmMemoryMetricsResponse() : gc_num_warn_threshold_exceeded(0), gc_num_info_threshold_exceeded(0), gc_total_extra_sleep_time_millis(0), gc_count(0), gc_time_millis(0) {
  }

  virtual ~TGetJvmMemoryMetricsResponse() throw();
  std::vector<TJvmMemoryPool>  memory_pools;
  int64_t gc_num_warn_threshold_exceeded;
  int64_t gc_num_info_threshold_exceeded;
  int64_t gc_total_extra_sleep_time_millis;
  int64_t gc_count;
  int64_t gc_time_millis;

  void __set_memory_pools(const std::vector<TJvmMemoryPool> & val);

  void __set_gc_num_warn_threshold_exceeded(const int64_t val);

  void __set_gc_num_info_threshold_exceeded(const int64_t val);

  void __set_gc_total_extra_sleep_time_millis(const int64_t val);

  void __set_gc_count(const int64_t val);

  void __set_gc_time_millis(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetJvmMemoryMetricsResponse &a, TGetJvmMemoryMetricsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetJvmMemoryMetricsResponse& obj);


class TJvmThreadInfo {
 public:

  TJvmThreadInfo(const TJvmThreadInfo&);
  TJvmThreadInfo(TJvmThreadInfo&&);
  TJvmThreadInfo& operator=(const TJvmThreadInfo&);
  TJvmThreadInfo& operator=(TJvmThreadInfo&&);
  TJvmThreadInfo() : summary(), cpu_time_in_ns(0), user_time_in_ns(0), blocked_count(0), blocked_time_in_ms(0), is_in_native(0) {
  }

  virtual ~TJvmThreadInfo() throw();
  std::string summary;
  int64_t cpu_time_in_ns;
  int64_t user_time_in_ns;
  int64_t blocked_count;
  int64_t blocked_time_in_ms;
  bool is_in_native;

  void __set_summary(const std::string& val);

  void __set_cpu_time_in_ns(const int64_t val);

  void __set_user_time_in_ns(const int64_t val);

  void __set_blocked_count(const int64_t val);

  void __set_blocked_time_in_ms(const int64_t val);

  void __set_is_in_native(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TJvmThreadInfo &a, TJvmThreadInfo &b);

std::ostream& operator<<(std::ostream& out, const TJvmThreadInfo& obj);


class TGetJvmThreadsInfoRequest {
 public:

  TGetJvmThreadsInfoRequest(const TGetJvmThreadsInfoRequest&);
  TGetJvmThreadsInfoRequest(TGetJvmThreadsInfoRequest&&);
  TGetJvmThreadsInfoRequest& operator=(const TGetJvmThreadsInfoRequest&);
  TGetJvmThreadsInfoRequest& operator=(TGetJvmThreadsInfoRequest&&);
  TGetJvmThreadsInfoRequest() : get_complete_info(0) {
  }

  virtual ~TGetJvmThreadsInfoRequest() throw();
  bool get_complete_info;

  void __set_get_complete_info(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetJvmThreadsInfoRequest &a, TGetJvmThreadsInfoRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetJvmThreadsInfoRequest& obj);

typedef struct _TGetJvmThreadsInfoResponse__isset {
  _TGetJvmThreadsInfoResponse__isset() : threads(false) {}
  bool threads :1;
} _TGetJvmThreadsInfoResponse__isset;

class TGetJvmThreadsInfoResponse {
 public:

  TGetJvmThreadsInfoResponse(const TGetJvmThreadsInfoResponse&);
  TGetJvmThreadsInfoResponse(TGetJvmThreadsInfoResponse&&);
  TGetJvmThreadsInfoResponse& operator=(const TGetJvmThreadsInfoResponse&);
  TGetJvmThreadsInfoResponse& operator=(TGetJvmThreadsInfoResponse&&);
  TGetJvmThreadsInfoResponse() : total_thread_count(0), daemon_thread_count(0), peak_thread_count(0) {
  }

  virtual ~TGetJvmThreadsInfoResponse() throw();
  int32_t total_thread_count;
  int32_t daemon_thread_count;
  int32_t peak_thread_count;
  std::vector<TJvmThreadInfo>  threads;

  _TGetJvmThreadsInfoResponse__isset __isset;

  void __set_total_thread_count(const int32_t val);

  void __set_daemon_thread_count(const int32_t val);

  void __set_peak_thread_count(const int32_t val);

  void __set_threads(const std::vector<TJvmThreadInfo> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetJvmThreadsInfoResponse &a, TGetJvmThreadsInfoResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetJvmThreadsInfoResponse& obj);


class TGetJMXJsonResponse {
 public:

  TGetJMXJsonResponse(const TGetJMXJsonResponse&);
  TGetJMXJsonResponse(TGetJMXJsonResponse&&);
  TGetJMXJsonResponse& operator=(const TGetJMXJsonResponse&);
  TGetJMXJsonResponse& operator=(TGetJMXJsonResponse&&);
  TGetJMXJsonResponse() : jmx_json() {
  }

  virtual ~TGetJMXJsonResponse() throw();
  std::string jmx_json;

  void __set_jmx_json(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetJMXJsonResponse &a, TGetJMXJsonResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetJMXJsonResponse& obj);


class TGetHadoopConfigRequest {
 public:

  TGetHadoopConfigRequest(const TGetHadoopConfigRequest&);
  TGetHadoopConfigRequest(TGetHadoopConfigRequest&&);
  TGetHadoopConfigRequest& operator=(const TGetHadoopConfigRequest&);
  TGetHadoopConfigRequest& operator=(TGetHadoopConfigRequest&&);
  TGetHadoopConfigRequest() : name() {
  }

  virtual ~TGetHadoopConfigRequest() throw();
  std::string name;

  void __set_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetHadoopConfigRequest &a, TGetHadoopConfigRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetHadoopConfigRequest& obj);

typedef struct _TGetHadoopConfigResponse__isset {
  _TGetHadoopConfigResponse__isset() : value(false) {}
  bool value :1;
} _TGetHadoopConfigResponse__isset;

class TGetHadoopConfigResponse {
 public:

  TGetHadoopConfigResponse(const TGetHadoopConfigResponse&);
  TGetHadoopConfigResponse(TGetHadoopConfigResponse&&);
  TGetHadoopConfigResponse& operator=(const TGetHadoopConfigResponse&);
  TGetHadoopConfigResponse& operator=(TGetHadoopConfigResponse&&);
  TGetHadoopConfigResponse() : value() {
  }

  virtual ~TGetHadoopConfigResponse() throw();
  std::string value;

  _TGetHadoopConfigResponse__isset __isset;

  void __set_value(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetHadoopConfigResponse &a, TGetHadoopConfigResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetHadoopConfigResponse& obj);

typedef struct _TGetAllHadoopConfigsResponse__isset {
  _TGetAllHadoopConfigsResponse__isset() : configs(false) {}
  bool configs :1;
} _TGetAllHadoopConfigsResponse__isset;

class TGetAllHadoopConfigsResponse {
 public:

  TGetAllHadoopConfigsResponse(const TGetAllHadoopConfigsResponse&);
  TGetAllHadoopConfigsResponse(TGetAllHadoopConfigsResponse&&);
  TGetAllHadoopConfigsResponse& operator=(const TGetAllHadoopConfigsResponse&);
  TGetAllHadoopConfigsResponse& operator=(TGetAllHadoopConfigsResponse&&);
  TGetAllHadoopConfigsResponse() {
  }

  virtual ~TGetAllHadoopConfigsResponse() throw();
  std::map<std::string, std::string>  configs;

  _TGetAllHadoopConfigsResponse__isset __isset;

  void __set_configs(const std::map<std::string, std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetAllHadoopConfigsResponse &a, TGetAllHadoopConfigsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetAllHadoopConfigsResponse& obj);


class TGetHadoopGroupsRequest {
 public:

  TGetHadoopGroupsRequest(const TGetHadoopGroupsRequest&);
  TGetHadoopGroupsRequest(TGetHadoopGroupsRequest&&);
  TGetHadoopGroupsRequest& operator=(const TGetHadoopGroupsRequest&);
  TGetHadoopGroupsRequest& operator=(TGetHadoopGroupsRequest&&);
  TGetHadoopGroupsRequest() : user() {
  }

  virtual ~TGetHadoopGroupsRequest() throw();
  std::string user;

  void __set_user(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetHadoopGroupsRequest &a, TGetHadoopGroupsRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetHadoopGroupsRequest& obj);


class TGetHadoopGroupsResponse {
 public:

  TGetHadoopGroupsResponse(const TGetHadoopGroupsResponse&);
  TGetHadoopGroupsResponse(TGetHadoopGroupsResponse&&);
  TGetHadoopGroupsResponse& operator=(const TGetHadoopGroupsResponse&);
  TGetHadoopGroupsResponse& operator=(TGetHadoopGroupsResponse&&);
  TGetHadoopGroupsResponse() {
  }

  virtual ~TGetHadoopGroupsResponse() throw();
  std::vector<std::string>  groups;

  void __set_groups(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetHadoopGroupsResponse &a, TGetHadoopGroupsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetHadoopGroupsResponse& obj);


class TBuildTestDescriptorTableParams {
 public:

  TBuildTestDescriptorTableParams(const TBuildTestDescriptorTableParams&);
  TBuildTestDescriptorTableParams(TBuildTestDescriptorTableParams&&);
  TBuildTestDescriptorTableParams& operator=(const TBuildTestDescriptorTableParams&);
  TBuildTestDescriptorTableParams& operator=(TBuildTestDescriptorTableParams&&);
  TBuildTestDescriptorTableParams() {
  }

  virtual ~TBuildTestDescriptorTableParams() throw();
  std::vector<std::vector< ::impala::TColumnType> >  slot_types;

  void __set_slot_types(const std::vector<std::vector< ::impala::TColumnType> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBuildTestDescriptorTableParams &a, TBuildTestDescriptorTableParams &b);

std::ostream& operator<<(std::ostream& out, const TBuildTestDescriptorTableParams& obj);

typedef struct _TTestCaseData__isset {
  _TTestCaseData__isset() : tables_and_views(false), dbs(false) {}
  bool tables_and_views :1;
  bool dbs :1;
} _TTestCaseData__isset;

class TTestCaseData {
 public:

  TTestCaseData(const TTestCaseData&);
  TTestCaseData(TTestCaseData&&);
  TTestCaseData& operator=(const TTestCaseData&);
  TTestCaseData& operator=(TTestCaseData&&);
  TTestCaseData() : query_stmt(), testcase_data_path(), impala_version() {
  }

  virtual ~TTestCaseData() throw();
  std::string query_stmt;
  std::vector< ::impala::TTable>  tables_and_views;
  std::vector< ::impala::TDatabase>  dbs;
  std::string testcase_data_path;
  std::string impala_version;

  _TTestCaseData__isset __isset;

  void __set_query_stmt(const std::string& val);

  void __set_tables_and_views(const std::vector< ::impala::TTable> & val);

  void __set_dbs(const std::vector< ::impala::TDatabase> & val);

  void __set_testcase_data_path(const std::string& val);

  void __set_impala_version(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTestCaseData &a, TTestCaseData &b);

std::ostream& operator<<(std::ostream& out, const TTestCaseData& obj);


class TQueryCompleteContext {
 public:

  TQueryCompleteContext(const TQueryCompleteContext&);
  TQueryCompleteContext(TQueryCompleteContext&&);
  TQueryCompleteContext& operator=(const TQueryCompleteContext&);
  TQueryCompleteContext& operator=(TQueryCompleteContext&&);
  TQueryCompleteContext() : lineage_string() {
  }

  virtual ~TQueryCompleteContext() throw();
  std::string lineage_string;

  void __set_lineage_string(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryCompleteContext &a, TQueryCompleteContext &b);

std::ostream& operator<<(std::ostream& out, const TQueryCompleteContext& obj);

typedef struct _TWrappedHttpRequest__isset {
  _TWrappedHttpRequest__isset() : content(false) {}
  bool content :1;
} _TWrappedHttpRequest__isset;

class TWrappedHttpRequest {
 public:

  TWrappedHttpRequest(const TWrappedHttpRequest&);
  TWrappedHttpRequest(TWrappedHttpRequest&&);
  TWrappedHttpRequest& operator=(const TWrappedHttpRequest&);
  TWrappedHttpRequest& operator=(TWrappedHttpRequest&&);
  TWrappedHttpRequest() : method(), server_name(), server_port(0), path(), content(), remote_ip(), secure(0) {
  }

  virtual ~TWrappedHttpRequest() throw();
  std::string method;
  std::string server_name;
  int32_t server_port;
  std::string path;
  std::map<std::string, std::string>  params;
  std::map<std::string, std::string>  headers;
  std::map<std::string, std::string>  cookies;
  std::string content;
  std::string remote_ip;
  bool secure;

  _TWrappedHttpRequest__isset __isset;

  void __set_method(const std::string& val);

  void __set_server_name(const std::string& val);

  void __set_server_port(const int32_t val);

  void __set_path(const std::string& val);

  void __set_params(const std::map<std::string, std::string> & val);

  void __set_headers(const std::map<std::string, std::string> & val);

  void __set_cookies(const std::map<std::string, std::string> & val);

  void __set_content(const std::string& val);

  void __set_remote_ip(const std::string& val);

  void __set_secure(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TWrappedHttpRequest &a, TWrappedHttpRequest &b);

std::ostream& operator<<(std::ostream& out, const TWrappedHttpRequest& obj);

typedef struct _TWrappedHttpResponse__isset {
  _TWrappedHttpResponse__isset() : content(false), content_type(false) {}
  bool content :1;
  bool content_type :1;
} _TWrappedHttpResponse__isset;

class TWrappedHttpResponse {
 public:

  TWrappedHttpResponse(const TWrappedHttpResponse&);
  TWrappedHttpResponse(TWrappedHttpResponse&&);
  TWrappedHttpResponse& operator=(const TWrappedHttpResponse&);
  TWrappedHttpResponse& operator=(TWrappedHttpResponse&&);
  TWrappedHttpResponse() : status_code(0), status_text(), content(), content_type() {
  }

  virtual ~TWrappedHttpResponse() throw();
  int16_t status_code;
  std::string status_text;
  std::map<std::string, std::string>  headers;
  std::map<std::string, std::string>  cookies;
  std::string content;
  std::string content_type;

  _TWrappedHttpResponse__isset __isset;

  void __set_status_code(const int16_t val);

  void __set_status_text(const std::string& val);

  void __set_headers(const std::map<std::string, std::string> & val);

  void __set_cookies(const std::map<std::string, std::string> & val);

  void __set_content(const std::string& val);

  void __set_content_type(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TWrappedHttpResponse &a, TWrappedHttpResponse &b);

std::ostream& operator<<(std::ostream& out, const TWrappedHttpResponse& obj);

} // namespace

#include "Frontend_types.tcc"

#endif
