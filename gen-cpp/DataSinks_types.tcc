/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DataSinks_TYPES_TCC
#define DataSinks_TYPES_TCC

#include "ExecStats_types.tcc"
#include "Exprs_types.tcc"
#include "Types_types.tcc"
#include "Descriptors_types.tcc"
#include "Partitions_types.tcc"
#include "PlanNodes_types.tcc"
#include "ResourceProfile_types.tcc"
#include "DataSinks_types.h"

namespace impala {

template <class Protocol_>
uint32_t TDataStreamSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dest_node_id = false;
  bool isset_output_partition = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          isset_dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->output_partition.read(iprot);
          isset_output_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dest_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDataStreamSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataStreamSink");

  xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dest_node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_partition", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->output_partition.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsTableSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_key_exprs = false;
  bool isset_overwrite = false;
  bool isset_input_is_clustered = false;
  bool isset_sorting_order = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_key_exprs.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->partition_key_exprs.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->partition_key_exprs[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_key_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overwrite);
          isset_overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->skip_header_line_count);
          this->__isset.skip_header_line_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->input_is_clustered);
          isset_input_is_clustered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_columns.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->sort_columns.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += iprot->readI32(this->sort_columns[_i13]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->write_id);
          this->__isset.write_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->sorting_order = ( ::impala::TSortingOrder::type)ecast14;
          isset_sorting_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_result_sink);
          this->__isset.is_result_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->external_output_dir);
          this->__isset.external_output_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->external_output_partition_depth);
          this->__isset.external_output_partition_depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parquet_bloom_filter_col_info.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _ktype16;
            ::apache::thrift::protocol::TType _vtype17;
            xfer += iprot->readMapBegin(_ktype16, _vtype17, _size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              std::string _key20;
              xfer += iprot->readString(_key20);
              int64_t& _val21 = this->parquet_bloom_filter_col_info[_key20];
              xfer += iprot->readI64(_val21);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.parquet_bloom_filter_col_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_key_exprs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_overwrite)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_input_is_clustered)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sorting_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsTableSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsTableSink");

  xfer += oprot->writeFieldBegin("partition_key_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_key_exprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter22;
    for (_iter22 = this->partition_key_exprs.begin(); _iter22 != this->partition_key_exprs.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->overwrite);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skip_header_line_count) {
    xfer += oprot->writeFieldBegin("skip_header_line_count", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->skip_header_line_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("input_is_clustered", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->input_is_clustered);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sort_columns) {
    xfer += oprot->writeFieldBegin("sort_columns", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sort_columns.size()));
      std::vector<int32_t> ::const_iterator _iter23;
      for (_iter23 = this->sort_columns.begin(); _iter23 != this->sort_columns.end(); ++_iter23)
      {
        xfer += oprot->writeI32((*_iter23));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.write_id) {
    xfer += oprot->writeFieldBegin("write_id", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->write_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sorting_order", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->sorting_order);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.is_result_sink) {
    xfer += oprot->writeFieldBegin("is_result_sink", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_result_sink);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.external_output_dir) {
    xfer += oprot->writeFieldBegin("external_output_dir", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->external_output_dir);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.external_output_partition_depth) {
    xfer += oprot->writeFieldBegin("external_output_partition_depth", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->external_output_partition_depth);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parquet_bloom_filter_col_info) {
    xfer += oprot->writeFieldBegin("parquet_bloom_filter_col_info", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->parquet_bloom_filter_col_info.size()));
      std::map<std::string, int64_t> ::const_iterator _iter24;
      for (_iter24 = this->parquet_bloom_filter_col_info.begin(); _iter24 != this->parquet_bloom_filter_col_info.end(); ++_iter24)
      {
        xfer += oprot->writeString(_iter24->first);
        xfer += oprot->writeI64(_iter24->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TKuduTableSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->referenced_columns.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _etype32;
            xfer += iprot->readListBegin(_etype32, _size29);
            this->referenced_columns.resize(_size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              xfer += iprot->readI32(this->referenced_columns[_i33]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.referenced_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignore_not_found_or_duplicate);
          this->__isset.ignore_not_found_or_duplicate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->kudu_txn_token);
          this->__isset.kudu_txn_token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TKuduTableSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduTableSink");

  if (this->__isset.referenced_columns) {
    xfer += oprot->writeFieldBegin("referenced_columns", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->referenced_columns.size()));
      std::vector<int32_t> ::const_iterator _iter34;
      for (_iter34 = this->referenced_columns.begin(); _iter34 != this->referenced_columns.end(); ++_iter34)
      {
        xfer += oprot->writeI32((*_iter34));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignore_not_found_or_duplicate) {
    xfer += oprot->writeFieldBegin("ignore_not_found_or_duplicate", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->ignore_not_found_or_duplicate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_txn_token) {
    xfer += oprot->writeFieldBegin("kudu_txn_token", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->kudu_txn_token);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TJoinBuildSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_dest_node_id = false;
  bool isset_join_op = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dest_node_id);
          isset_dest_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast39;
          xfer += iprot->readI32(ecast39);
          this->join_op = ( ::impala::TJoinOp::type)ecast39;
          isset_join_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->eq_join_conjuncts.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->eq_join_conjuncts.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->eq_join_conjuncts[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.eq_join_conjuncts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->runtime_filters.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->runtime_filters.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->runtime_filters[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.runtime_filters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hash_seed);
          this->__isset.hash_seed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->share_build);
          this->__isset.share_build = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_dest_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_join_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TJoinBuildSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJoinBuildSink");

  xfer += oprot->writeFieldBegin("dest_node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dest_node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("join_op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->join_op);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.eq_join_conjuncts) {
    xfer += oprot->writeFieldBegin("eq_join_conjuncts", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->eq_join_conjuncts.size()));
      std::vector< ::impala::TEqJoinCondition> ::const_iterator _iter50;
      for (_iter50 = this->eq_join_conjuncts.begin(); _iter50 != this->eq_join_conjuncts.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.runtime_filters) {
    xfer += oprot->writeFieldBegin("runtime_filters", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->runtime_filters.size()));
      std::vector< ::impala::TRuntimeFilterDesc> ::const_iterator _iter51;
      for (_iter51 = this->runtime_filters.begin(); _iter51 != this->runtime_filters.end(); ++_iter51)
      {
        xfer += (*_iter51).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hash_seed) {
    xfer += oprot->writeFieldBegin("hash_seed", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->hash_seed);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.share_build) {
    xfer += oprot->writeFieldBegin("share_build", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->share_build);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPlanRootSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_resource_profile = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_profile.read(iprot);
          isset_resource_profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_resource_profile)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPlanRootSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanRootSink");

  xfer += oprot->writeFieldBegin("resource_profile", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->resource_profile.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_target_table_id = false;
  bool isset_type = false;
  bool isset_action = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->target_table_id);
          isset_target_table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->type = (TTableSinkType::type)ecast60;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->action = (TSinkAction::type)ecast61;
          isset_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_table_sink.read(iprot);
          this->__isset.hdfs_table_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kudu_table_sink.read(iprot);
          this->__isset.kudu_table_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_target_table_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_action)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTableSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableSink");

  xfer += oprot->writeFieldBegin("target_table_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->target_table_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->action);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hdfs_table_sink) {
    xfer += oprot->writeFieldBegin("hdfs_table_sink", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->hdfs_table_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_table_sink) {
    xfer += oprot->writeFieldBegin("kudu_table_sink", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->kudu_table_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDataSink::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->type = (TDataSinkType::type)ecast66;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_sink.read(iprot);
          this->__isset.stream_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_sink.read(iprot);
          this->__isset.table_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->join_build_sink.read(iprot);
          this->__isset.join_build_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->plan_root_sink.read(iprot);
          this->__isset.plan_root_sink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          this->__isset.label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->estimated_stats.read(iprot);
          this->__isset.estimated_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->output_exprs.clear();
            uint32_t _size67;
            ::apache::thrift::protocol::TType _etype70;
            xfer += iprot->readListBegin(_etype70, _size67);
            this->output_exprs.resize(_size67);
            uint32_t _i71;
            for (_i71 = 0; _i71 < _size67; ++_i71)
            {
              xfer += this->output_exprs[_i71].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.output_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->resource_profile.read(iprot);
          this->__isset.resource_profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDataSink::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSink");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stream_sink) {
    xfer += oprot->writeFieldBegin("stream_sink", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->stream_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_sink) {
    xfer += oprot->writeFieldBegin("table_sink", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->table_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.join_build_sink) {
    xfer += oprot->writeFieldBegin("join_build_sink", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->join_build_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.plan_root_sink) {
    xfer += oprot->writeFieldBegin("plan_root_sink", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->plan_root_sink.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.label) {
    xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->label);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.estimated_stats) {
    xfer += oprot->writeFieldBegin("estimated_stats", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->estimated_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.output_exprs) {
    xfer += oprot->writeFieldBegin("output_exprs", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->output_exprs.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter72;
      for (_iter72 = this->output_exprs.begin(); _iter72 != this->output_exprs.end(); ++_iter72)
      {
        xfer += (*_iter72).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.resource_profile) {
    xfer += oprot->writeFieldBegin("resource_profile", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->resource_profile.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
