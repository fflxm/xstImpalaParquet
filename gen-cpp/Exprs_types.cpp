/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Exprs_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTExprNodeTypeValues[] = {
  TExprNodeType::NULL_LITERAL,
  TExprNodeType::BOOL_LITERAL,
  TExprNodeType::INT_LITERAL,
  TExprNodeType::FLOAT_LITERAL,
  TExprNodeType::STRING_LITERAL,
  TExprNodeType::DECIMAL_LITERAL,
  TExprNodeType::TIMESTAMP_LITERAL,
  TExprNodeType::CASE_EXPR,
  TExprNodeType::COMPOUND_PRED,
  TExprNodeType::IN_PRED,
  TExprNodeType::IS_NULL_PRED,
  TExprNodeType::LIKE_PRED,
  TExprNodeType::SLOT_REF,
  TExprNodeType::TUPLE_IS_NULL_PRED,
  TExprNodeType::FUNCTION_CALL,
  TExprNodeType::AGGREGATE_EXPR,
  TExprNodeType::IS_NOT_EMPTY_PRED,
  TExprNodeType::KUDU_PARTITION_EXPR,
  TExprNodeType::VALID_TUPLE_ID_EXPR,
  TExprNodeType::DATE_LITERAL
};
const char* _kTExprNodeTypeNames[] = {
  "NULL_LITERAL",
  "BOOL_LITERAL",
  "INT_LITERAL",
  "FLOAT_LITERAL",
  "STRING_LITERAL",
  "DECIMAL_LITERAL",
  "TIMESTAMP_LITERAL",
  "CASE_EXPR",
  "COMPOUND_PRED",
  "IN_PRED",
  "IS_NULL_PRED",
  "LIKE_PRED",
  "SLOT_REF",
  "TUPLE_IS_NULL_PRED",
  "FUNCTION_CALL",
  "AGGREGATE_EXPR",
  "IS_NOT_EMPTY_PRED",
  "KUDU_PARTITION_EXPR",
  "VALID_TUPLE_ID_EXPR",
  "DATE_LITERAL"
};
const std::map<int, const char*> _TExprNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(20, _kTExprNodeTypeValues, _kTExprNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExprNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TExprNodeType_VALUES_TO_NAMES.find(val);
  if (it != _TExprNodeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExtractFieldValues[] = {
  TExtractField::INVALID_FIELD,
  TExtractField::YEAR,
  TExtractField::QUARTER,
  TExtractField::MONTH,
  TExtractField::DAY,
  TExtractField::HOUR,
  TExtractField::MINUTE,
  TExtractField::SECOND,
  TExtractField::MILLISECOND,
  TExtractField::EPOCH
};
const char* _kTExtractFieldNames[] = {
  "INVALID_FIELD",
  "YEAR",
  "QUARTER",
  "MONTH",
  "DAY",
  "HOUR",
  "MINUTE",
  "SECOND",
  "MILLISECOND",
  "EPOCH"
};
const std::map<int, const char*> _TExtractField_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTExtractFieldValues, _kTExtractFieldNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExtractField::type& val) {
  std::map<int, const char*>::const_iterator it = _TExtractField_VALUES_TO_NAMES.find(val);
  if (it != _TExtractField_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TBoolLiteral::~TBoolLiteral() throw() {
}


void TBoolLiteral::__set_value(const bool val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TBoolLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TBoolLiteral &a, TBoolLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TBoolLiteral::TBoolLiteral(const TBoolLiteral& other0) {
  value = other0.value;
}
TBoolLiteral::TBoolLiteral( TBoolLiteral&& other1) {
  value = std::move(other1.value);
}
TBoolLiteral& TBoolLiteral::operator=(const TBoolLiteral& other2) {
  value = other2.value;
  return *this;
}
TBoolLiteral& TBoolLiteral::operator=(TBoolLiteral&& other3) {
  value = std::move(other3.value);
  return *this;
}
void TBoolLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBoolLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TCaseExpr::~TCaseExpr() throw() {
}


void TCaseExpr::__set_has_case_expr(const bool val) {
  this->has_case_expr = val;
}

void TCaseExpr::__set_has_else_expr(const bool val) {
  this->has_else_expr = val;
}
std::ostream& operator<<(std::ostream& out, const TCaseExpr& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCaseExpr &a, TCaseExpr &b) {
  using ::std::swap;
  swap(a.has_case_expr, b.has_case_expr);
  swap(a.has_else_expr, b.has_else_expr);
}

TCaseExpr::TCaseExpr(const TCaseExpr& other4) {
  has_case_expr = other4.has_case_expr;
  has_else_expr = other4.has_else_expr;
}
TCaseExpr::TCaseExpr( TCaseExpr&& other5) {
  has_case_expr = std::move(other5.has_case_expr);
  has_else_expr = std::move(other5.has_else_expr);
}
TCaseExpr& TCaseExpr::operator=(const TCaseExpr& other6) {
  has_case_expr = other6.has_case_expr;
  has_else_expr = other6.has_else_expr;
  return *this;
}
TCaseExpr& TCaseExpr::operator=(TCaseExpr&& other7) {
  has_case_expr = std::move(other7.has_case_expr);
  has_else_expr = std::move(other7.has_else_expr);
  return *this;
}
void TCaseExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCaseExpr(";
  out << "has_case_expr=" << to_string(has_case_expr);
  out << ", " << "has_else_expr=" << to_string(has_else_expr);
  out << ")";
}


TDateLiteral::~TDateLiteral() throw() {
}


void TDateLiteral::__set_days_since_epoch(const int32_t val) {
  this->days_since_epoch = val;
}

void TDateLiteral::__set_date_string(const std::string& val) {
  this->date_string = val;
}
std::ostream& operator<<(std::ostream& out, const TDateLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDateLiteral &a, TDateLiteral &b) {
  using ::std::swap;
  swap(a.days_since_epoch, b.days_since_epoch);
  swap(a.date_string, b.date_string);
}

TDateLiteral::TDateLiteral(const TDateLiteral& other8) {
  days_since_epoch = other8.days_since_epoch;
  date_string = other8.date_string;
}
TDateLiteral::TDateLiteral( TDateLiteral&& other9) {
  days_since_epoch = std::move(other9.days_since_epoch);
  date_string = std::move(other9.date_string);
}
TDateLiteral& TDateLiteral::operator=(const TDateLiteral& other10) {
  days_since_epoch = other10.days_since_epoch;
  date_string = other10.date_string;
  return *this;
}
TDateLiteral& TDateLiteral::operator=(TDateLiteral&& other11) {
  days_since_epoch = std::move(other11.days_since_epoch);
  date_string = std::move(other11.date_string);
  return *this;
}
void TDateLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDateLiteral(";
  out << "days_since_epoch=" << to_string(days_since_epoch);
  out << ", " << "date_string=" << to_string(date_string);
  out << ")";
}


TDecimalLiteral::~TDecimalLiteral() throw() {
}


void TDecimalLiteral::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TDecimalLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDecimalLiteral &a, TDecimalLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TDecimalLiteral::TDecimalLiteral(const TDecimalLiteral& other12) {
  value = other12.value;
}
TDecimalLiteral::TDecimalLiteral( TDecimalLiteral&& other13) {
  value = std::move(other13.value);
}
TDecimalLiteral& TDecimalLiteral::operator=(const TDecimalLiteral& other14) {
  value = other14.value;
  return *this;
}
TDecimalLiteral& TDecimalLiteral::operator=(TDecimalLiteral&& other15) {
  value = std::move(other15.value);
  return *this;
}
void TDecimalLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDecimalLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TFloatLiteral::~TFloatLiteral() throw() {
}


void TFloatLiteral::__set_value(const double val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TFloatLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TFloatLiteral &a, TFloatLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TFloatLiteral::TFloatLiteral(const TFloatLiteral& other16) {
  value = other16.value;
}
TFloatLiteral::TFloatLiteral( TFloatLiteral&& other17) {
  value = std::move(other17.value);
}
TFloatLiteral& TFloatLiteral::operator=(const TFloatLiteral& other18) {
  value = other18.value;
  return *this;
}
TFloatLiteral& TFloatLiteral::operator=(TFloatLiteral&& other19) {
  value = std::move(other19.value);
  return *this;
}
void TFloatLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFloatLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TIntLiteral::~TIntLiteral() throw() {
}


void TIntLiteral::__set_value(const int64_t val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TIntLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIntLiteral &a, TIntLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TIntLiteral::TIntLiteral(const TIntLiteral& other20) {
  value = other20.value;
}
TIntLiteral::TIntLiteral( TIntLiteral&& other21) {
  value = std::move(other21.value);
}
TIntLiteral& TIntLiteral::operator=(const TIntLiteral& other22) {
  value = other22.value;
  return *this;
}
TIntLiteral& TIntLiteral::operator=(TIntLiteral&& other23) {
  value = std::move(other23.value);
  return *this;
}
void TIntLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIntLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TTimestampLiteral::~TTimestampLiteral() throw() {
}


void TTimestampLiteral::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TTimestampLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTimestampLiteral &a, TTimestampLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TTimestampLiteral::TTimestampLiteral(const TTimestampLiteral& other24) {
  value = other24.value;
}
TTimestampLiteral::TTimestampLiteral( TTimestampLiteral&& other25) {
  value = std::move(other25.value);
}
TTimestampLiteral& TTimestampLiteral::operator=(const TTimestampLiteral& other26) {
  value = other26.value;
  return *this;
}
TTimestampLiteral& TTimestampLiteral::operator=(TTimestampLiteral&& other27) {
  value = std::move(other27.value);
  return *this;
}
void TTimestampLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTimestampLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TInPredicate::~TInPredicate() throw() {
}


void TInPredicate::__set_is_not_in(const bool val) {
  this->is_not_in = val;
}
std::ostream& operator<<(std::ostream& out, const TInPredicate& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TInPredicate &a, TInPredicate &b) {
  using ::std::swap;
  swap(a.is_not_in, b.is_not_in);
}

TInPredicate::TInPredicate(const TInPredicate& other28) {
  is_not_in = other28.is_not_in;
}
TInPredicate::TInPredicate( TInPredicate&& other29) {
  is_not_in = std::move(other29.is_not_in);
}
TInPredicate& TInPredicate::operator=(const TInPredicate& other30) {
  is_not_in = other30.is_not_in;
  return *this;
}
TInPredicate& TInPredicate::operator=(TInPredicate&& other31) {
  is_not_in = std::move(other31.is_not_in);
  return *this;
}
void TInPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TInPredicate(";
  out << "is_not_in=" << to_string(is_not_in);
  out << ")";
}


TIsNullPredicate::~TIsNullPredicate() throw() {
}


void TIsNullPredicate::__set_is_not_null(const bool val) {
  this->is_not_null = val;
}
std::ostream& operator<<(std::ostream& out, const TIsNullPredicate& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIsNullPredicate &a, TIsNullPredicate &b) {
  using ::std::swap;
  swap(a.is_not_null, b.is_not_null);
}

TIsNullPredicate::TIsNullPredicate(const TIsNullPredicate& other32) {
  is_not_null = other32.is_not_null;
}
TIsNullPredicate::TIsNullPredicate( TIsNullPredicate&& other33) {
  is_not_null = std::move(other33.is_not_null);
}
TIsNullPredicate& TIsNullPredicate::operator=(const TIsNullPredicate& other34) {
  is_not_null = other34.is_not_null;
  return *this;
}
TIsNullPredicate& TIsNullPredicate::operator=(TIsNullPredicate&& other35) {
  is_not_null = std::move(other35.is_not_null);
  return *this;
}
void TIsNullPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIsNullPredicate(";
  out << "is_not_null=" << to_string(is_not_null);
  out << ")";
}


TLiteralPredicate::~TLiteralPredicate() throw() {
}


void TLiteralPredicate::__set_value(const bool val) {
  this->value = val;
}

void TLiteralPredicate::__set_is_null(const bool val) {
  this->is_null = val;
}
std::ostream& operator<<(std::ostream& out, const TLiteralPredicate& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TLiteralPredicate &a, TLiteralPredicate &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.is_null, b.is_null);
}

TLiteralPredicate::TLiteralPredicate(const TLiteralPredicate& other36) {
  value = other36.value;
  is_null = other36.is_null;
}
TLiteralPredicate::TLiteralPredicate( TLiteralPredicate&& other37) {
  value = std::move(other37.value);
  is_null = std::move(other37.is_null);
}
TLiteralPredicate& TLiteralPredicate::operator=(const TLiteralPredicate& other38) {
  value = other38.value;
  is_null = other38.is_null;
  return *this;
}
TLiteralPredicate& TLiteralPredicate::operator=(TLiteralPredicate&& other39) {
  value = std::move(other39.value);
  is_null = std::move(other39.is_null);
  return *this;
}
void TLiteralPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TLiteralPredicate(";
  out << "value=" << to_string(value);
  out << ", " << "is_null=" << to_string(is_null);
  out << ")";
}


TTupleIsNullPredicate::~TTupleIsNullPredicate() throw() {
}


void TTupleIsNullPredicate::__set_tuple_ids(const std::vector< ::impala::TTupleId> & val) {
  this->tuple_ids = val;
}
std::ostream& operator<<(std::ostream& out, const TTupleIsNullPredicate& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTupleIsNullPredicate &a, TTupleIsNullPredicate &b) {
  using ::std::swap;
  swap(a.tuple_ids, b.tuple_ids);
}

TTupleIsNullPredicate::TTupleIsNullPredicate(const TTupleIsNullPredicate& other46) {
  tuple_ids = other46.tuple_ids;
}
TTupleIsNullPredicate::TTupleIsNullPredicate( TTupleIsNullPredicate&& other47) {
  tuple_ids = std::move(other47.tuple_ids);
}
TTupleIsNullPredicate& TTupleIsNullPredicate::operator=(const TTupleIsNullPredicate& other48) {
  tuple_ids = other48.tuple_ids;
  return *this;
}
TTupleIsNullPredicate& TTupleIsNullPredicate::operator=(TTupleIsNullPredicate&& other49) {
  tuple_ids = std::move(other49.tuple_ids);
  return *this;
}
void TTupleIsNullPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTupleIsNullPredicate(";
  out << "tuple_ids=" << to_string(tuple_ids);
  out << ")";
}


TSlotRef::~TSlotRef() throw() {
}


void TSlotRef::__set_slot_id(const  ::impala::TSlotId val) {
  this->slot_id = val;
}
std::ostream& operator<<(std::ostream& out, const TSlotRef& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TSlotRef &a, TSlotRef &b) {
  using ::std::swap;
  swap(a.slot_id, b.slot_id);
}

TSlotRef::TSlotRef(const TSlotRef& other50) {
  slot_id = other50.slot_id;
}
TSlotRef::TSlotRef( TSlotRef&& other51) {
  slot_id = std::move(other51.slot_id);
}
TSlotRef& TSlotRef::operator=(const TSlotRef& other52) {
  slot_id = other52.slot_id;
  return *this;
}
TSlotRef& TSlotRef::operator=(TSlotRef&& other53) {
  slot_id = std::move(other53.slot_id);
  return *this;
}
void TSlotRef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSlotRef(";
  out << "slot_id=" << to_string(slot_id);
  out << ")";
}


TStringLiteral::~TStringLiteral() throw() {
}


void TStringLiteral::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TStringLiteral& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TStringLiteral &a, TStringLiteral &b) {
  using ::std::swap;
  swap(a.value, b.value);
}

TStringLiteral::TStringLiteral(const TStringLiteral& other54) {
  value = other54.value;
}
TStringLiteral::TStringLiteral( TStringLiteral&& other55) {
  value = std::move(other55.value);
}
TStringLiteral& TStringLiteral::operator=(const TStringLiteral& other56) {
  value = other56.value;
  return *this;
}
TStringLiteral& TStringLiteral::operator=(TStringLiteral&& other57) {
  value = std::move(other57.value);
  return *this;
}
void TStringLiteral::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStringLiteral(";
  out << "value=" << to_string(value);
  out << ")";
}


TAggregateExpr::~TAggregateExpr() throw() {
}


void TAggregateExpr::__set_is_merge_agg(const bool val) {
  this->is_merge_agg = val;
}

void TAggregateExpr::__set_arg_types(const std::vector< ::impala::TColumnType> & val) {
  this->arg_types = val;
}
std::ostream& operator<<(std::ostream& out, const TAggregateExpr& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAggregateExpr &a, TAggregateExpr &b) {
  using ::std::swap;
  swap(a.is_merge_agg, b.is_merge_agg);
  swap(a.arg_types, b.arg_types);
}

TAggregateExpr::TAggregateExpr(const TAggregateExpr& other64) {
  is_merge_agg = other64.is_merge_agg;
  arg_types = other64.arg_types;
}
TAggregateExpr::TAggregateExpr( TAggregateExpr&& other65) {
  is_merge_agg = std::move(other65.is_merge_agg);
  arg_types = std::move(other65.arg_types);
}
TAggregateExpr& TAggregateExpr::operator=(const TAggregateExpr& other66) {
  is_merge_agg = other66.is_merge_agg;
  arg_types = other66.arg_types;
  return *this;
}
TAggregateExpr& TAggregateExpr::operator=(TAggregateExpr&& other67) {
  is_merge_agg = std::move(other67.is_merge_agg);
  arg_types = std::move(other67.arg_types);
  return *this;
}
void TAggregateExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregateExpr(";
  out << "is_merge_agg=" << to_string(is_merge_agg);
  out << ", " << "arg_types=" << to_string(arg_types);
  out << ")";
}


TKuduPartitionExpr::~TKuduPartitionExpr() throw() {
}


void TKuduPartitionExpr::__set_target_table_id(const  ::impala::TTableId val) {
  this->target_table_id = val;
}

void TKuduPartitionExpr::__set_referenced_columns(const std::vector<int32_t> & val) {
  this->referenced_columns = val;
}
std::ostream& operator<<(std::ostream& out, const TKuduPartitionExpr& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TKuduPartitionExpr &a, TKuduPartitionExpr &b) {
  using ::std::swap;
  swap(a.target_table_id, b.target_table_id);
  swap(a.referenced_columns, b.referenced_columns);
}

TKuduPartitionExpr::TKuduPartitionExpr(const TKuduPartitionExpr& other74) {
  target_table_id = other74.target_table_id;
  referenced_columns = other74.referenced_columns;
}
TKuduPartitionExpr::TKuduPartitionExpr( TKuduPartitionExpr&& other75) {
  target_table_id = std::move(other75.target_table_id);
  referenced_columns = std::move(other75.referenced_columns);
}
TKuduPartitionExpr& TKuduPartitionExpr::operator=(const TKuduPartitionExpr& other76) {
  target_table_id = other76.target_table_id;
  referenced_columns = other76.referenced_columns;
  return *this;
}
TKuduPartitionExpr& TKuduPartitionExpr::operator=(TKuduPartitionExpr&& other77) {
  target_table_id = std::move(other77.target_table_id);
  referenced_columns = std::move(other77.referenced_columns);
  return *this;
}
void TKuduPartitionExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionExpr(";
  out << "target_table_id=" << to_string(target_table_id);
  out << ", " << "referenced_columns=" << to_string(referenced_columns);
  out << ")";
}


TCastExpr::~TCastExpr() throw() {
}


void TCastExpr::__set_cast_format(const std::string& val) {
  this->cast_format = val;
}
std::ostream& operator<<(std::ostream& out, const TCastExpr& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCastExpr &a, TCastExpr &b) {
  using ::std::swap;
  swap(a.cast_format, b.cast_format);
}

TCastExpr::TCastExpr(const TCastExpr& other78) {
  cast_format = other78.cast_format;
}
TCastExpr::TCastExpr( TCastExpr&& other79) {
  cast_format = std::move(other79.cast_format);
}
TCastExpr& TCastExpr::operator=(const TCastExpr& other80) {
  cast_format = other80.cast_format;
  return *this;
}
TCastExpr& TCastExpr::operator=(TCastExpr&& other81) {
  cast_format = std::move(other81.cast_format);
  return *this;
}
void TCastExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCastExpr(";
  out << "cast_format=" << to_string(cast_format);
  out << ")";
}


TExprNode::~TExprNode() throw() {
}


void TExprNode::__set_node_type(const TExprNodeType::type val) {
  this->node_type = val;
}

void TExprNode::__set_type(const  ::impala::TColumnType& val) {
  this->type = val;
}

void TExprNode::__set_num_children(const int32_t val) {
  this->num_children = val;
}

void TExprNode::__set_is_constant(const bool val) {
  this->is_constant = val;
}

void TExprNode::__set_fn(const  ::impala::TFunction& val) {
  this->fn = val;
__isset.fn = true;
}

void TExprNode::__set_vararg_start_idx(const int32_t val) {
  this->vararg_start_idx = val;
__isset.vararg_start_idx = true;
}

void TExprNode::__set_bool_literal(const TBoolLiteral& val) {
  this->bool_literal = val;
__isset.bool_literal = true;
}

void TExprNode::__set_case_expr(const TCaseExpr& val) {
  this->case_expr = val;
__isset.case_expr = true;
}

void TExprNode::__set_date_literal(const TDateLiteral& val) {
  this->date_literal = val;
__isset.date_literal = true;
}

void TExprNode::__set_float_literal(const TFloatLiteral& val) {
  this->float_literal = val;
__isset.float_literal = true;
}

void TExprNode::__set_int_literal(const TIntLiteral& val) {
  this->int_literal = val;
__isset.int_literal = true;
}

void TExprNode::__set_in_predicate(const TInPredicate& val) {
  this->in_predicate = val;
__isset.in_predicate = true;
}

void TExprNode::__set_is_null_pred(const TIsNullPredicate& val) {
  this->is_null_pred = val;
__isset.is_null_pred = true;
}

void TExprNode::__set_literal_pred(const TLiteralPredicate& val) {
  this->literal_pred = val;
__isset.literal_pred = true;
}

void TExprNode::__set_slot_ref(const TSlotRef& val) {
  this->slot_ref = val;
__isset.slot_ref = true;
}

void TExprNode::__set_string_literal(const TStringLiteral& val) {
  this->string_literal = val;
__isset.string_literal = true;
}

void TExprNode::__set_tuple_is_null_pred(const TTupleIsNullPredicate& val) {
  this->tuple_is_null_pred = val;
__isset.tuple_is_null_pred = true;
}

void TExprNode::__set_decimal_literal(const TDecimalLiteral& val) {
  this->decimal_literal = val;
__isset.decimal_literal = true;
}

void TExprNode::__set_agg_expr(const TAggregateExpr& val) {
  this->agg_expr = val;
__isset.agg_expr = true;
}

void TExprNode::__set_timestamp_literal(const TTimestampLiteral& val) {
  this->timestamp_literal = val;
__isset.timestamp_literal = true;
}

void TExprNode::__set_kudu_partition_expr(const TKuduPartitionExpr& val) {
  this->kudu_partition_expr = val;
__isset.kudu_partition_expr = true;
}

void TExprNode::__set_cast_expr(const TCastExpr& val) {
  this->cast_expr = val;
__isset.cast_expr = true;
}
std::ostream& operator<<(std::ostream& out, const TExprNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TExprNode &a, TExprNode &b) {
  using ::std::swap;
  swap(a.node_type, b.node_type);
  swap(a.type, b.type);
  swap(a.num_children, b.num_children);
  swap(a.is_constant, b.is_constant);
  swap(a.fn, b.fn);
  swap(a.vararg_start_idx, b.vararg_start_idx);
  swap(a.bool_literal, b.bool_literal);
  swap(a.case_expr, b.case_expr);
  swap(a.date_literal, b.date_literal);
  swap(a.float_literal, b.float_literal);
  swap(a.int_literal, b.int_literal);
  swap(a.in_predicate, b.in_predicate);
  swap(a.is_null_pred, b.is_null_pred);
  swap(a.literal_pred, b.literal_pred);
  swap(a.slot_ref, b.slot_ref);
  swap(a.string_literal, b.string_literal);
  swap(a.tuple_is_null_pred, b.tuple_is_null_pred);
  swap(a.decimal_literal, b.decimal_literal);
  swap(a.agg_expr, b.agg_expr);
  swap(a.timestamp_literal, b.timestamp_literal);
  swap(a.kudu_partition_expr, b.kudu_partition_expr);
  swap(a.cast_expr, b.cast_expr);
  swap(a.__isset, b.__isset);
}

TExprNode::TExprNode(const TExprNode& other83) {
  node_type = other83.node_type;
  type = other83.type;
  num_children = other83.num_children;
  is_constant = other83.is_constant;
  fn = other83.fn;
  vararg_start_idx = other83.vararg_start_idx;
  bool_literal = other83.bool_literal;
  case_expr = other83.case_expr;
  date_literal = other83.date_literal;
  float_literal = other83.float_literal;
  int_literal = other83.int_literal;
  in_predicate = other83.in_predicate;
  is_null_pred = other83.is_null_pred;
  literal_pred = other83.literal_pred;
  slot_ref = other83.slot_ref;
  string_literal = other83.string_literal;
  tuple_is_null_pred = other83.tuple_is_null_pred;
  decimal_literal = other83.decimal_literal;
  agg_expr = other83.agg_expr;
  timestamp_literal = other83.timestamp_literal;
  kudu_partition_expr = other83.kudu_partition_expr;
  cast_expr = other83.cast_expr;
  __isset = other83.__isset;
}
TExprNode::TExprNode( TExprNode&& other84) {
  node_type = std::move(other84.node_type);
  type = std::move(other84.type);
  num_children = std::move(other84.num_children);
  is_constant = std::move(other84.is_constant);
  fn = std::move(other84.fn);
  vararg_start_idx = std::move(other84.vararg_start_idx);
  bool_literal = std::move(other84.bool_literal);
  case_expr = std::move(other84.case_expr);
  date_literal = std::move(other84.date_literal);
  float_literal = std::move(other84.float_literal);
  int_literal = std::move(other84.int_literal);
  in_predicate = std::move(other84.in_predicate);
  is_null_pred = std::move(other84.is_null_pred);
  literal_pred = std::move(other84.literal_pred);
  slot_ref = std::move(other84.slot_ref);
  string_literal = std::move(other84.string_literal);
  tuple_is_null_pred = std::move(other84.tuple_is_null_pred);
  decimal_literal = std::move(other84.decimal_literal);
  agg_expr = std::move(other84.agg_expr);
  timestamp_literal = std::move(other84.timestamp_literal);
  kudu_partition_expr = std::move(other84.kudu_partition_expr);
  cast_expr = std::move(other84.cast_expr);
  __isset = std::move(other84.__isset);
}
TExprNode& TExprNode::operator=(const TExprNode& other85) {
  node_type = other85.node_type;
  type = other85.type;
  num_children = other85.num_children;
  is_constant = other85.is_constant;
  fn = other85.fn;
  vararg_start_idx = other85.vararg_start_idx;
  bool_literal = other85.bool_literal;
  case_expr = other85.case_expr;
  date_literal = other85.date_literal;
  float_literal = other85.float_literal;
  int_literal = other85.int_literal;
  in_predicate = other85.in_predicate;
  is_null_pred = other85.is_null_pred;
  literal_pred = other85.literal_pred;
  slot_ref = other85.slot_ref;
  string_literal = other85.string_literal;
  tuple_is_null_pred = other85.tuple_is_null_pred;
  decimal_literal = other85.decimal_literal;
  agg_expr = other85.agg_expr;
  timestamp_literal = other85.timestamp_literal;
  kudu_partition_expr = other85.kudu_partition_expr;
  cast_expr = other85.cast_expr;
  __isset = other85.__isset;
  return *this;
}
TExprNode& TExprNode::operator=(TExprNode&& other86) {
  node_type = std::move(other86.node_type);
  type = std::move(other86.type);
  num_children = std::move(other86.num_children);
  is_constant = std::move(other86.is_constant);
  fn = std::move(other86.fn);
  vararg_start_idx = std::move(other86.vararg_start_idx);
  bool_literal = std::move(other86.bool_literal);
  case_expr = std::move(other86.case_expr);
  date_literal = std::move(other86.date_literal);
  float_literal = std::move(other86.float_literal);
  int_literal = std::move(other86.int_literal);
  in_predicate = std::move(other86.in_predicate);
  is_null_pred = std::move(other86.is_null_pred);
  literal_pred = std::move(other86.literal_pred);
  slot_ref = std::move(other86.slot_ref);
  string_literal = std::move(other86.string_literal);
  tuple_is_null_pred = std::move(other86.tuple_is_null_pred);
  decimal_literal = std::move(other86.decimal_literal);
  agg_expr = std::move(other86.agg_expr);
  timestamp_literal = std::move(other86.timestamp_literal);
  kudu_partition_expr = std::move(other86.kudu_partition_expr);
  cast_expr = std::move(other86.cast_expr);
  __isset = std::move(other86.__isset);
  return *this;
}
void TExprNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExprNode(";
  out << "node_type=" << to_string(node_type);
  out << ", " << "type=" << to_string(type);
  out << ", " << "num_children=" << to_string(num_children);
  out << ", " << "is_constant=" << to_string(is_constant);
  out << ", " << "fn="; (__isset.fn ? (out << to_string(fn)) : (out << "<null>"));
  out << ", " << "vararg_start_idx="; (__isset.vararg_start_idx ? (out << to_string(vararg_start_idx)) : (out << "<null>"));
  out << ", " << "bool_literal="; (__isset.bool_literal ? (out << to_string(bool_literal)) : (out << "<null>"));
  out << ", " << "case_expr="; (__isset.case_expr ? (out << to_string(case_expr)) : (out << "<null>"));
  out << ", " << "date_literal="; (__isset.date_literal ? (out << to_string(date_literal)) : (out << "<null>"));
  out << ", " << "float_literal="; (__isset.float_literal ? (out << to_string(float_literal)) : (out << "<null>"));
  out << ", " << "int_literal="; (__isset.int_literal ? (out << to_string(int_literal)) : (out << "<null>"));
  out << ", " << "in_predicate="; (__isset.in_predicate ? (out << to_string(in_predicate)) : (out << "<null>"));
  out << ", " << "is_null_pred="; (__isset.is_null_pred ? (out << to_string(is_null_pred)) : (out << "<null>"));
  out << ", " << "literal_pred="; (__isset.literal_pred ? (out << to_string(literal_pred)) : (out << "<null>"));
  out << ", " << "slot_ref="; (__isset.slot_ref ? (out << to_string(slot_ref)) : (out << "<null>"));
  out << ", " << "string_literal="; (__isset.string_literal ? (out << to_string(string_literal)) : (out << "<null>"));
  out << ", " << "tuple_is_null_pred="; (__isset.tuple_is_null_pred ? (out << to_string(tuple_is_null_pred)) : (out << "<null>"));
  out << ", " << "decimal_literal="; (__isset.decimal_literal ? (out << to_string(decimal_literal)) : (out << "<null>"));
  out << ", " << "agg_expr="; (__isset.agg_expr ? (out << to_string(agg_expr)) : (out << "<null>"));
  out << ", " << "timestamp_literal="; (__isset.timestamp_literal ? (out << to_string(timestamp_literal)) : (out << "<null>"));
  out << ", " << "kudu_partition_expr="; (__isset.kudu_partition_expr ? (out << to_string(kudu_partition_expr)) : (out << "<null>"));
  out << ", " << "cast_expr="; (__isset.cast_expr ? (out << to_string(cast_expr)) : (out << "<null>"));
  out << ")";
}


TExpr::~TExpr() throw() {
}


void TExpr::__set_nodes(const std::vector<TExprNode> & val) {
  this->nodes = val;
}
std::ostream& operator<<(std::ostream& out, const TExpr& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TExpr &a, TExpr &b) {
  using ::std::swap;
  swap(a.nodes, b.nodes);
}

TExpr::TExpr(const TExpr& other93) {
  nodes = other93.nodes;
}
TExpr::TExpr( TExpr&& other94) {
  nodes = std::move(other94.nodes);
}
TExpr& TExpr::operator=(const TExpr& other95) {
  nodes = other95.nodes;
  return *this;
}
TExpr& TExpr::operator=(TExpr&& other96) {
  nodes = std::move(other96.nodes);
  return *this;
}
void TExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExpr(";
  out << "nodes=" << to_string(nodes);
  out << ")";
}


TExprBatch::~TExprBatch() throw() {
}


void TExprBatch::__set_exprs(const std::vector<TExpr> & val) {
  this->exprs = val;
}
std::ostream& operator<<(std::ostream& out, const TExprBatch& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TExprBatch &a, TExprBatch &b) {
  using ::std::swap;
  swap(a.exprs, b.exprs);
}

TExprBatch::TExprBatch(const TExprBatch& other103) {
  exprs = other103.exprs;
}
TExprBatch::TExprBatch( TExprBatch&& other104) {
  exprs = std::move(other104.exprs);
}
TExprBatch& TExprBatch::operator=(const TExprBatch& other105) {
  exprs = other105.exprs;
  return *this;
}
TExprBatch& TExprBatch::operator=(TExprBatch&& other106) {
  exprs = std::move(other106.exprs);
  return *this;
}
void TExprBatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExprBatch(";
  out << "exprs=" << to_string(exprs);
  out << ")";
}

} // namespace
