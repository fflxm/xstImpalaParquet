/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Descriptors_TYPES_TCC
#define Descriptors_TYPES_TCC

#include "CatalogObjects_types.tcc"
#include "Types_types.tcc"
#include "Exprs_types.tcc"
#include "Descriptors_types.h"

namespace impala {

template <class Protocol_>
uint32_t TSlotDescriptor::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_parent = false;
  bool isset_slotType = false;
  bool isset_materializedPath = false;
  bool isset_byteOffset = false;
  bool isset_nullIndicatorByte = false;
  bool isset_nullIndicatorBit = false;
  bool isset_slotIdx = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent);
          isset_parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemTupleId);
          this->__isset.itemTupleId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->slotType.read(iprot);
          isset_slotType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->materializedPath.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->materializedPath.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->materializedPath[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_materializedPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->byteOffset);
          isset_byteOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nullIndicatorByte);
          isset_nullIndicatorByte = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nullIndicatorBit);
          isset_nullIndicatorBit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->slotIdx);
          isset_slotIdx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slotType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_materializedPath)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_byteOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullIndicatorByte)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullIndicatorBit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slotIdx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TSlotDescriptor::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSlotDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->parent);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.itemTupleId) {
    xfer += oprot->writeFieldBegin("itemTupleId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->itemTupleId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("slotType", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->slotType.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("materializedPath", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->materializedPath.size()));
    std::vector<int32_t> ::const_iterator _iter5;
    for (_iter5 = this->materializedPath.begin(); _iter5 != this->materializedPath.end(); ++_iter5)
    {
      xfer += oprot->writeI32((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteOffset", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->byteOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullIndicatorByte", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->nullIndicatorByte);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullIndicatorBit", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->nullIndicatorBit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slotIdx", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->slotIdx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TColumnDescriptor::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->icebergFieldId);
          this->__isset.icebergFieldId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->icebergFieldMapKeyId);
          this->__isset.icebergFieldMapKeyId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->icebergFieldMapValueId);
          this->__isset.icebergFieldMapValueId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TColumnDescriptor::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnDescriptor");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.icebergFieldId) {
    xfer += oprot->writeFieldBegin("icebergFieldId", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->icebergFieldId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.icebergFieldMapKeyId) {
    xfer += oprot->writeFieldBegin("icebergFieldMapKeyId", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->icebergFieldMapKeyId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.icebergFieldMapValueId) {
    xfer += oprot->writeFieldBegin("icebergFieldMapValueId", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->icebergFieldMapValueId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableDescriptor::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_tableType = false;
  bool isset_columnDescriptors = false;
  bool isset_numClusteringCols = false;
  bool isset_tableName = false;
  bool isset_dbName = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->tableType = ( ::impala::TTableType::type)ecast14;
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnDescriptors.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->columnDescriptors.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += this->columnDescriptors[_i19].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columnDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numClusteringCols);
          isset_numClusteringCols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfsTable.read(iprot);
          this->__isset.hdfsTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbaseTable.read(iprot);
          this->__isset.hbaseTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataSourceTable.read(iprot);
          this->__isset.dataSourceTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kuduTable.read(iprot);
          this->__isset.kuduTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->icebergTable.read(iprot);
          this->__isset.icebergTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dbName);
          isset_dbName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnDescriptors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numClusteringCols)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dbName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTableDescriptor::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnDescriptors", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columnDescriptors.size()));
    std::vector<TColumnDescriptor> ::const_iterator _iter20;
    for (_iter20 = this->columnDescriptors.begin(); _iter20 != this->columnDescriptors.end(); ++_iter20)
    {
      xfer += (*_iter20).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numClusteringCols", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->numClusteringCols);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hdfsTable) {
    xfer += oprot->writeFieldBegin("hdfsTable", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->hdfsTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbaseTable) {
    xfer += oprot->writeFieldBegin("hbaseTable", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->hbaseTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dbName", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->dbName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.dataSourceTable) {
    xfer += oprot->writeFieldBegin("dataSourceTable", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->dataSourceTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kuduTable) {
    xfer += oprot->writeFieldBegin("kuduTable", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->kuduTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.icebergTable) {
    xfer += oprot->writeFieldBegin("icebergTable", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->icebergTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTupleDescriptor::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_byteSize = false;
  bool isset_numNullBytes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->byteSize);
          isset_byteSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numNullBytes);
          isset_numNullBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tableId);
          this->__isset.tableId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tuplePath.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->tuplePath.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += iprot->readI32(this->tuplePath[_i29]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tuplePath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_byteSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_numNullBytes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTupleDescriptor::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTupleDescriptor");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("byteSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->byteSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numNullBytes", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->numNullBytes);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableId) {
    xfer += oprot->writeFieldBegin("tableId", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->tableId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tuplePath) {
    xfer += oprot->writeFieldBegin("tuplePath", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->tuplePath.size()));
      std::vector<int32_t> ::const_iterator _iter30;
      for (_iter30 = this->tuplePath.begin(); _iter30 != this->tuplePath.end(); ++_iter30)
      {
        xfer += oprot->writeI32((*_iter30));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDescriptorTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tupleDescriptors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->slotDescriptors.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->slotDescriptors.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->slotDescriptors[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.slotDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tupleDescriptors.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->tupleDescriptors.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->tupleDescriptors[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_tupleDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tableDescriptors.clear();
            uint32_t _size45;
            ::apache::thrift::protocol::TType _etype48;
            xfer += iprot->readListBegin(_etype48, _size45);
            this->tableDescriptors.resize(_size45);
            uint32_t _i49;
            for (_i49 = 0; _i49 < _size45; ++_i49)
            {
              xfer += this->tableDescriptors[_i49].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tableDescriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tupleDescriptors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDescriptorTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescriptorTable");

  if (this->__isset.slotDescriptors) {
    xfer += oprot->writeFieldBegin("slotDescriptors", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->slotDescriptors.size()));
      std::vector<TSlotDescriptor> ::const_iterator _iter50;
      for (_iter50 = this->slotDescriptors.begin(); _iter50 != this->slotDescriptors.end(); ++_iter50)
      {
        xfer += (*_iter50).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tupleDescriptors", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tupleDescriptors.size()));
    std::vector<TTupleDescriptor> ::const_iterator _iter51;
    for (_iter51 = this->tupleDescriptors.begin(); _iter51 != this->tupleDescriptors.end(); ++_iter51)
    {
      xfer += (*_iter51).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tableDescriptors) {
    xfer += oprot->writeFieldBegin("tableDescriptors", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tableDescriptors.size()));
      std::vector<TTableDescriptor> ::const_iterator _iter52;
      for (_iter52 = this->tableDescriptors.begin(); _iter52 != this->tableDescriptors.end(); ++_iter52)
      {
        xfer += (*_iter52).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDescriptorTableSerialized::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_thrift_desc_tbl = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->thrift_desc_tbl);
          isset_thrift_desc_tbl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_thrift_desc_tbl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDescriptorTableSerialized::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescriptorTableSerialized");

  xfer += oprot->writeFieldBegin("thrift_desc_tbl", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->thrift_desc_tbl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
