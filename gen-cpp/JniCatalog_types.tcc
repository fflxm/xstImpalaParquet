/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef JniCatalog_TYPES_TCC
#define JniCatalog_TYPES_TCC

#include "CatalogObjects_types.tcc"
#include "Types_types.tcc"
#include "Status_types.tcc"
#include "TCLIService_types.tcc"
#include "hive_metastore_types.tcc"
#include "JniCatalog_types.h"

namespace impala {

template <class Protocol_>
uint32_t TAlterDbSetOwnerParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_owner_type = false;
  bool isset_owner_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->owner_type = (TOwnerType::type)ecast0;
          isset_owner_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner_name);
          isset_owner_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_owner_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterDbSetOwnerParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterDbSetOwnerParams");

  xfer += oprot->writeFieldBegin("owner_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->owner_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->owner_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterDbParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_alter_type = false;
  bool isset_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->alter_type = (TAlterDbType::type)ecast5;
          isset_alter_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_owner_params.read(iprot);
          this->__isset.set_owner_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_alter_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterDbParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterDbParams");

  xfer += oprot->writeFieldBegin("alter_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->alter_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.set_owner_params) {
    xfer += oprot->writeFieldBegin("set_owner_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->set_owner_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateDbParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;
  bool isset_owner = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->managed_location);
          this->__isset.managed_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateDbParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateDbParams");

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.if_not_exists) {
    xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->if_not_exists);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.managed_location) {
    xfer += oprot->writeFieldBegin("managed_location", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->managed_location);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateDataSourceParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data_source = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source.read(iprot);
          isset_data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateDataSourceParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateDataSourceParams");

  xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data_source.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.if_not_exists) {
    xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->if_not_exists);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDropDataSourceParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data_source = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data_source);
          isset_data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          this->__isset.if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDropDataSourceParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropDataSourceParams");

  xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->data_source);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.if_exists) {
    xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->if_exists);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDropStatsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->partition_set.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              {
                this->partition_set[_i26].clear();
                uint32_t _size27;
                ::apache::thrift::protocol::TType _etype30;
                xfer += iprot->readListBegin(_etype30, _size27);
                this->partition_set[_i26].resize(_size27);
                uint32_t _i31;
                for (_i31 = 0; _i31 < _size27; ++_i31)
                {
                  xfer += this->partition_set[_i26][_i31].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDropStatsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropStatsParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter32;
      for (_iter32 = this->partition_set.begin(); _iter32 != this->partition_set.end(); ++_iter32)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter32).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter33;
          for (_iter33 = (*_iter32).begin(); _iter33 != (*_iter32).end(); ++_iter33)
          {
            xfer += (*_iter33).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateFunctionParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fn = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          isset_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateFunctionParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateFunctionParams");

  xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fn.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.if_not_exists) {
    xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->if_not_exists);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableRowFormat::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field_terminator);
          this->__isset.field_terminator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->line_terminator);
          this->__isset.line_terminator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->escaped_by);
          this->__isset.escaped_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TTableRowFormat::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableRowFormat");

  if (this->__isset.field_terminator) {
    xfer += oprot->writeFieldBegin("field_terminator", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->field_terminator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.line_terminator) {
    xfer += oprot->writeFieldBegin("line_terminator", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->line_terminator);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.escaped_by) {
    xfer += oprot->writeFieldBegin("escaped_by", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->escaped_by);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsCachingOp::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_set_cached = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->set_cached);
          isset_set_cached = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cache_pool_name);
          this->__isset.cache_pool_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->replication);
          this->__isset.replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_set_cached)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsCachingOp::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsCachingOp");

  xfer += oprot->writeFieldBegin("set_cached", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->set_cached);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cache_pool_name) {
    xfer += oprot->writeFieldBegin("cache_pool_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cache_pool_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replication) {
    xfer += oprot->writeFieldBegin("replication", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->replication);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableOrViewRenameParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_new_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->new_table_name.read(iprot);
          isset_new_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_new_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableOrViewRenameParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableOrViewRenameParams");

  xfer += oprot->writeFieldBegin("new_table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->new_table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAddColsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_if_not_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->columns.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->columns[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAddColsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableAddColsParams");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::impala::TColumn> ::const_iterator _iter59;
    for (_iter59 = this->columns.begin(); _iter59 != this->columns.end(); ++_iter59)
    {
      xfer += (*_iter59).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableReplaceColsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->columns.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->columns[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableReplaceColsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableReplaceColsParams");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::impala::TColumn> ::const_iterator _iter69;
    for (_iter69 = this->columns.begin(); _iter69 != this->columns.end(); ++_iter69)
    {
      xfer += (*_iter69).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartitionDef::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_spec = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->partition_spec.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += this->partition_spec[_i78].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cache_op.read(iprot);
          this->__isset.cache_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPartitionDef::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartitionDef");

  xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
    std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter79;
    for (_iter79 = this->partition_spec.begin(); _iter79 != this->partition_spec.end(); ++_iter79)
    {
      xfer += (*_iter79).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_op) {
    xfer += oprot->writeFieldBegin("cache_op", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->cache_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAddPartitionParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_if_not_exists = false;
  bool isset_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->partitions.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += this->partitions[_i88].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAddPartitionParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableAddPartitionParams");

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<TPartitionDef> ::const_iterator _iter89;
    for (_iter89 = this->partitions.begin(); _iter89 != this->partitions.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAddDropRangePartitionParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_range_partition_spec = false;
  bool isset_ignore_errors = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->range_partition_spec.read(iprot);
          isset_range_partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignore_errors);
          isset_ignore_errors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->type = (TRangePartitionOperationType::type)ecast94;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_range_partition_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ignore_errors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAddDropRangePartitionParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableAddDropRangePartitionParams");

  xfer += oprot->writeFieldBegin("range_partition_spec", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->range_partition_spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ignore_errors", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->ignore_errors);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableDropColParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_col_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          isset_col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_col_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableDropColParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableDropColParams");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableDropPartitionParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_set = false;
  bool isset_if_exists = false;
  bool isset_purge = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->partition_set.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              {
                this->partition_set[_i107].clear();
                uint32_t _size108;
                ::apache::thrift::protocol::TType _etype111;
                xfer += iprot->readListBegin(_etype111, _size108);
                this->partition_set[_i107].resize(_size108);
                uint32_t _i112;
                for (_i112 = 0; _i112 < _size108; ++_i112)
                {
                  xfer += this->partition_set[_i107][_i112].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge);
          isset_purge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_set)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_purge)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableDropPartitionParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableDropPartitionParams");

  xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
    std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter113;
    for (_iter113 = this->partition_set.begin(); _iter113 != this->partition_set.end(); ++_iter113)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter113).size()));
        std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter114;
        for (_iter114 = (*_iter113).begin(); _iter114 != (*_iter113).end(); ++_iter114)
        {
          xfer += (*_iter114).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("purge", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->purge);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAlterColParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_col_name = false;
  bool isset_new_col_def = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          isset_col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->new_col_def.read(iprot);
          isset_new_col_def = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_col_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_new_col_def)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableAlterColParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableAlterColParams");

  xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->col_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_col_def", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->new_col_def.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetTblPropertiesParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_target = false;
  bool isset_properties = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast123;
          xfer += iprot->readI32(ecast123);
          this->target = ( ::impala::TTablePropertyType::type)ecast123;
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readString(_key129);
              std::string& _val130 = this->properties[_key129];
              xfer += iprot->readString(_val130);
            }
            xfer += iprot->readMapEnd();
          }
          isset_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->partition_set.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              {
                this->partition_set[_i135].clear();
                uint32_t _size136;
                ::apache::thrift::protocol::TType _etype139;
                xfer += iprot->readListBegin(_etype139, _size136);
                this->partition_set[_i135].resize(_size136);
                uint32_t _i140;
                for (_i140 = 0; _i140 < _size136; ++_i140)
                {
                  xfer += this->partition_set[_i135][_i140].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetTblPropertiesParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableSetTblPropertiesParams");

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter141;
    for (_iter141 = this->properties.begin(); _iter141 != this->properties.end(); ++_iter141)
    {
      xfer += oprot->writeString(_iter141->first);
      xfer += oprot->writeString(_iter141->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter142;
      for (_iter142 = this->partition_set.begin(); _iter142 != this->partition_set.end(); ++_iter142)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter142).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter143;
          for (_iter143 = (*_iter142).begin(); _iter143 != (*_iter142).end(); ++_iter143)
          {
            xfer += (*_iter143).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetFileFormatParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_format = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast148;
          xfer += iprot->readI32(ecast148);
          this->file_format = ( ::impala::THdfsFileFormat::type)ecast148;
          isset_file_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size149;
            ::apache::thrift::protocol::TType _etype152;
            xfer += iprot->readListBegin(_etype152, _size149);
            this->partition_set.resize(_size149);
            uint32_t _i153;
            for (_i153 = 0; _i153 < _size149; ++_i153)
            {
              {
                this->partition_set[_i153].clear();
                uint32_t _size154;
                ::apache::thrift::protocol::TType _etype157;
                xfer += iprot->readListBegin(_etype157, _size154);
                this->partition_set[_i153].resize(_size154);
                uint32_t _i158;
                for (_i158 = 0; _i158 < _size154; ++_i158)
                {
                  xfer += this->partition_set[_i153][_i158].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_format)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetFileFormatParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableSetFileFormatParams");

  xfer += oprot->writeFieldBegin("file_format", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->file_format);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter159;
      for (_iter159 = this->partition_set.begin(); _iter159 != this->partition_set.end(); ++_iter159)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter159).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter160;
          for (_iter160 = (*_iter159).begin(); _iter160 != (*_iter159).end(); ++_iter160)
          {
            xfer += (*_iter160).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetRowFormatParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_row_format = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_format.read(iprot);
          isset_row_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size165;
            ::apache::thrift::protocol::TType _etype168;
            xfer += iprot->readListBegin(_etype168, _size165);
            this->partition_set.resize(_size165);
            uint32_t _i169;
            for (_i169 = 0; _i169 < _size165; ++_i169)
            {
              {
                this->partition_set[_i169].clear();
                uint32_t _size170;
                ::apache::thrift::protocol::TType _etype173;
                xfer += iprot->readListBegin(_etype173, _size170);
                this->partition_set[_i169].resize(_size170);
                uint32_t _i174;
                for (_i174 = 0; _i174 < _size170; ++_i174)
                {
                  xfer += this->partition_set[_i169][_i174].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_row_format)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetRowFormatParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableSetRowFormatParams");

  xfer += oprot->writeFieldBegin("row_format", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->row_format.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter175;
      for (_iter175 = this->partition_set.begin(); _iter175 != this->partition_set.end(); ++_iter175)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter175).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter176;
          for (_iter176 = (*_iter175).begin(); _iter176 != (*_iter175).end(); ++_iter176)
          {
            xfer += (*_iter176).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetLocationParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_location = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _etype184;
            xfer += iprot->readListBegin(_etype184, _size181);
            this->partition_spec.resize(_size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              xfer += this->partition_spec[_i185].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetLocationParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableSetLocationParams");

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_spec) {
    xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
      std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter186;
      for (_iter186 = this->partition_spec.begin(); _iter186 != this->partition_spec.end(); ++_iter186)
      {
        xfer += (*_iter186).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableOrViewSetOwnerParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_owner_type = false;
  bool isset_owner_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast191;
          xfer += iprot->readI32(ecast191);
          this->owner_type = (TOwnerType::type)ecast191;
          isset_owner_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner_name);
          isset_owner_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_owner_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableOrViewSetOwnerParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableOrViewSetOwnerParams");

  xfer += oprot->writeFieldBegin("owner_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->owner_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->owner_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableUpdateStatsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_stats.read(iprot);
          this->__isset.table_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partition_stats.clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _ktype197;
            ::apache::thrift::protocol::TType _vtype198;
            xfer += iprot->readMapBegin(_ktype197, _vtype198, _size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              std::vector<std::string>  _key201;
              {
                _key201.clear();
                uint32_t _size203;
                ::apache::thrift::protocol::TType _etype206;
                xfer += iprot->readListBegin(_etype206, _size203);
                _key201.resize(_size203);
                uint32_t _i207;
                for (_i207 = 0; _i207 < _size203; ++_i207)
                {
                  xfer += iprot->readString(_key201[_i207]);
                }
                xfer += iprot->readListEnd();
              }
               ::impala::TPartitionStats& _val202 = this->partition_stats[_key201];
              xfer += _val202.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.partition_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->column_stats.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _ktype209;
            ::apache::thrift::protocol::TType _vtype210;
            xfer += iprot->readMapBegin(_ktype209, _vtype210, _size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              std::string _key213;
              xfer += iprot->readString(_key213);
               ::impala::TColumnStats& _val214 = this->column_stats[_key213];
              xfer += _val214.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.column_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->expect_all_partitions);
          this->__isset.expect_all_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_incremental);
          this->__isset.is_incremental = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableUpdateStatsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableUpdateStatsParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.table_stats) {
    xfer += oprot->writeFieldBegin("table_stats", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->table_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_stats) {
    xfer += oprot->writeFieldBegin("partition_stats", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_LIST, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_stats.size()));
      std::map<std::vector<std::string> ,  ::impala::TPartitionStats> ::const_iterator _iter215;
      for (_iter215 = this->partition_stats.begin(); _iter215 != this->partition_stats.end(); ++_iter215)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(_iter215->first.size()));
          std::vector<std::string> ::const_iterator _iter216;
          for (_iter216 = _iter215->first.begin(); _iter216 != _iter215->first.end(); ++_iter216)
          {
            xfer += oprot->writeString((*_iter216));
          }
          xfer += oprot->writeListEnd();
        }
        xfer += _iter215->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_stats) {
    xfer += oprot->writeFieldBegin("column_stats", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_stats.size()));
      std::map<std::string,  ::impala::TColumnStats> ::const_iterator _iter217;
      for (_iter217 = this->column_stats.begin(); _iter217 != this->column_stats.end(); ++_iter217)
      {
        xfer += oprot->writeString(_iter217->first);
        xfer += _iter217->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expect_all_partitions) {
    xfer += oprot->writeFieldBegin("expect_all_partitions", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->expect_all_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_incremental) {
    xfer += oprot->writeFieldBegin("is_incremental", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_incremental);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetCachedParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cache_op = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cache_op.read(iprot);
          isset_cache_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size222;
            ::apache::thrift::protocol::TType _etype225;
            xfer += iprot->readListBegin(_etype225, _size222);
            this->partition_set.resize(_size222);
            uint32_t _i226;
            for (_i226 = 0; _i226 < _size222; ++_i226)
            {
              {
                this->partition_set[_i226].clear();
                uint32_t _size227;
                ::apache::thrift::protocol::TType _etype230;
                xfer += iprot->readListBegin(_etype230, _size227);
                this->partition_set[_i226].resize(_size227);
                uint32_t _i231;
                for (_i231 = 0; _i231 < _size227; ++_i231)
                {
                  xfer += this->partition_set[_i226][_i231].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cache_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetCachedParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableSetCachedParams");

  xfer += oprot->writeFieldBegin("cache_op", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cache_op.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter232;
      for (_iter232 = this->partition_set.begin(); _iter232 != this->partition_set.end(); ++_iter232)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter232).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter233;
          for (_iter233 = (*_iter232).begin(); _iter233 != (*_iter232).end(); ++_iter233)
          {
            xfer += (*_iter233).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableUnSetTblPropertiesParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_target = false;
  bool isset_property_keys = false;
  bool isset_if_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast238;
          xfer += iprot->readI32(ecast238);
          this->target = ( ::impala::TTablePropertyType::type)ecast238;
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->property_keys.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->property_keys.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += iprot->readString(this->property_keys[_i243]);
            }
            xfer += iprot->readListEnd();
          }
          isset_property_keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size244;
            ::apache::thrift::protocol::TType _etype247;
            xfer += iprot->readListBegin(_etype247, _size244);
            this->partition_set.resize(_size244);
            uint32_t _i248;
            for (_i248 = 0; _i248 < _size244; ++_i248)
            {
              {
                this->partition_set[_i248].clear();
                uint32_t _size249;
                ::apache::thrift::protocol::TType _etype252;
                xfer += iprot->readListBegin(_etype252, _size249);
                this->partition_set[_i248].resize(_size249);
                uint32_t _i253;
                for (_i253 = 0; _i253 < _size249; ++_i253)
                {
                  xfer += this->partition_set[_i248][_i253].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_property_keys)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableUnSetTblPropertiesParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableUnSetTblPropertiesParams");

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property_keys", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->property_keys.size()));
    std::vector<std::string> ::const_iterator _iter254;
    for (_iter254 = this->property_keys.begin(); _iter254 != this->property_keys.end(); ++_iter254)
    {
      xfer += oprot->writeString((*_iter254));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter255;
      for (_iter255 = this->partition_set.begin(); _iter255 != this->partition_set.end(); ++_iter255)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter255).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter256;
          for (_iter256 = (*_iter255).begin(); _iter256 != (*_iter255).end(); ++_iter256)
          {
            xfer += (*_iter256).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetPartitionSpecParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_spec = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_spec.read(iprot);
          isset_partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableSetPartitionSpecParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableSetPartitionSpecParams");

  xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->partition_spec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_alter_type = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast265;
          xfer += iprot->readI32(ecast265);
          this->alter_type = (TAlterTableType::type)ecast265;
          isset_alter_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rename_params.read(iprot);
          this->__isset.rename_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->add_cols_params.read(iprot);
          this->__isset.add_cols_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->add_partition_params.read(iprot);
          this->__isset.add_partition_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_col_params.read(iprot);
          this->__isset.alter_col_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_col_params.read(iprot);
          this->__isset.drop_col_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_partition_params.read(iprot);
          this->__isset.drop_partition_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_file_format_params.read(iprot);
          this->__isset.set_file_format_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_location_params.read(iprot);
          this->__isset.set_location_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_tbl_properties_params.read(iprot);
          this->__isset.set_tbl_properties_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_stats_params.read(iprot);
          this->__isset.update_stats_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_cached_params.read(iprot);
          this->__isset.set_cached_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->add_drop_range_partition_params.read(iprot);
          this->__isset.add_drop_range_partition_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_row_format_params.read(iprot);
          this->__isset.set_row_format_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_owner_params.read(iprot);
          this->__isset.set_owner_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->replace_cols_params.read(iprot);
          this->__isset.replace_cols_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->unset_tbl_properties_params.read(iprot);
          this->__isset.unset_tbl_properties_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_partition_spec_params.read(iprot);
          this->__isset.set_partition_spec_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_alter_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAlterTableParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAlterTableParams");

  xfer += oprot->writeFieldBegin("alter_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->alter_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rename_params) {
    xfer += oprot->writeFieldBegin("rename_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->rename_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_cols_params) {
    xfer += oprot->writeFieldBegin("add_cols_params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->add_cols_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_partition_params) {
    xfer += oprot->writeFieldBegin("add_partition_params", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->add_partition_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alter_col_params) {
    xfer += oprot->writeFieldBegin("alter_col_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->alter_col_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_col_params) {
    xfer += oprot->writeFieldBegin("drop_col_params", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->drop_col_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_partition_params) {
    xfer += oprot->writeFieldBegin("drop_partition_params", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->drop_partition_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_file_format_params) {
    xfer += oprot->writeFieldBegin("set_file_format_params", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->set_file_format_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_location_params) {
    xfer += oprot->writeFieldBegin("set_location_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->set_location_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_tbl_properties_params) {
    xfer += oprot->writeFieldBegin("set_tbl_properties_params", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->set_tbl_properties_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_stats_params) {
    xfer += oprot->writeFieldBegin("update_stats_params", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->update_stats_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_cached_params) {
    xfer += oprot->writeFieldBegin("set_cached_params", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->set_cached_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.add_drop_range_partition_params) {
    xfer += oprot->writeFieldBegin("add_drop_range_partition_params", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->add_drop_range_partition_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_row_format_params) {
    xfer += oprot->writeFieldBegin("set_row_format_params", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->set_row_format_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_owner_params) {
    xfer += oprot->writeFieldBegin("set_owner_params", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->set_owner_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.replace_cols_params) {
    xfer += oprot->writeFieldBegin("replace_cols_params", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->replace_cols_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.unset_tbl_properties_params) {
    xfer += oprot->writeFieldBegin("unset_tbl_properties_params", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->unset_tbl_properties_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_partition_spec_params) {
    xfer += oprot->writeFieldBegin("set_partition_spec_params", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->set_partition_spec_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateTableLikeParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_src_table_name = false;
  bool isset_is_external = false;
  bool isset_if_not_exists = false;
  bool isset_owner = false;
  bool isset_sorting_order = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->src_table_name.read(iprot);
          isset_src_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_external);
          isset_is_external = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast270;
          xfer += iprot->readI32(ecast270);
          this->file_format = ( ::impala::THdfsFileFormat::type)ecast270;
          this->__isset.file_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_columns.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->sort_columns.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += iprot->readString(this->sort_columns[_i275]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast276;
          xfer += iprot->readI32(ecast276);
          this->sorting_order = ( ::impala::TSortingOrder::type)ecast276;
          isset_sorting_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_src_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_external)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sorting_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateTableLikeParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateTableLikeParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src_table_name", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->src_table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_external", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_external);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_format) {
    xfer += oprot->writeFieldBegin("file_format", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->file_format);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_columns) {
    xfer += oprot->writeFieldBegin("sort_columns", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sort_columns.size()));
      std::vector<std::string> ::const_iterator _iter277;
      for (_iter277 = this->sort_columns.begin(); _iter277 != this->sort_columns.end(); ++_iter277)
      {
        xfer += oprot->writeString((*_iter277));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sorting_order", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32((int32_t)this->sorting_order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateTableParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_columns = false;
  bool isset_file_format = false;
  bool isset_is_external = false;
  bool isset_if_not_exists = false;
  bool isset_owner = false;
  bool isset_sorting_order = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _etype285;
            xfer += iprot->readListBegin(_etype285, _size282);
            this->columns.resize(_size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              xfer += this->columns[_i286].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_columns.clear();
            uint32_t _size287;
            ::apache::thrift::protocol::TType _etype290;
            xfer += iprot->readListBegin(_etype290, _size287);
            this->partition_columns.resize(_size287);
            uint32_t _i291;
            for (_i291 = 0; _i291 < _size287; ++_i291)
            {
              xfer += this->partition_columns[_i291].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast292;
          xfer += iprot->readI32(ecast292);
          this->file_format = ( ::impala::THdfsFileFormat::type)ecast292;
          isset_file_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_external);
          isset_is_external = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          isset_if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->row_format.read(iprot);
          this->__isset.row_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->table_properties.clear();
            uint32_t _size293;
            ::apache::thrift::protocol::TType _ktype294;
            ::apache::thrift::protocol::TType _vtype295;
            xfer += iprot->readMapBegin(_ktype294, _vtype295, _size293);
            uint32_t _i297;
            for (_i297 = 0; _i297 < _size293; ++_i297)
            {
              std::string _key298;
              xfer += iprot->readString(_key298);
              std::string& _val299 = this->table_properties[_key298];
              xfer += iprot->readString(_val299);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.table_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->serde_properties.clear();
            uint32_t _size300;
            ::apache::thrift::protocol::TType _ktype301;
            ::apache::thrift::protocol::TType _vtype302;
            xfer += iprot->readMapBegin(_ktype301, _vtype302, _size300);
            uint32_t _i304;
            for (_i304 = 0; _i304 < _size300; ++_i304)
            {
              std::string _key305;
              xfer += iprot->readString(_key305);
              std::string& _val306 = this->serde_properties[_key305];
              xfer += iprot->readString(_val306);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.serde_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cache_op.read(iprot);
          this->__isset.cache_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_by.clear();
            uint32_t _size307;
            ::apache::thrift::protocol::TType _etype310;
            xfer += iprot->readListBegin(_etype310, _size307);
            this->partition_by.resize(_size307);
            uint32_t _i311;
            for (_i311 = 0; _i311 < _size307; ++_i311)
            {
              xfer += this->partition_by[_i311].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primary_key_column_names.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->primary_key_column_names.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              xfer += iprot->readString(this->primary_key_column_names[_i316]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.primary_key_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sort_columns.clear();
            uint32_t _size317;
            ::apache::thrift::protocol::TType _etype320;
            xfer += iprot->readListBegin(_etype320, _size317);
            this->sort_columns.resize(_size317);
            uint32_t _i321;
            for (_i321 = 0; _i321 < _size317; ++_i321)
            {
              xfer += iprot->readString(this->sort_columns[_i321]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.sort_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast322;
          xfer += iprot->readI32(ecast322);
          this->sorting_order = ( ::impala::TSortingOrder::type)ecast322;
          isset_sorting_order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primary_keys.clear();
            uint32_t _size323;
            ::apache::thrift::protocol::TType _etype326;
            xfer += iprot->readListBegin(_etype326, _size323);
            this->primary_keys.resize(_size323);
            uint32_t _i327;
            for (_i327 = 0; _i327 < _size323; ++_i327)
            {
              xfer += this->primary_keys[_i327].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.primary_keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->foreign_keys.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _etype331;
            xfer += iprot->readListBegin(_etype331, _size328);
            this->foreign_keys.resize(_size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              xfer += this->foreign_keys[_i332].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.foreign_keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->partition_spec.read(iprot);
          this->__isset.partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_file_format)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_external)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_not_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sorting_order)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateTableParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateTableParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::impala::TColumn> ::const_iterator _iter333;
    for (_iter333 = this->columns.begin(); _iter333 != this->columns.end(); ++_iter333)
    {
      xfer += (*_iter333).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_columns) {
    xfer += oprot->writeFieldBegin("partition_columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_columns.size()));
      std::vector< ::impala::TColumn> ::const_iterator _iter334;
      for (_iter334 = this->partition_columns.begin(); _iter334 != this->partition_columns.end(); ++_iter334)
      {
        xfer += (*_iter334).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("file_format", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->file_format);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_external", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_external);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->if_not_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.row_format) {
    xfer += oprot->writeFieldBegin("row_format", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->row_format.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->location);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_properties) {
    xfer += oprot->writeFieldBegin("table_properties", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->table_properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter335;
      for (_iter335 = this->table_properties.begin(); _iter335 != this->table_properties.end(); ++_iter335)
      {
        xfer += oprot->writeString(_iter335->first);
        xfer += oprot->writeString(_iter335->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serde_properties) {
    xfer += oprot->writeFieldBegin("serde_properties", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->serde_properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter336;
      for (_iter336 = this->serde_properties.begin(); _iter336 != this->serde_properties.end(); ++_iter336)
      {
        xfer += oprot->writeString(_iter336->first);
        xfer += oprot->writeString(_iter336->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_op) {
    xfer += oprot->writeFieldBegin("cache_op", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->cache_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_by) {
    xfer += oprot->writeFieldBegin("partition_by", ::apache::thrift::protocol::T_LIST, 14);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_by.size()));
      std::vector< ::impala::TKuduPartitionParam> ::const_iterator _iter337;
      for (_iter337 = this->partition_by.begin(); _iter337 != this->partition_by.end(); ++_iter337)
      {
        xfer += (*_iter337).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.primary_key_column_names) {
    xfer += oprot->writeFieldBegin("primary_key_column_names", ::apache::thrift::protocol::T_LIST, 15);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->primary_key_column_names.size()));
      std::vector<std::string> ::const_iterator _iter338;
      for (_iter338 = this->primary_key_column_names.begin(); _iter338 != this->primary_key_column_names.end(); ++_iter338)
      {
        xfer += oprot->writeString((*_iter338));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sort_columns) {
    xfer += oprot->writeFieldBegin("sort_columns", ::apache::thrift::protocol::T_LIST, 16);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sort_columns.size()));
      std::vector<std::string> ::const_iterator _iter339;
      for (_iter339 = this->sort_columns.begin(); _iter339 != this->sort_columns.end(); ++_iter339)
      {
        xfer += oprot->writeString((*_iter339));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sorting_order", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32((int32_t)this->sorting_order);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.primary_keys) {
    xfer += oprot->writeFieldBegin("primary_keys", ::apache::thrift::protocol::T_LIST, 19);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->primary_keys.size()));
      std::vector< ::Apache::Hadoop::Hive::SQLPrimaryKey> ::const_iterator _iter340;
      for (_iter340 = this->primary_keys.begin(); _iter340 != this->primary_keys.end(); ++_iter340)
      {
        xfer += (*_iter340).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.foreign_keys) {
    xfer += oprot->writeFieldBegin("foreign_keys", ::apache::thrift::protocol::T_LIST, 20);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->foreign_keys.size()));
      std::vector< ::Apache::Hadoop::Hive::SQLForeignKey> ::const_iterator _iter341;
      for (_iter341 = this->foreign_keys.begin(); _iter341 != this->foreign_keys.end(); ++_iter341)
      {
        xfer += (*_iter341).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_spec) {
    xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->partition_spec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateOrAlterViewParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_view_name = false;
  bool isset_columns = false;
  bool isset_owner = false;
  bool isset_original_view_def = false;
  bool isset_expanded_view_def = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->view_name.read(iprot);
          isset_view_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->columns.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += this->columns[_i350].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->original_view_def);
          isset_original_view_def = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expanded_view_def);
          isset_expanded_view_def = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_not_exists);
          this->__isset.if_not_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_view_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_original_view_def)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_expanded_view_def)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateOrAlterViewParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateOrAlterViewParams");

  xfer += oprot->writeFieldBegin("view_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->view_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector< ::impala::TColumn> ::const_iterator _iter351;
    for (_iter351 = this->columns.begin(); _iter351 != this->columns.end(); ++_iter351)
    {
      xfer += (*_iter351).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("original_view_def", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->original_view_def);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expanded_view_def", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->expanded_view_def);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.if_not_exists) {
    xfer += oprot->writeFieldBegin("if_not_exists", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->if_not_exists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TComputeStatsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_stats_query);
          this->__isset.tbl_stats_query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_stats_query);
          this->__isset.col_stats_query = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_incremental);
          this->__isset.is_incremental = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->existing_part_stats.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->existing_part_stats.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += this->existing_part_stats[_i360].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.existing_part_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expected_partitions.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _etype364;
            xfer += iprot->readListBegin(_etype364, _size361);
            this->expected_partitions.resize(_size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              {
                this->expected_partitions[_i365].clear();
                uint32_t _size366;
                ::apache::thrift::protocol::TType _etype369;
                xfer += iprot->readListBegin(_etype369, _size366);
                this->expected_partitions[_i365].resize(_size366);
                uint32_t _i370;
                for (_i370 = 0; _i370 < _size366; ++_i370)
                {
                  xfer += iprot->readString(this->expected_partitions[_i365][_i370]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expected_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->expect_all_partitions);
          this->__isset.expect_all_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_partition_cols);
          this->__isset.num_partition_cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_file_bytes);
          this->__isset.total_file_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TComputeStatsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TComputeStatsParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tbl_stats_query) {
    xfer += oprot->writeFieldBegin("tbl_stats_query", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->tbl_stats_query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_stats_query) {
    xfer += oprot->writeFieldBegin("col_stats_query", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->col_stats_query);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_incremental) {
    xfer += oprot->writeFieldBegin("is_incremental", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_incremental);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.existing_part_stats) {
    xfer += oprot->writeFieldBegin("existing_part_stats", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->existing_part_stats.size()));
      std::vector< ::impala::TPartitionStats> ::const_iterator _iter371;
      for (_iter371 = this->existing_part_stats.begin(); _iter371 != this->existing_part_stats.end(); ++_iter371)
      {
        xfer += (*_iter371).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expected_partitions) {
    xfer += oprot->writeFieldBegin("expected_partitions", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->expected_partitions.size()));
      std::vector<std::vector<std::string> > ::const_iterator _iter372;
      for (_iter372 = this->expected_partitions.begin(); _iter372 != this->expected_partitions.end(); ++_iter372)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter372).size()));
          std::vector<std::string> ::const_iterator _iter373;
          for (_iter373 = (*_iter372).begin(); _iter373 != (*_iter372).end(); ++_iter373)
          {
            xfer += oprot->writeString((*_iter373));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expect_all_partitions) {
    xfer += oprot->writeFieldBegin("expect_all_partitions", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->expect_all_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_partition_cols) {
    xfer += oprot->writeFieldBegin("num_partition_cols", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->num_partition_cols);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_file_bytes) {
    xfer += oprot->writeFieldBegin("total_file_bytes", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->total_file_bytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCreateDropRoleParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_drop = false;
  bool isset_role_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_drop);
          isset_is_drop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->role_name);
          isset_role_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_drop)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_role_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCreateDropRoleParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCreateDropRoleParams");

  xfer += oprot->writeFieldBegin("is_drop", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_drop);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("role_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->role_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGrantRevokeRoleParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_role_names = false;
  bool isset_group_names = false;
  bool isset_is_grant = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->role_names.clear();
            uint32_t _size382;
            ::apache::thrift::protocol::TType _etype385;
            xfer += iprot->readListBegin(_etype385, _size382);
            this->role_names.resize(_size382);
            uint32_t _i386;
            for (_i386 = 0; _i386 < _size382; ++_i386)
            {
              xfer += iprot->readString(this->role_names[_i386]);
            }
            xfer += iprot->readListEnd();
          }
          isset_role_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_names.clear();
            uint32_t _size387;
            ::apache::thrift::protocol::TType _etype390;
            xfer += iprot->readListBegin(_etype390, _size387);
            this->group_names.resize(_size387);
            uint32_t _i391;
            for (_i391 = 0; _i391 < _size387; ++_i391)
            {
              xfer += iprot->readString(this->group_names[_i391]);
            }
            xfer += iprot->readListEnd();
          }
          isset_group_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_grant);
          isset_is_grant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_role_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_group_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_grant)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGrantRevokeRoleParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGrantRevokeRoleParams");

  xfer += oprot->writeFieldBegin("role_names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->role_names.size()));
    std::vector<std::string> ::const_iterator _iter392;
    for (_iter392 = this->role_names.begin(); _iter392 != this->role_names.end(); ++_iter392)
    {
      xfer += oprot->writeString((*_iter392));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("group_names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->group_names.size()));
    std::vector<std::string> ::const_iterator _iter393;
    for (_iter393 = this->group_names.begin(); _iter393 != this->group_names.end(); ++_iter393)
    {
      xfer += oprot->writeString((*_iter393));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_grant", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_grant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGrantRevokePrivParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_privileges = false;
  bool isset_principal_name = false;
  bool isset_is_grant = false;
  bool isset_has_grant_opt = false;
  bool isset_principal_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->privileges.clear();
            uint32_t _size398;
            ::apache::thrift::protocol::TType _etype401;
            xfer += iprot->readListBegin(_etype401, _size398);
            this->privileges.resize(_size398);
            uint32_t _i402;
            for (_i402 = 0; _i402 < _size398; ++_i402)
            {
              xfer += this->privileges[_i402].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_privileges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal_name);
          isset_principal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_grant);
          isset_is_grant = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_grant_opt);
          isset_has_grant_opt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast403;
          xfer += iprot->readI32(ecast403);
          this->principal_type = ( ::impala::TPrincipalType::type)ecast403;
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_privileges)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_grant)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_grant_opt)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGrantRevokePrivParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGrantRevokePrivParams");

  xfer += oprot->writeFieldBegin("privileges", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->privileges.size()));
    std::vector< ::impala::TPrivilege> ::const_iterator _iter404;
    for (_iter404 = this->privileges.begin(); _iter404 != this->privileges.end(); ++_iter404)
    {
      xfer += (*_iter404).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->principal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_grant", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_grant);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_grant_opt", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_grant_opt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->principal_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDropDbParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;
  bool isset_if_exists = false;
  bool isset_cascade = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->cascade);
          isset_cascade = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cascade)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDropDbParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropDbParams");

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cascade", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->cascade);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDropTableOrViewParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_if_exists = false;
  bool isset_purge = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->purge);
          isset_purge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_table);
          this->__isset.is_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_purge)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDropTableOrViewParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropTableOrViewParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("purge", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->purge);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.is_table) {
    xfer += oprot->writeFieldBegin("is_table", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_table);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTruncateParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_if_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->delete_stats);
          this->__isset.delete_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTruncateParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTruncateParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.delete_stats) {
    xfer += oprot->writeFieldBegin("delete_stats", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->delete_stats);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDropFunctionParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fn_name = false;
  bool isset_arg_types = false;
  bool isset_if_exists = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn_name.read(iprot);
          isset_fn_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arg_types.clear();
            uint32_t _size421;
            ::apache::thrift::protocol::TType _etype424;
            xfer += iprot->readListBegin(_etype424, _size421);
            this->arg_types.resize(_size421);
            uint32_t _i425;
            for (_i425 = 0; _i425 < _size421; ++_i425)
            {
              xfer += this->arg_types[_i425].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_arg_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->if_exists);
          isset_if_exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fn_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_arg_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_if_exists)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDropFunctionParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDropFunctionParams");

  xfer += oprot->writeFieldBegin("fn_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fn_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg_types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arg_types.size()));
    std::vector< ::impala::TColumnType> ::const_iterator _iter426;
    for (_iter426 = this->arg_types.begin(); _iter426 != this->arg_types.end(); ++_iter426)
    {
      xfer += (*_iter426).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("if_exists", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->if_exists);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableUsageMetrics::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory_estimate_bytes);
          this->__isset.memory_estimate_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_metadata_operations);
          this->__isset.num_metadata_operations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_files);
          this->__isset.num_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->median_table_loading_ns);
          this->__isset.median_table_loading_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_table_loading_ns);
          this->__isset.max_table_loading_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_table_loading);
          this->__isset.num_table_loading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->p75_loading_time_ns);
          this->__isset.p75_loading_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->p95_loading_time_ns);
          this->__isset.p95_loading_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->p99_loading_time_ns);
          this->__isset.p99_loading_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTableUsageMetrics::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableUsageMetrics");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.memory_estimate_bytes) {
    xfer += oprot->writeFieldBegin("memory_estimate_bytes", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->memory_estimate_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_metadata_operations) {
    xfer += oprot->writeFieldBegin("num_metadata_operations", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->num_metadata_operations);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_files) {
    xfer += oprot->writeFieldBegin("num_files", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->num_files);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.median_table_loading_ns) {
    xfer += oprot->writeFieldBegin("median_table_loading_ns", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->median_table_loading_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_table_loading_ns) {
    xfer += oprot->writeFieldBegin("max_table_loading_ns", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->max_table_loading_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_table_loading) {
    xfer += oprot->writeFieldBegin("num_table_loading", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->num_table_loading);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.p75_loading_time_ns) {
    xfer += oprot->writeFieldBegin("p75_loading_time_ns", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->p75_loading_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.p95_loading_time_ns) {
    xfer += oprot->writeFieldBegin("p95_loading_time_ns", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->p95_loading_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.p99_loading_time_ns) {
    xfer += oprot->writeFieldBegin("p99_loading_time_ns", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->p99_loading_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogUsageResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_large_tables = false;
  bool isset_frequently_accessed_tables = false;
  bool isset_high_file_count_tables = false;
  bool isset_long_metadata_loading_tables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->large_tables.clear();
            uint32_t _size435;
            ::apache::thrift::protocol::TType _etype438;
            xfer += iprot->readListBegin(_etype438, _size435);
            this->large_tables.resize(_size435);
            uint32_t _i439;
            for (_i439 = 0; _i439 < _size435; ++_i439)
            {
              xfer += this->large_tables[_i439].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_large_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->frequently_accessed_tables.clear();
            uint32_t _size440;
            ::apache::thrift::protocol::TType _etype443;
            xfer += iprot->readListBegin(_etype443, _size440);
            this->frequently_accessed_tables.resize(_size440);
            uint32_t _i444;
            for (_i444 = 0; _i444 < _size440; ++_i444)
            {
              xfer += this->frequently_accessed_tables[_i444].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_frequently_accessed_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->high_file_count_tables.clear();
            uint32_t _size445;
            ::apache::thrift::protocol::TType _etype448;
            xfer += iprot->readListBegin(_etype448, _size445);
            this->high_file_count_tables.resize(_size445);
            uint32_t _i449;
            for (_i449 = 0; _i449 < _size445; ++_i449)
            {
              xfer += this->high_file_count_tables[_i449].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_high_file_count_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->long_metadata_loading_tables.clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _etype453;
            xfer += iprot->readListBegin(_etype453, _size450);
            this->long_metadata_loading_tables.resize(_size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              xfer += this->long_metadata_loading_tables[_i454].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_long_metadata_loading_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_large_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_frequently_accessed_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_high_file_count_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_long_metadata_loading_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogUsageResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogUsageResponse");

  xfer += oprot->writeFieldBegin("large_tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->large_tables.size()));
    std::vector<TTableUsageMetrics> ::const_iterator _iter455;
    for (_iter455 = this->large_tables.begin(); _iter455 != this->large_tables.end(); ++_iter455)
    {
      xfer += (*_iter455).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("frequently_accessed_tables", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->frequently_accessed_tables.size()));
    std::vector<TTableUsageMetrics> ::const_iterator _iter456;
    for (_iter456 = this->frequently_accessed_tables.begin(); _iter456 != this->frequently_accessed_tables.end(); ++_iter456)
    {
      xfer += (*_iter456).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("high_file_count_tables", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->high_file_count_tables.size()));
    std::vector<TTableUsageMetrics> ::const_iterator _iter457;
    for (_iter457 = this->high_file_count_tables.begin(); _iter457 != this->high_file_count_tables.end(); ++_iter457)
    {
      xfer += (*_iter457).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("long_metadata_loading_tables", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->long_metadata_loading_tables.size()));
    std::vector<TTableUsageMetrics> ::const_iterator _iter458;
    for (_iter458 = this->long_metadata_loading_tables.begin(); _iter458 != this->long_metadata_loading_tables.end(); ++_iter458)
    {
      xfer += (*_iter458).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TOperationUsageCounter::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_op_name = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalog_op_name);
          isset_catalog_op_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->op_counter);
          this->__isset.op_counter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_op_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TOperationUsageCounter::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TOperationUsageCounter");

  xfer += oprot->writeFieldBegin("catalog_op_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catalog_op_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.op_counter) {
    xfer += oprot->writeFieldBegin("op_counter", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->op_counter);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetOperationUsageResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_op_counters = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->catalog_op_counters.clear();
            uint32_t _size467;
            ::apache::thrift::protocol::TType _etype470;
            xfer += iprot->readListBegin(_etype470, _size467);
            this->catalog_op_counters.resize(_size467);
            uint32_t _i471;
            for (_i471 = 0; _i471 < _size467; ++_i471)
            {
              xfer += this->catalog_op_counters[_i471].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_catalog_op_counters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_op_counters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetOperationUsageResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetOperationUsageResponse");

  xfer += oprot->writeFieldBegin("catalog_op_counters", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->catalog_op_counters.size()));
    std::vector<TOperationUsageCounter> ::const_iterator _iter472;
    for (_iter472 = this->catalog_op_counters.begin(); _iter472 != this->catalog_op_counters.end(); ++_iter472)
    {
      xfer += (*_iter472).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TColumnName::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_column_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          isset_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_column_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TColumnName::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnName");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCommentOnParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_name.read(iprot);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TCommentOnParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCommentOnParams");

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->table_name.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_name) {
    xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->column_name.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TEventProcessorMetrics::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->events_received);
          this->__isset.events_received = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->events_skipped);
          this->__isset.events_skipped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->events_fetch_duration_mean);
          this->__isset.events_fetch_duration_mean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->events_process_duration_mean);
          this->__isset.events_process_duration_mean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->events_received_1min_rate);
          this->__isset.events_received_1min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->events_received_5min_rate);
          this->__isset.events_received_5min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->events_received_15min_rate);
          this->__isset.events_received_15min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->events_skipped_per_poll_mean);
          this->__isset.events_skipped_per_poll_mean = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_synced_event_id);
          this->__isset.last_synced_event_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TEventProcessorMetrics::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TEventProcessorMetrics");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.events_received) {
    xfer += oprot->writeFieldBegin("events_received", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->events_received);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_skipped) {
    xfer += oprot->writeFieldBegin("events_skipped", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->events_skipped);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_fetch_duration_mean) {
    xfer += oprot->writeFieldBegin("events_fetch_duration_mean", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->events_fetch_duration_mean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_process_duration_mean) {
    xfer += oprot->writeFieldBegin("events_process_duration_mean", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->events_process_duration_mean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_received_1min_rate) {
    xfer += oprot->writeFieldBegin("events_received_1min_rate", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->events_received_1min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_received_5min_rate) {
    xfer += oprot->writeFieldBegin("events_received_5min_rate", ::apache::thrift::protocol::T_DOUBLE, 7);
    xfer += oprot->writeDouble(this->events_received_5min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_received_15min_rate) {
    xfer += oprot->writeFieldBegin("events_received_15min_rate", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->events_received_15min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.events_skipped_per_poll_mean) {
    xfer += oprot->writeFieldBegin("events_skipped_per_poll_mean", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->events_skipped_per_poll_mean);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last_synced_event_id) {
    xfer += oprot->writeFieldBegin("last_synced_event_id", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->last_synced_event_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogHmsCacheApiMetrics::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_api_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->api_name);
          isset_api_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->api_requests);
          this->__isset.api_requests = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->p99_response_time_ms);
          this->__isset.p99_response_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->p95_response_time_ms);
          this->__isset.p95_response_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->response_time_mean_ms);
          this->__isset.response_time_mean_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->response_time_max_ms);
          this->__isset.response_time_max_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->response_time_min_ms);
          this->__isset.response_time_min_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->api_requests_1min_rate);
          this->__isset.api_requests_1min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->api_requests_5min_rate);
          this->__isset.api_requests_5min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->api_requests_15min_rate);
          this->__isset.api_requests_15min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cache_hit_ratio);
          this->__isset.cache_hit_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_api_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogHmsCacheApiMetrics::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogHmsCacheApiMetrics");

  xfer += oprot->writeFieldBegin("api_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->api_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.api_requests) {
    xfer += oprot->writeFieldBegin("api_requests", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->api_requests);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.p99_response_time_ms) {
    xfer += oprot->writeFieldBegin("p99_response_time_ms", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->p99_response_time_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.p95_response_time_ms) {
    xfer += oprot->writeFieldBegin("p95_response_time_ms", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->p95_response_time_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.response_time_mean_ms) {
    xfer += oprot->writeFieldBegin("response_time_mean_ms", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->response_time_mean_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.response_time_max_ms) {
    xfer += oprot->writeFieldBegin("response_time_max_ms", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->response_time_max_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.response_time_min_ms) {
    xfer += oprot->writeFieldBegin("response_time_min_ms", ::apache::thrift::protocol::T_DOUBLE, 7);
    xfer += oprot->writeDouble(this->response_time_min_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests_1min_rate) {
    xfer += oprot->writeFieldBegin("api_requests_1min_rate", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->api_requests_1min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests_5min_rate) {
    xfer += oprot->writeFieldBegin("api_requests_5min_rate", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->api_requests_5min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests_15min_rate) {
    xfer += oprot->writeFieldBegin("api_requests_15min_rate", ::apache::thrift::protocol::T_DOUBLE, 10);
    xfer += oprot->writeDouble(this->api_requests_15min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_hit_ratio) {
    xfer += oprot->writeFieldBegin("cache_hit_ratio", ::apache::thrift::protocol::T_DOUBLE, 11);
    xfer += oprot->writeDouble(this->cache_hit_ratio);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogdHmsCacheMetrics::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_api_metrics = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->api_metrics.clear();
            uint32_t _size493;
            ::apache::thrift::protocol::TType _etype496;
            xfer += iprot->readListBegin(_etype496, _size493);
            this->api_metrics.resize(_size493);
            uint32_t _i497;
            for (_i497 = 0; _i497 < _size493; ++_i497)
            {
              xfer += this->api_metrics[_i497].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_api_metrics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cache_hit_ratio);
          this->__isset.cache_hit_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->api_requests);
          this->__isset.api_requests = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->api_requests_1min_rate);
          this->__isset.api_requests_1min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->api_requests_5min_rate);
          this->__isset.api_requests_5min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->api_requests_15min_rate);
          this->__isset.api_requests_15min_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_api_metrics)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogdHmsCacheMetrics::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogdHmsCacheMetrics");

  xfer += oprot->writeFieldBegin("api_metrics", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->api_metrics.size()));
    std::vector<TCatalogHmsCacheApiMetrics> ::const_iterator _iter498;
    for (_iter498 = this->api_metrics.begin(); _iter498 != this->api_metrics.end(); ++_iter498)
    {
      xfer += (*_iter498).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cache_hit_ratio) {
    xfer += oprot->writeFieldBegin("cache_hit_ratio", ::apache::thrift::protocol::T_DOUBLE, 2);
    xfer += oprot->writeDouble(this->cache_hit_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests) {
    xfer += oprot->writeFieldBegin("api_requests", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->api_requests);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests_1min_rate) {
    xfer += oprot->writeFieldBegin("api_requests_1min_rate", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->api_requests_1min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests_5min_rate) {
    xfer += oprot->writeFieldBegin("api_requests_5min_rate", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->api_requests_5min_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.api_requests_15min_rate) {
    xfer += oprot->writeFieldBegin("api_requests_15min_rate", ::apache::thrift::protocol::T_DOUBLE, 6);
    xfer += oprot->writeDouble(this->api_requests_15min_rate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogServerMetricsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_partial_fetch_rpc_queue_len = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->catalog_partial_fetch_rpc_queue_len);
          isset_catalog_partial_fetch_rpc_queue_len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->event_metrics.read(iprot);
          this->__isset.event_metrics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogd_hms_cache_metrics.read(iprot);
          this->__isset.catalogd_hms_cache_metrics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_partial_fetch_rpc_queue_len)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogServerMetricsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogServerMetricsResponse");

  xfer += oprot->writeFieldBegin("catalog_partial_fetch_rpc_queue_len", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->catalog_partial_fetch_rpc_queue_len);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.event_metrics) {
    xfer += oprot->writeFieldBegin("event_metrics", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->event_metrics.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogd_hms_cache_metrics) {
    xfer += oprot->writeFieldBegin("catalogd_hms_cache_metrics", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->catalogd_hms_cache_metrics.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCopyTestCaseReq::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_input_path = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->input_path);
          isset_input_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_input_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCopyTestCaseReq::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCopyTestCaseReq");

  xfer += oprot->writeFieldBegin("input_path", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->input_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TEventProcessorMetricsSummaryResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_summary = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          isset_summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_summary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TEventProcessorMetricsSummaryResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TEventProcessorMetricsSummaryResponse");

  xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->summary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
