/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CatalogService_TYPES_TCC
#define CatalogService_TYPES_TCC

#include "CatalogObjects_types.tcc"
#include "JniCatalog_types.tcc"
#include "Types_types.tcc"
#include "Status_types.tcc"
#include "Results_types.tcc"
#include "hive_metastore_types.tcc"
#include "SqlConstraints_types.tcc"
#include "CatalogService_types.h"

namespace impala {

template <class Protocol_>
uint32_t TCatalogServiceRequestHeader::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requesting_user);
          this->__isset.requesting_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->redacted_sql_stmt);
          this->__isset.redacted_sql_stmt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->client_ip);
          this->__isset.client_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_minimal_response);
          this->__isset.want_minimal_response = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TCatalogServiceRequestHeader::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogServiceRequestHeader");

  if (this->__isset.requesting_user) {
    xfer += oprot->writeFieldBegin("requesting_user", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->requesting_user);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.redacted_sql_stmt) {
    xfer += oprot->writeFieldBegin("redacted_sql_stmt", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->redacted_sql_stmt);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.client_ip) {
    xfer += oprot->writeFieldBegin("client_ip", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->client_ip);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.want_minimal_response) {
    xfer += oprot->writeFieldBegin("want_minimal_response", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->want_minimal_response);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogUpdateResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_service_id = false;
  bool isset_version = false;
  bool isset_status = false;
  bool isset_is_invalidate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_service_id.read(iprot);
          isset_catalog_service_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_invalidate);
          isset_is_invalidate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updated_catalog_objects.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->updated_catalog_objects.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->updated_catalog_objects[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updated_catalog_objects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->removed_catalog_objects.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->removed_catalog_objects.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += this->removed_catalog_objects[_i13].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.removed_catalog_objects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_service_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_invalidate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogUpdateResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogUpdateResult");

  xfer += oprot->writeFieldBegin("catalog_service_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog_service_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_invalidate", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_invalidate);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.updated_catalog_objects) {
    xfer += oprot->writeFieldBegin("updated_catalog_objects", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updated_catalog_objects.size()));
      std::vector< ::impala::TCatalogObject> ::const_iterator _iter14;
      for (_iter14 = this->updated_catalog_objects.begin(); _iter14 != this->updated_catalog_objects.end(); ++_iter14)
      {
        xfer += (*_iter14).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.removed_catalog_objects) {
    xfer += oprot->writeFieldBegin("removed_catalog_objects", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->removed_catalog_objects.size()));
      std::vector< ::impala::TCatalogObject> ::const_iterator _iter15;
      for (_iter15 = this->removed_catalog_objects.begin(); _iter15 != this->removed_catalog_objects.end(); ++_iter15)
      {
        xfer += (*_iter15).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDdlExecRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_ddl_type = false;
  bool isset_sync_ddl = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->protocol_version = (CatalogServiceVersion::type)ecast20;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->ddl_type = ( ::impala::TDdlType::type)ecast21;
          isset_ddl_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_table_params.read(iprot);
          this->__isset.alter_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_view_params.read(iprot);
          this->__isset.alter_view_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_db_params.read(iprot);
          this->__isset.create_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_table_params.read(iprot);
          this->__isset.create_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_table_like_params.read(iprot);
          this->__isset.create_table_like_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_view_params.read(iprot);
          this->__isset.create_view_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_fn_params.read(iprot);
          this->__isset.create_fn_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_db_params.read(iprot);
          this->__isset.drop_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_table_or_view_params.read(iprot);
          this->__isset.drop_table_or_view_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->truncate_params.read(iprot);
          this->__isset.truncate_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_fn_params.read(iprot);
          this->__isset.drop_fn_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->compute_stats_params.read(iprot);
          this->__isset.compute_stats_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_data_source_params.read(iprot);
          this->__isset.create_data_source_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_data_source_params.read(iprot);
          this->__isset.drop_data_source_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_stats_params.read(iprot);
          this->__isset.drop_stats_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_drop_role_params.read(iprot);
          this->__isset.create_drop_role_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->grant_revoke_role_params.read(iprot);
          this->__isset.grant_revoke_role_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->grant_revoke_priv_params.read(iprot);
          this->__isset.grant_revoke_priv_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sync_ddl);
          isset_sync_ddl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->comment_on_params.read(iprot);
          this->__isset.comment_on_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->alter_db_params.read(iprot);
          this->__isset.alter_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->copy_test_case_params.read(iprot);
          this->__isset.copy_test_case_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debug_action);
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ddl_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sync_ddl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDdlExecRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDdlExecRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.header) {
    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ddl_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->ddl_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.alter_table_params) {
    xfer += oprot->writeFieldBegin("alter_table_params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->alter_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alter_view_params) {
    xfer += oprot->writeFieldBegin("alter_view_params", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->alter_view_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_db_params) {
    xfer += oprot->writeFieldBegin("create_db_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->create_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_table_params) {
    xfer += oprot->writeFieldBegin("create_table_params", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->create_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_table_like_params) {
    xfer += oprot->writeFieldBegin("create_table_like_params", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->create_table_like_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_view_params) {
    xfer += oprot->writeFieldBegin("create_view_params", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->create_view_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_fn_params) {
    xfer += oprot->writeFieldBegin("create_fn_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->create_fn_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_db_params) {
    xfer += oprot->writeFieldBegin("drop_db_params", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->drop_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_table_or_view_params) {
    xfer += oprot->writeFieldBegin("drop_table_or_view_params", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->drop_table_or_view_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.truncate_params) {
    xfer += oprot->writeFieldBegin("truncate_params", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->truncate_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_fn_params) {
    xfer += oprot->writeFieldBegin("drop_fn_params", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->drop_fn_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compute_stats_params) {
    xfer += oprot->writeFieldBegin("compute_stats_params", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->compute_stats_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_data_source_params) {
    xfer += oprot->writeFieldBegin("create_data_source_params", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->create_data_source_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_data_source_params) {
    xfer += oprot->writeFieldBegin("drop_data_source_params", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->drop_data_source_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.drop_stats_params) {
    xfer += oprot->writeFieldBegin("drop_stats_params", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->drop_stats_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_drop_role_params) {
    xfer += oprot->writeFieldBegin("create_drop_role_params", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->create_drop_role_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grant_revoke_role_params) {
    xfer += oprot->writeFieldBegin("grant_revoke_role_params", ::apache::thrift::protocol::T_STRUCT, 20);
    xfer += this->grant_revoke_role_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.grant_revoke_priv_params) {
    xfer += oprot->writeFieldBegin("grant_revoke_priv_params", ::apache::thrift::protocol::T_STRUCT, 21);
    xfer += this->grant_revoke_priv_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sync_ddl", ::apache::thrift::protocol::T_BOOL, 22);
  xfer += oprot->writeBool(this->sync_ddl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment_on_params) {
    xfer += oprot->writeFieldBegin("comment_on_params", ::apache::thrift::protocol::T_STRUCT, 23);
    xfer += this->comment_on_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alter_db_params) {
    xfer += oprot->writeFieldBegin("alter_db_params", ::apache::thrift::protocol::T_STRUCT, 24);
    xfer += this->alter_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.copy_test_case_params) {
    xfer += oprot->writeFieldBegin("copy_test_case_params", ::apache::thrift::protocol::T_STRUCT, 25);
    xfer += this->copy_test_case_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_STRING, 26);
    xfer += oprot->writeString(this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDdlExecResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->new_table_created);
          this->__isset.new_table_created = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set.read(iprot);
          this->__isset.result_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_create_time);
          this->__isset.table_create_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_location);
          this->__isset.table_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDdlExecResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDdlExecResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.new_table_created) {
    xfer += oprot->writeFieldBegin("new_table_created", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->new_table_created);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_set) {
    xfer += oprot->writeFieldBegin("result_set", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->result_set.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->table_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_create_time) {
    xfer += oprot->writeFieldBegin("table_create_time", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->table_create_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_location) {
    xfer += oprot->writeFieldBegin("table_location", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->table_location);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergOperationParam::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iceberg_data_files_fb = false;
  bool isset_is_overwrite = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->spec_id);
          this->__isset.spec_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iceberg_data_files_fb.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->iceberg_data_files_fb.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readBinary(this->iceberg_data_files_fb[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          isset_iceberg_data_files_fb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_overwrite);
          isset_is_overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iceberg_data_files_fb)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_overwrite)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergOperationParam::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIcebergOperationParam");

  if (this->__isset.spec_id) {
    xfer += oprot->writeFieldBegin("spec_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->spec_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("iceberg_data_files_fb", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->iceberg_data_files_fb.size()));
    std::vector<std::string> ::const_iterator _iter35;
    for (_iter35 = this->iceberg_data_files_fb.begin(); _iter35 != this->iceberg_data_files_fb.end(); ++_iter35)
    {
      xfer += oprot->writeBinary((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_overwrite", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_overwrite);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdatedPartition::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_files = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->files.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += iprot->readString(this->files[_i44]);
            }
            xfer += iprot->readListEnd();
          }
          isset_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_files)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdatedPartition::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdatedPartition");

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
    std::vector<std::string> ::const_iterator _iter45;
    for (_iter45 = this->files.begin(); _iter45 != this->files.end(); ++_iter45)
    {
      xfer += oprot->writeString((*_iter45));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_sync_ddl = false;
  bool isset_target_table = false;
  bool isset_db_name = false;
  bool isset_updated_partitions = false;
  bool isset_is_overwrite = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->protocol_version = (CatalogServiceVersion::type)ecast50;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sync_ddl);
          isset_sync_ddl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_table);
          isset_target_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->updated_partitions.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _ktype52;
            ::apache::thrift::protocol::TType _vtype53;
            xfer += iprot->readMapBegin(_ktype52, _vtype53, _size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              std::string _key56;
              xfer += iprot->readString(_key56);
              TUpdatedPartition& _val57 = this->updated_partitions[_key56];
              xfer += _val57.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_updated_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_overwrite);
          isset_is_overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->transaction_id);
          this->__isset.transaction_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->write_id);
          this->__isset.write_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iceberg_operation.read(iprot);
          this->__isset.iceberg_operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sync_ddl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target_table)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_updated_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_overwrite)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateCatalogRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sync_ddl", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sync_ddl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.header) {
    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("target_table", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->target_table);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updated_partitions", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updated_partitions.size()));
    std::map<std::string, TUpdatedPartition> ::const_iterator _iter58;
    for (_iter58 = this->updated_partitions.begin(); _iter58 != this->updated_partitions.end(); ++_iter58)
    {
      xfer += oprot->writeString(_iter58->first);
      xfer += _iter58->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_overwrite", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->is_overwrite);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.transaction_id) {
    xfer += oprot->writeFieldBegin("transaction_id", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->transaction_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.write_id) {
    xfer += oprot->writeFieldBegin("write_id", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->write_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iceberg_operation) {
    xfer += oprot->writeFieldBegin("iceberg_operation", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->iceberg_operation.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateCatalogResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TResetMetadataRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_is_refresh = false;
  bool isset_sync_ddl = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast67;
          xfer += iprot->readI32(ecast67);
          this->protocol_version = (CatalogServiceVersion::type)ecast67;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_refresh);
          isset_is_refresh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->partition_spec.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += this->partition_spec[_i72].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sync_ddl);
          isset_sync_ddl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->authorization);
          this->__isset.authorization = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->refresh_updated_hms_partitions);
          this->__isset.refresh_updated_hms_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->debug_action);
          this->__isset.debug_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_refresh)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sync_ddl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TResetMetadataRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResetMetadataRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.header) {
    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("is_refresh", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_refresh);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->table_name.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_spec) {
    xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
      std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter73;
      for (_iter73 = this->partition_spec.begin(); _iter73 != this->partition_spec.end(); ++_iter73)
      {
        xfer += (*_iter73).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("sync_ddl", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->sync_ddl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.authorization) {
    xfer += oprot->writeFieldBegin("authorization", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->authorization);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.refresh_updated_hms_partitions) {
    xfer += oprot->writeFieldBegin("refresh_updated_hms_partitions", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->refresh_updated_hms_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_action) {
    xfer += oprot->writeFieldBegin("debug_action", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->debug_action);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TResetMetadataResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TResetMetadataResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResetMetadataResponse");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast82;
          xfer += iprot->readI32(ecast82);
          this->protocol_version = (CatalogServiceVersion::type)ecast82;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetFunctionsRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.header) {
    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->functions.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->functions[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetFunctionsResponse");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.functions) {
    xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
      std::vector< ::impala::TFunction> ::const_iterator _iter92;
      for (_iter92 = this->functions.begin(); _iter92 != this->functions.end(); ++_iter92)
      {
        xfer += (*_iter92).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogInfoSelector::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_db_names);
          this->__isset.want_db_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TCatalogInfoSelector::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogInfoSelector");

  xfer += oprot->writeFieldBegin("want_db_names", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->want_db_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartialCatalogInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->db_names.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->db_names.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += iprot->readString(this->db_names[_i105]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.db_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TPartialCatalogInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartialCatalogInfo");

  xfer += oprot->writeFieldBegin("db_names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->db_names.size()));
    std::vector<std::string> ::const_iterator _iter106;
    for (_iter106 = this->db_names.begin(); _iter106 != this->db_names.end(); ++_iter106)
    {
      xfer += oprot->writeString((*_iter106));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableInfoSelector::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_hms_table);
          this->__isset.want_hms_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_ids.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->partition_ids.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += iprot->readI64(this->partition_ids[_i115]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_partition_names);
          this->__isset.want_partition_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_partition_metadata);
          this->__isset.want_partition_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_partition_files);
          this->__isset.want_partition_files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->want_stats_for_column_names.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _etype119;
            xfer += iprot->readListBegin(_etype119, _size116);
            this->want_stats_for_column_names.resize(_size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              xfer += iprot->readString(this->want_stats_for_column_names[_i120]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.want_stats_for_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_partition_stats);
          this->__isset.want_partition_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_table_constraints);
          this->__isset.want_table_constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valid_write_ids.read(iprot);
          this->__isset.valid_write_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_stats_for_all_columns);
          this->__isset.want_stats_for_all_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_hms_partition);
          this->__isset.want_hms_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_iceberg_snapshot);
          this->__isset.want_iceberg_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TTableInfoSelector::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableInfoSelector");

  xfer += oprot->writeFieldBegin("want_hms_table", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->want_hms_table);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_ids) {
    xfer += oprot->writeFieldBegin("partition_ids", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->partition_ids.size()));
      std::vector<int64_t> ::const_iterator _iter121;
      for (_iter121 = this->partition_ids.begin(); _iter121 != this->partition_ids.end(); ++_iter121)
      {
        xfer += oprot->writeI64((*_iter121));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("want_partition_names", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->want_partition_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("want_partition_metadata", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->want_partition_metadata);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("want_partition_files", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->want_partition_files);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.want_stats_for_column_names) {
    xfer += oprot->writeFieldBegin("want_stats_for_column_names", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->want_stats_for_column_names.size()));
      std::vector<std::string> ::const_iterator _iter122;
      for (_iter122 = this->want_stats_for_column_names.begin(); _iter122 != this->want_stats_for_column_names.end(); ++_iter122)
      {
        xfer += oprot->writeString((*_iter122));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("want_partition_stats", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->want_partition_stats);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("want_table_constraints", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->want_table_constraints);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.valid_write_ids) {
    xfer += oprot->writeFieldBegin("valid_write_ids", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->valid_write_ids.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_id) {
    xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->table_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.want_stats_for_all_columns) {
    xfer += oprot->writeFieldBegin("want_stats_for_all_columns", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->want_stats_for_all_columns);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("want_hms_partition", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->want_hms_partition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("want_iceberg_snapshot", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->want_iceberg_snapshot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartialPartitionInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hms_partition.read(iprot);
          this->__isset.hms_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_descriptors.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->file_descriptors.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += this->file_descriptors[_i131].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.file_descriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->insert_file_descriptors.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->insert_file_descriptors.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += this->insert_file_descriptors[_i136].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.insert_file_descriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->delete_file_descriptors.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _etype140;
            xfer += iprot->readListBegin(_etype140, _size137);
            this->delete_file_descriptors.resize(_size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              xfer += this->delete_file_descriptors[_i141].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.delete_file_descriptors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_compaction_id);
          this->__isset.last_compaction_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->partition_stats);
          this->__isset.partition_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_incremental_stats);
          this->__isset.has_incremental_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_marked_cached);
          this->__isset.is_marked_cached = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hms_parameters.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _ktype143;
            ::apache::thrift::protocol::TType _vtype144;
            xfer += iprot->readMapBegin(_ktype143, _vtype144, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              std::string _key147;
              xfer += iprot->readString(_key147);
              std::string& _val148 = this->hms_parameters[_key147];
              xfer += iprot->readString(_val148);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hms_parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->write_id);
          this->__isset.write_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_storage_descriptor.read(iprot);
          this->__isset.hdfs_storage_descriptor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPartialPartitionInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartialPartitionInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.name) {
    xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hms_partition) {
    xfer += oprot->writeFieldBegin("hms_partition", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->hms_partition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.file_descriptors) {
    xfer += oprot->writeFieldBegin("file_descriptors", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->file_descriptors.size()));
      std::vector< ::impala::THdfsFileDesc> ::const_iterator _iter149;
      for (_iter149 = this->file_descriptors.begin(); _iter149 != this->file_descriptors.end(); ++_iter149)
      {
        xfer += (*_iter149).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_stats) {
    xfer += oprot->writeFieldBegin("partition_stats", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->partition_stats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_incremental_stats) {
    xfer += oprot->writeFieldBegin("has_incremental_stats", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->has_incremental_stats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_marked_cached) {
    xfer += oprot->writeFieldBegin("is_marked_cached", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_marked_cached);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.insert_file_descriptors) {
    xfer += oprot->writeFieldBegin("insert_file_descriptors", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->insert_file_descriptors.size()));
      std::vector< ::impala::THdfsFileDesc> ::const_iterator _iter150;
      for (_iter150 = this->insert_file_descriptors.begin(); _iter150 != this->insert_file_descriptors.end(); ++_iter150)
      {
        xfer += (*_iter150).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.delete_file_descriptors) {
    xfer += oprot->writeFieldBegin("delete_file_descriptors", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->delete_file_descriptors.size()));
      std::vector< ::impala::THdfsFileDesc> ::const_iterator _iter151;
      for (_iter151 = this->delete_file_descriptors.begin(); _iter151 != this->delete_file_descriptors.end(); ++_iter151)
      {
        xfer += (*_iter151).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hms_parameters) {
    xfer += oprot->writeFieldBegin("hms_parameters", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hms_parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter152;
      for (_iter152 = this->hms_parameters.begin(); _iter152 != this->hms_parameters.end(); ++_iter152)
      {
        xfer += oprot->writeString(_iter152->first);
        xfer += oprot->writeString(_iter152->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.write_id) {
    xfer += oprot->writeFieldBegin("write_id", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->write_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_storage_descriptor) {
    xfer += oprot->writeFieldBegin("hdfs_storage_descriptor", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->hdfs_storage_descriptor.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->location.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last_compaction_id) {
    xfer += oprot->writeFieldBegin("last_compaction_id", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->last_compaction_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergSnapshot::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_snapshot_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->snapshot_id);
          isset_snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->iceberg_file_desc_map.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _ktype158;
            ::apache::thrift::protocol::TType _vtype159;
            xfer += iprot->readMapBegin(_ktype158, _vtype159, _size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              std::string _key162;
              xfer += iprot->readString(_key162);
               ::impala::THdfsFileDesc& _val163 = this->iceberg_file_desc_map[_key162];
              xfer += _val163.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.iceberg_file_desc_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_snapshot_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergSnapshot::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIcebergSnapshot");

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->snapshot_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.iceberg_file_desc_map) {
    xfer += oprot->writeFieldBegin("iceberg_file_desc_map", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iceberg_file_desc_map.size()));
      std::map<std::string,  ::impala::THdfsFileDesc> ::const_iterator _iter164;
      for (_iter164 = this->iceberg_file_desc_map.begin(); _iter164 != this->iceberg_file_desc_map.end(); ++_iter164)
      {
        xfer += oprot->writeString(_iter164->first);
        xfer += _iter164->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartialTableInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hms_table.read(iprot);
          this->__isset.hms_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->partitions.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += this->partitions[_i173].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_stats.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->column_stats.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += this->column_stats[_i178].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->storage_metadata_load_time_ns);
          this->__isset.storage_metadata_load_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_addresses.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size179);
            this->network_addresses.resize(_size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              xfer += this->network_addresses[_i183].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sql_constraints.read(iprot);
          this->__isset.sql_constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valid_write_ids.read(iprot);
          this->__isset.valid_write_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_marked_cached);
          this->__isset.is_marked_cached = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_prefixes.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _etype187;
            xfer += iprot->readListBegin(_etype187, _size184);
            this->partition_prefixes.resize(_size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              xfer += iprot->readString(this->partition_prefixes[_i188]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_prefixes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iceberg_snapshot.read(iprot);
          this->__isset.iceberg_snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TPartialTableInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartialTableInfo");

  if (this->__isset.hms_table) {
    xfer += oprot->writeFieldBegin("hms_table", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->hms_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partitions) {
    xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
      std::vector<TPartialPartitionInfo> ::const_iterator _iter189;
      for (_iter189 = this->partitions.begin(); _iter189 != this->partitions.end(); ++_iter189)
      {
        xfer += (*_iter189).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_stats) {
    xfer += oprot->writeFieldBegin("column_stats", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_stats.size()));
      std::vector< ::Apache::Hadoop::Hive::ColumnStatisticsObj> ::const_iterator _iter190;
      for (_iter190 = this->column_stats.begin(); _iter190 != this->column_stats.end(); ++_iter190)
      {
        xfer += (*_iter190).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_metadata_load_time_ns) {
    xfer += oprot->writeFieldBegin("storage_metadata_load_time_ns", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->storage_metadata_load_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_addresses) {
    xfer += oprot->writeFieldBegin("network_addresses", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_addresses.size()));
      std::vector< ::impala::TNetworkAddress> ::const_iterator _iter191;
      for (_iter191 = this->network_addresses.begin(); _iter191 != this->network_addresses.end(); ++_iter191)
      {
        xfer += (*_iter191).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sql_constraints) {
    xfer += oprot->writeFieldBegin("sql_constraints", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->sql_constraints.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.valid_write_ids) {
    xfer += oprot->writeFieldBegin("valid_write_ids", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->valid_write_ids.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_marked_cached) {
    xfer += oprot->writeFieldBegin("is_marked_cached", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_marked_cached);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_prefixes) {
    xfer += oprot->writeFieldBegin("partition_prefixes", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partition_prefixes.size()));
      std::vector<std::string> ::const_iterator _iter192;
      for (_iter192 = this->partition_prefixes.begin(); _iter192 != this->partition_prefixes.end(); ++_iter192)
      {
        xfer += oprot->writeString((*_iter192));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iceberg_snapshot) {
    xfer += oprot->writeFieldBegin("iceberg_snapshot", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->iceberg_snapshot.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TBriefTableMeta::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msType);
          this->__isset.msType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TBriefTableMeta::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBriefTableMeta");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.msType) {
    xfer += oprot->writeFieldBegin("msType", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->msType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDbInfoSelector::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_hms_database);
          this->__isset.want_hms_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_brief_meta_of_tables);
          this->__isset.want_brief_meta_of_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->want_function_names);
          this->__isset.want_function_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TDbInfoSelector::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDbInfoSelector");

  xfer += oprot->writeFieldBegin("want_hms_database", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->want_hms_database);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("want_brief_meta_of_tables", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->want_brief_meta_of_tables);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("want_function_names", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->want_function_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartialDbInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hms_database.read(iprot);
          this->__isset.hms_database = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->brief_meta_of_tables.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->brief_meta_of_tables.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              xfer += this->brief_meta_of_tables[_i209].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.brief_meta_of_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->function_names.clear();
            uint32_t _size210;
            ::apache::thrift::protocol::TType _etype213;
            xfer += iprot->readListBegin(_etype213, _size210);
            this->function_names.resize(_size210);
            uint32_t _i214;
            for (_i214 = 0; _i214 < _size210; ++_i214)
            {
              xfer += iprot->readString(this->function_names[_i214]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.function_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TPartialDbInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartialDbInfo");

  if (this->__isset.hms_database) {
    xfer += oprot->writeFieldBegin("hms_database", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->hms_database.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.brief_meta_of_tables) {
    xfer += oprot->writeFieldBegin("brief_meta_of_tables", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->brief_meta_of_tables.size()));
      std::vector<TBriefTableMeta> ::const_iterator _iter215;
      for (_iter215 = this->brief_meta_of_tables.begin(); _iter215 != this->brief_meta_of_tables.end(); ++_iter215)
      {
        xfer += (*_iter215).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.function_names) {
    xfer += oprot->writeFieldBegin("function_names", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->function_names.size()));
      std::vector<std::string> ::const_iterator _iter216;
      for (_iter216 = this->function_names.begin(); _iter216 != this->function_names.end(); ++_iter216)
      {
        xfer += oprot->writeString((*_iter216));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetPartialCatalogObjectRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_object_desc = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast221;
          xfer += iprot->readI32(ecast221);
          this->protocol_version = (CatalogServiceVersion::type)ecast221;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->object_desc.read(iprot);
          isset_object_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_info_selector.read(iprot);
          this->__isset.table_info_selector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->db_info_selector.read(iprot);
          this->__isset.db_info_selector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_info_selector.read(iprot);
          this->__isset.catalog_info_selector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_object_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetPartialCatalogObjectRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetPartialCatalogObjectRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("object_desc", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->object_desc.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.table_info_selector) {
    xfer += oprot->writeFieldBegin("table_info_selector", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->table_info_selector.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_info_selector) {
    xfer += oprot->writeFieldBegin("db_info_selector", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->db_info_selector.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalog_info_selector) {
    xfer += oprot->writeFieldBegin("catalog_info_selector", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->catalog_info_selector.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetPartialCatalogObjectResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast226;
          xfer += iprot->readI32(ecast226);
          this->lookup_status = (CatalogLookupStatus::type)ecast226;
          this->__isset.lookup_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->object_version_number);
          this->__isset.object_version_number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_info.read(iprot);
          this->__isset.table_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->db_info.read(iprot);
          this->__isset.db_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_info.read(iprot);
          this->__isset.catalog_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size227;
            ::apache::thrift::protocol::TType _etype230;
            xfer += iprot->readListBegin(_etype230, _size227);
            this->functions.resize(_size227);
            uint32_t _i231;
            for (_i231 = 0; _i231 < _size227; ++_i231)
            {
              xfer += this->functions[_i231].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetPartialCatalogObjectResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetPartialCatalogObjectResponse");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lookup_status) {
    xfer += oprot->writeFieldBegin("lookup_status", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->lookup_status);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.object_version_number) {
    xfer += oprot->writeFieldBegin("object_version_number", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->object_version_number);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_info) {
    xfer += oprot->writeFieldBegin("table_info", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->table_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_info) {
    xfer += oprot->writeFieldBegin("db_info", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->db_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalog_info) {
    xfer += oprot->writeFieldBegin("catalog_info", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->catalog_info.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.functions) {
    xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
      std::vector< ::impala::TFunction> ::const_iterator _iter232;
      for (_iter232 = this->functions.begin(); _iter232 != this->functions.end(); ++_iter232)
      {
        xfer += (*_iter232).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogObjectRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_object_desc = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast237;
          xfer += iprot->readI32(ecast237);
          this->protocol_version = (CatalogServiceVersion::type)ecast237;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->object_desc.read(iprot);
          isset_object_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_object_desc)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogObjectRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogObjectRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("object_desc", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->object_desc.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.header) {
    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogObjectResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_object = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_object.read(iprot);
          isset_catalog_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_object)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogObjectResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogObjectResponse");

  xfer += oprot->writeFieldBegin("catalog_object", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog_object.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetPartitionStatsRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast246;
          xfer += iprot->readI32(ecast246);
          this->protocol_version = (CatalogServiceVersion::type)ecast246;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valid_write_ids.read(iprot);
          this->__isset.valid_write_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_id);
          this->__isset.table_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetPartitionStatsRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetPartitionStatsRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.valid_write_ids) {
    xfer += oprot->writeFieldBegin("valid_write_ids", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->valid_write_ids.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_id) {
    xfer += oprot->writeFieldBegin("table_id", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->table_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetPartitionStatsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partition_stats.clear();
            uint32_t _size251;
            ::apache::thrift::protocol::TType _ktype252;
            ::apache::thrift::protocol::TType _vtype253;
            xfer += iprot->readMapBegin(_ktype252, _vtype253, _size251);
            uint32_t _i255;
            for (_i255 = 0; _i255 < _size251; ++_i255)
            {
              std::string _key256;
              xfer += iprot->readString(_key256);
              std::string& _val257 = this->partition_stats[_key256];
              xfer += iprot->readBinary(_val257);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.partition_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetPartitionStatsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetPartitionStatsResponse");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_stats) {
    xfer += oprot->writeFieldBegin("partition_stats", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partition_stats.size()));
      std::map<std::string, std::string> ::const_iterator _iter258;
      for (_iter258 = this->partition_stats.begin(); _iter258 != this->partition_stats.end(); ++_iter258)
      {
        xfer += oprot->writeString(_iter258->first);
        xfer += oprot->writeBinary(_iter258->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPrioritizeLoadRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_object_descs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast263;
          xfer += iprot->readI32(ecast263);
          this->protocol_version = (CatalogServiceVersion::type)ecast263;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->object_descs.clear();
            uint32_t _size264;
            ::apache::thrift::protocol::TType _etype267;
            xfer += iprot->readListBegin(_etype267, _size264);
            this->object_descs.resize(_size264);
            uint32_t _i268;
            for (_i268 = 0; _i268 < _size264; ++_i268)
            {
              xfer += this->object_descs[_i268].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_object_descs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_object_descs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPrioritizeLoadRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPrioritizeLoadRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.header) {
    xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->header.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("object_descs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->object_descs.size()));
    std::vector< ::impala::TCatalogObject> ::const_iterator _iter269;
    for (_iter269 = this->object_descs.begin(); _iter269 != this->object_descs.end(); ++_iter269)
    {
      xfer += (*_iter269).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPrioritizeLoadResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPrioritizeLoadResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPrioritizeLoadResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableUsage::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_num_usages = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_usages);
          isset_num_usages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_usages)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTableUsage::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableUsage");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_usages", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_usages);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateTableUsageRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_usages = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->usages.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _etype285;
            xfer += iprot->readListBegin(_etype285, _size282);
            this->usages.resize(_size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              xfer += this->usages[_i286].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_usages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_usages)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateTableUsageRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateTableUsageRequest");

  xfer += oprot->writeFieldBegin("usages", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->usages.size()));
    std::vector<TTableUsage> ::const_iterator _iter287;
    for (_iter287 = this->usages.begin(); _iter287 != this->usages.end(); ++_iter287)
    {
      xfer += (*_iter287).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateTableUsageResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TUpdateTableUsageResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateTableUsageResponse");

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
