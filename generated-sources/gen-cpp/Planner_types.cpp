/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Planner_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {


TPlanFragment::~TPlanFragment() throw() {
}


void TPlanFragment::__set_idx(const  ::impala::TFragmentIdx val) {
  this->idx = val;
}

void TPlanFragment::__set_display_name(const std::string& val) {
  this->display_name = val;
}

void TPlanFragment::__set_plan(const  ::impala::TPlan& val) {
  this->plan = val;
__isset.plan = true;
}

void TPlanFragment::__set_output_sink(const  ::impala::TDataSink& val) {
  this->output_sink = val;
__isset.output_sink = true;
}

void TPlanFragment::__set_partition(const  ::impala::TDataPartition& val) {
  this->partition = val;
}

void TPlanFragment::__set_backend_min_mem_reservation_bytes(const int64_t val) {
  this->backend_min_mem_reservation_bytes = val;
__isset.backend_min_mem_reservation_bytes = true;
}

void TPlanFragment::__set_instance_min_mem_reservation_bytes(const int64_t val) {
  this->instance_min_mem_reservation_bytes = val;
__isset.instance_min_mem_reservation_bytes = true;
}

void TPlanFragment::__set_instance_initial_mem_reservation_total_claims(const int64_t val) {
  this->instance_initial_mem_reservation_total_claims = val;
__isset.instance_initial_mem_reservation_total_claims = true;
}

void TPlanFragment::__set_backend_initial_mem_reservation_total_claims(const int64_t val) {
  this->backend_initial_mem_reservation_total_claims = val;
__isset.backend_initial_mem_reservation_total_claims = true;
}

void TPlanFragment::__set_produced_runtime_filters_reservation_bytes(const int64_t val) {
  this->produced_runtime_filters_reservation_bytes = val;
__isset.produced_runtime_filters_reservation_bytes = true;
}

void TPlanFragment::__set_consumed_runtime_filters_reservation_bytes(const int64_t val) {
  this->consumed_runtime_filters_reservation_bytes = val;
__isset.consumed_runtime_filters_reservation_bytes = true;
}

void TPlanFragment::__set_thread_reservation(const int64_t val) {
  this->thread_reservation = val;
__isset.thread_reservation = true;
}
std::ostream& operator<<(std::ostream& out, const TPlanFragment& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPlanFragment &a, TPlanFragment &b) {
  using ::std::swap;
  swap(a.idx, b.idx);
  swap(a.display_name, b.display_name);
  swap(a.plan, b.plan);
  swap(a.output_sink, b.output_sink);
  swap(a.partition, b.partition);
  swap(a.backend_min_mem_reservation_bytes, b.backend_min_mem_reservation_bytes);
  swap(a.instance_min_mem_reservation_bytes, b.instance_min_mem_reservation_bytes);
  swap(a.instance_initial_mem_reservation_total_claims, b.instance_initial_mem_reservation_total_claims);
  swap(a.backend_initial_mem_reservation_total_claims, b.backend_initial_mem_reservation_total_claims);
  swap(a.produced_runtime_filters_reservation_bytes, b.produced_runtime_filters_reservation_bytes);
  swap(a.consumed_runtime_filters_reservation_bytes, b.consumed_runtime_filters_reservation_bytes);
  swap(a.thread_reservation, b.thread_reservation);
  swap(a.__isset, b.__isset);
}

TPlanFragment::TPlanFragment(const TPlanFragment& other0) {
  idx = other0.idx;
  display_name = other0.display_name;
  plan = other0.plan;
  output_sink = other0.output_sink;
  partition = other0.partition;
  backend_min_mem_reservation_bytes = other0.backend_min_mem_reservation_bytes;
  instance_min_mem_reservation_bytes = other0.instance_min_mem_reservation_bytes;
  instance_initial_mem_reservation_total_claims = other0.instance_initial_mem_reservation_total_claims;
  backend_initial_mem_reservation_total_claims = other0.backend_initial_mem_reservation_total_claims;
  produced_runtime_filters_reservation_bytes = other0.produced_runtime_filters_reservation_bytes;
  consumed_runtime_filters_reservation_bytes = other0.consumed_runtime_filters_reservation_bytes;
  thread_reservation = other0.thread_reservation;
  __isset = other0.__isset;
}
TPlanFragment::TPlanFragment( TPlanFragment&& other1) {
  idx = std::move(other1.idx);
  display_name = std::move(other1.display_name);
  plan = std::move(other1.plan);
  output_sink = std::move(other1.output_sink);
  partition = std::move(other1.partition);
  backend_min_mem_reservation_bytes = std::move(other1.backend_min_mem_reservation_bytes);
  instance_min_mem_reservation_bytes = std::move(other1.instance_min_mem_reservation_bytes);
  instance_initial_mem_reservation_total_claims = std::move(other1.instance_initial_mem_reservation_total_claims);
  backend_initial_mem_reservation_total_claims = std::move(other1.backend_initial_mem_reservation_total_claims);
  produced_runtime_filters_reservation_bytes = std::move(other1.produced_runtime_filters_reservation_bytes);
  consumed_runtime_filters_reservation_bytes = std::move(other1.consumed_runtime_filters_reservation_bytes);
  thread_reservation = std::move(other1.thread_reservation);
  __isset = std::move(other1.__isset);
}
TPlanFragment& TPlanFragment::operator=(const TPlanFragment& other2) {
  idx = other2.idx;
  display_name = other2.display_name;
  plan = other2.plan;
  output_sink = other2.output_sink;
  partition = other2.partition;
  backend_min_mem_reservation_bytes = other2.backend_min_mem_reservation_bytes;
  instance_min_mem_reservation_bytes = other2.instance_min_mem_reservation_bytes;
  instance_initial_mem_reservation_total_claims = other2.instance_initial_mem_reservation_total_claims;
  backend_initial_mem_reservation_total_claims = other2.backend_initial_mem_reservation_total_claims;
  produced_runtime_filters_reservation_bytes = other2.produced_runtime_filters_reservation_bytes;
  consumed_runtime_filters_reservation_bytes = other2.consumed_runtime_filters_reservation_bytes;
  thread_reservation = other2.thread_reservation;
  __isset = other2.__isset;
  return *this;
}
TPlanFragment& TPlanFragment::operator=(TPlanFragment&& other3) {
  idx = std::move(other3.idx);
  display_name = std::move(other3.display_name);
  plan = std::move(other3.plan);
  output_sink = std::move(other3.output_sink);
  partition = std::move(other3.partition);
  backend_min_mem_reservation_bytes = std::move(other3.backend_min_mem_reservation_bytes);
  instance_min_mem_reservation_bytes = std::move(other3.instance_min_mem_reservation_bytes);
  instance_initial_mem_reservation_total_claims = std::move(other3.instance_initial_mem_reservation_total_claims);
  backend_initial_mem_reservation_total_claims = std::move(other3.backend_initial_mem_reservation_total_claims);
  produced_runtime_filters_reservation_bytes = std::move(other3.produced_runtime_filters_reservation_bytes);
  consumed_runtime_filters_reservation_bytes = std::move(other3.consumed_runtime_filters_reservation_bytes);
  thread_reservation = std::move(other3.thread_reservation);
  __isset = std::move(other3.__isset);
  return *this;
}
void TPlanFragment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanFragment(";
  out << "idx=" << to_string(idx);
  out << ", " << "display_name=" << to_string(display_name);
  out << ", " << "plan="; (__isset.plan ? (out << to_string(plan)) : (out << "<null>"));
  out << ", " << "output_sink="; (__isset.output_sink ? (out << to_string(output_sink)) : (out << "<null>"));
  out << ", " << "partition=" << to_string(partition);
  out << ", " << "backend_min_mem_reservation_bytes="; (__isset.backend_min_mem_reservation_bytes ? (out << to_string(backend_min_mem_reservation_bytes)) : (out << "<null>"));
  out << ", " << "instance_min_mem_reservation_bytes="; (__isset.instance_min_mem_reservation_bytes ? (out << to_string(instance_min_mem_reservation_bytes)) : (out << "<null>"));
  out << ", " << "instance_initial_mem_reservation_total_claims="; (__isset.instance_initial_mem_reservation_total_claims ? (out << to_string(instance_initial_mem_reservation_total_claims)) : (out << "<null>"));
  out << ", " << "backend_initial_mem_reservation_total_claims="; (__isset.backend_initial_mem_reservation_total_claims ? (out << to_string(backend_initial_mem_reservation_total_claims)) : (out << "<null>"));
  out << ", " << "produced_runtime_filters_reservation_bytes="; (__isset.produced_runtime_filters_reservation_bytes ? (out << to_string(produced_runtime_filters_reservation_bytes)) : (out << "<null>"));
  out << ", " << "consumed_runtime_filters_reservation_bytes="; (__isset.consumed_runtime_filters_reservation_bytes ? (out << to_string(consumed_runtime_filters_reservation_bytes)) : (out << "<null>"));
  out << ", " << "thread_reservation="; (__isset.thread_reservation ? (out << to_string(thread_reservation)) : (out << "<null>"));
  out << ")";
}


TScanRangeLocation::~TScanRangeLocation() throw() {
}


void TScanRangeLocation::__set_host_idx(const int32_t val) {
  this->host_idx = val;
}

void TScanRangeLocation::__set_volume_id(const int32_t val) {
  this->volume_id = val;
__isset.volume_id = true;
}

void TScanRangeLocation::__set_is_cached(const bool val) {
  this->is_cached = val;
__isset.is_cached = true;
}
std::ostream& operator<<(std::ostream& out, const TScanRangeLocation& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TScanRangeLocation &a, TScanRangeLocation &b) {
  using ::std::swap;
  swap(a.host_idx, b.host_idx);
  swap(a.volume_id, b.volume_id);
  swap(a.is_cached, b.is_cached);
  swap(a.__isset, b.__isset);
}

TScanRangeLocation::TScanRangeLocation(const TScanRangeLocation& other4) {
  host_idx = other4.host_idx;
  volume_id = other4.volume_id;
  is_cached = other4.is_cached;
  __isset = other4.__isset;
}
TScanRangeLocation::TScanRangeLocation( TScanRangeLocation&& other5) {
  host_idx = std::move(other5.host_idx);
  volume_id = std::move(other5.volume_id);
  is_cached = std::move(other5.is_cached);
  __isset = std::move(other5.__isset);
}
TScanRangeLocation& TScanRangeLocation::operator=(const TScanRangeLocation& other6) {
  host_idx = other6.host_idx;
  volume_id = other6.volume_id;
  is_cached = other6.is_cached;
  __isset = other6.__isset;
  return *this;
}
TScanRangeLocation& TScanRangeLocation::operator=(TScanRangeLocation&& other7) {
  host_idx = std::move(other7.host_idx);
  volume_id = std::move(other7.volume_id);
  is_cached = std::move(other7.is_cached);
  __isset = std::move(other7.__isset);
  return *this;
}
void TScanRangeLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScanRangeLocation(";
  out << "host_idx=" << to_string(host_idx);
  out << ", " << "volume_id="; (__isset.volume_id ? (out << to_string(volume_id)) : (out << "<null>"));
  out << ", " << "is_cached="; (__isset.is_cached ? (out << to_string(is_cached)) : (out << "<null>"));
  out << ")";
}


TScanRangeLocationList::~TScanRangeLocationList() throw() {
}


void TScanRangeLocationList::__set_scan_range(const  ::impala::TScanRange& val) {
  this->scan_range = val;
}

void TScanRangeLocationList::__set_locations(const std::vector<TScanRangeLocation> & val) {
  this->locations = val;
}
std::ostream& operator<<(std::ostream& out, const TScanRangeLocationList& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TScanRangeLocationList &a, TScanRangeLocationList &b) {
  using ::std::swap;
  swap(a.scan_range, b.scan_range);
  swap(a.locations, b.locations);
  swap(a.__isset, b.__isset);
}

TScanRangeLocationList::TScanRangeLocationList(const TScanRangeLocationList& other14) {
  scan_range = other14.scan_range;
  locations = other14.locations;
  __isset = other14.__isset;
}
TScanRangeLocationList::TScanRangeLocationList( TScanRangeLocationList&& other15) {
  scan_range = std::move(other15.scan_range);
  locations = std::move(other15.locations);
  __isset = std::move(other15.__isset);
}
TScanRangeLocationList& TScanRangeLocationList::operator=(const TScanRangeLocationList& other16) {
  scan_range = other16.scan_range;
  locations = other16.locations;
  __isset = other16.__isset;
  return *this;
}
TScanRangeLocationList& TScanRangeLocationList::operator=(TScanRangeLocationList&& other17) {
  scan_range = std::move(other17.scan_range);
  locations = std::move(other17.locations);
  __isset = std::move(other17.__isset);
  return *this;
}
void TScanRangeLocationList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScanRangeLocationList(";
  out << "scan_range=" << to_string(scan_range);
  out << ", " << "locations=" << to_string(locations);
  out << ")";
}


TScanRangeSpec::~TScanRangeSpec() throw() {
}


void TScanRangeSpec::__set_concrete_ranges(const std::vector<TScanRangeLocationList> & val) {
  this->concrete_ranges = val;
__isset.concrete_ranges = true;
}

void TScanRangeSpec::__set_split_specs(const std::vector< ::impala::TFileSplitGeneratorSpec> & val) {
  this->split_specs = val;
__isset.split_specs = true;
}
std::ostream& operator<<(std::ostream& out, const TScanRangeSpec& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TScanRangeSpec &a, TScanRangeSpec &b) {
  using ::std::swap;
  swap(a.concrete_ranges, b.concrete_ranges);
  swap(a.split_specs, b.split_specs);
  swap(a.__isset, b.__isset);
}

TScanRangeSpec::TScanRangeSpec(const TScanRangeSpec& other30) {
  concrete_ranges = other30.concrete_ranges;
  split_specs = other30.split_specs;
  __isset = other30.__isset;
}
TScanRangeSpec::TScanRangeSpec( TScanRangeSpec&& other31) {
  concrete_ranges = std::move(other31.concrete_ranges);
  split_specs = std::move(other31.split_specs);
  __isset = std::move(other31.__isset);
}
TScanRangeSpec& TScanRangeSpec::operator=(const TScanRangeSpec& other32) {
  concrete_ranges = other32.concrete_ranges;
  split_specs = other32.split_specs;
  __isset = other32.__isset;
  return *this;
}
TScanRangeSpec& TScanRangeSpec::operator=(TScanRangeSpec&& other33) {
  concrete_ranges = std::move(other33.concrete_ranges);
  split_specs = std::move(other33.split_specs);
  __isset = std::move(other33.__isset);
  return *this;
}
void TScanRangeSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScanRangeSpec(";
  out << "concrete_ranges="; (__isset.concrete_ranges ? (out << to_string(concrete_ranges)) : (out << "<null>"));
  out << ", " << "split_specs="; (__isset.split_specs ? (out << to_string(split_specs)) : (out << "<null>"));
  out << ")";
}


TPlanFragmentTree::~TPlanFragmentTree() throw() {
}


void TPlanFragmentTree::__set_cohort_id(const int32_t val) {
  this->cohort_id = val;
}

void TPlanFragmentTree::__set_fragments(const std::vector<TPlanFragment> & val) {
  this->fragments = val;
}
std::ostream& operator<<(std::ostream& out, const TPlanFragmentTree& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPlanFragmentTree &a, TPlanFragmentTree &b) {
  using ::std::swap;
  swap(a.cohort_id, b.cohort_id);
  swap(a.fragments, b.fragments);
}

TPlanFragmentTree::TPlanFragmentTree(const TPlanFragmentTree& other40) {
  cohort_id = other40.cohort_id;
  fragments = other40.fragments;
}
TPlanFragmentTree::TPlanFragmentTree( TPlanFragmentTree&& other41) {
  cohort_id = std::move(other41.cohort_id);
  fragments = std::move(other41.fragments);
}
TPlanFragmentTree& TPlanFragmentTree::operator=(const TPlanFragmentTree& other42) {
  cohort_id = other42.cohort_id;
  fragments = other42.fragments;
  return *this;
}
TPlanFragmentTree& TPlanFragmentTree::operator=(TPlanFragmentTree&& other43) {
  cohort_id = std::move(other43.cohort_id);
  fragments = std::move(other43.fragments);
  return *this;
}
void TPlanFragmentTree::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanFragmentTree(";
  out << "cohort_id=" << to_string(cohort_id);
  out << ", " << "fragments=" << to_string(fragments);
  out << ")";
}

} // namespace
