/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Query_TYPES_H
#define Query_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "Types_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "Descriptors_types.h"
#include "Results_types.h"
#include "CatalogObjects_types.h"
#include "LineageGraph_types.h"


namespace impala {

struct TSchemaResolutionStrategy {
  enum type {
    POSITION = 0,
    NAME = 1,
    FIELD_ID = 2
  };
};

extern const std::map<int, const char*> _TSchemaResolutionStrategy_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSchemaResolutionStrategy::type& val);

struct TTransactionalType {
  enum type {
    NONE = 0,
    INSERT_ONLY = 1
  };
};

extern const std::map<int, const char*> _TTransactionalType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TTransactionalType::type& val);

struct TKuduReadMode {
  enum type {
    DEFAULT = 0,
    READ_LATEST = 1,
    READ_AT_SNAPSHOT = 2
  };
};

extern const std::map<int, const char*> _TKuduReadMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TKuduReadMode::type& val);

struct TKuduReplicaSelection {
  enum type {
    LEADER_ONLY = 0,
    CLOSEST_REPLICA = 1
  };
};

extern const std::map<int, const char*> _TKuduReplicaSelection_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TKuduReplicaSelection::type& val);

struct TJoinDistributionMode {
  enum type {
    BROADCAST = 0,
    SHUFFLE = 1
  };
};

extern const std::map<int, const char*> _TJoinDistributionMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TJoinDistributionMode::type& val);

struct TParquetArrayResolution {
  enum type {
    THREE_LEVEL = 0,
    TWO_LEVEL = 1,
    TWO_LEVEL_THEN_THREE_LEVEL = 2
  };
};

extern const std::map<int, const char*> _TParquetArrayResolution_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TParquetArrayResolution::type& val);

struct TParquetTimestampType {
  enum type {
    INT96_NANOS = 0,
    INT64_MILLIS = 1,
    INT64_MICROS = 2,
    INT64_NANOS = 3
  };
};

extern const std::map<int, const char*> _TParquetTimestampType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TParquetTimestampType::type& val);

struct TMinmaxFilterFastCodePathMode {
  enum type {
    OFF = 0,
    ON = 1,
    VERIFICATION = 2
  };
};

extern const std::map<int, const char*> _TMinmaxFilterFastCodePathMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TMinmaxFilterFastCodePathMode::type& val);

struct TParquetBloomFilterWrite {
  enum type {
    NEVER = 0,
    IF_NO_DICT = 1,
    ALWAYS = 2
  };
};

extern const std::map<int, const char*> _TParquetBloomFilterWrite_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TParquetBloomFilterWrite::type& val);

struct TSessionType {
  enum type {
    BEESWAX = 0,
    HIVESERVER2 = 1,
    EXTERNAL_FRONTEND = 2
  };
};

extern const std::map<int, const char*> _TSessionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSessionType::type& val);

class TQueryOptions;

class TClientRequest;

class TSessionState;

class TQueryCtx;

class TPlanExecInfo;

class TFinalizeParams;

class TQueryExecRequest;

typedef struct _TQueryOptions__isset {
  _TQueryOptions__isset() : abort_on_error(true), max_errors(true), disable_codegen(true), batch_size(true), num_nodes(true), max_scan_range_length(true), num_scanner_threads(true), debug_action(true), mem_limit(true), compression_codec(false), hbase_caching(true), hbase_cache_blocks(true), parquet_file_size(true), explain_level(true), sync_ddl(true), request_pool(false), disable_outermost_topn(true), query_timeout_s(true), buffer_pool_limit(false), appx_count_distinct(true), disable_unsafe_spills(true), exec_single_node_rows_threshold(true), optimize_partition_key_scans(true), replica_preference(true), schedule_random_replica(true), disable_streaming_preaggregations(true), runtime_filter_mode(true), runtime_bloom_filter_size(true), runtime_filter_wait_time_ms(true), disable_row_runtime_filtering(true), max_num_runtime_filters(true), parquet_annotate_strings_utf8(true), parquet_fallback_schema_resolution(true), mt_dop(false), s3_skip_insert_staging(true), runtime_filter_min_size(true), runtime_filter_max_size(true), prefetch_mode(true), strict_mode(true), scratch_limit(true), enable_expr_rewrites(true), decimal_v2(true), parquet_dictionary_filtering(true), parquet_array_resolution(true), parquet_read_statistics(true), default_join_distribution_mode(true), disable_codegen_rows_threshold(true), default_spillable_buffer_size(true), min_spillable_buffer_size(true), max_row_size(true), idle_session_timeout(false), compute_stats_min_sample_size(true), exec_time_limit_s(true), shuffle_distinct_exprs(true), max_mem_estimate_for_admission(true), thread_reservation_limit(true), thread_reservation_aggregate_limit(true), kudu_read_mode(true), allow_erasure_coded_files(true), timezone(true), scan_bytes_limit(true), cpu_limit_s(true), topn_bytes_limit(true), client_identifier(false), resource_trace_ratio(true), num_remote_executor_candidates(true), num_rows_produced_limit(true), planner_testcase_mode(true), default_file_format(true), parquet_timestamp_type(true), parquet_read_page_index(true), parquet_write_page_index(true), parquet_page_row_count_limit(false), disable_hdfs_num_rows_estimate(true), default_hints_insert_statement(false), spool_query_results(true), default_transactional_type(true), statement_expression_limit(true), max_statement_length_bytes(true), disable_data_cache(true), max_result_spooling_mem(true), max_spilled_result_spooling_mem(true), disable_hbase_num_rows_estimate(true), fetch_rows_timeout_ms(true), now_string(true), parquet_object_store_split_size(true), mem_limit_executors(true), broadcast_bytes_limit(true), preagg_bytes_limit(true), enable_cnf_rewrites(true), max_cnf_exprs(true), kudu_snapshot_read_timestamp_micros(true), retry_failed_queries(true), enabled_runtime_filter_types(true), async_codegen(true), enable_distinct_semi_join_optimization(true), sort_run_bytes_limit(true), max_fs_writers(true), refresh_updated_hms_partitions(true), spool_all_results_for_retries(true), runtime_filter_error_rate(false), use_local_tz_for_unix_timestamp_conversions(true), convert_legacy_hive_parquet_utc_timestamps(true), enable_outer_join_to_inner_transformation(true), targeted_kudu_scan_range_length(true), report_skew_limit(true), optimize_simple_limit(true), use_dop_for_costing(true), broadcast_to_partition_factor(true), join_rows_produced_limit(true), utf8_mode(true), analytic_rank_pushdown_threshold(true), minmax_filter_threshold(true), minmax_filtering_level(true), compute_column_minmax_stats(true), show_column_minmax_stats(true), default_ndv_scale(true), kudu_replica_selection(true), delete_stats_in_truncate(true), parquet_bloom_filtering(true), minmax_filter_sorted_columns(true), minmax_filter_fast_code_path(true), enable_kudu_transaction(true), minmax_filter_partition_columns(true), parquet_bloom_filter_write(true), orc_read_statistics(true), enable_async_ddl_execution(true), enable_async_load_data_execution(true), parquet_late_materialization_threshold(true), parquet_dictionary_runtime_filter_entry_limit(true), abort_java_udf_on_exception(true), orc_async_read(true), runtime_in_list_filter_entry_limit(true) {}
  bool abort_on_error :1;
  bool max_errors :1;
  bool disable_codegen :1;
  bool batch_size :1;
  bool num_nodes :1;
  bool max_scan_range_length :1;
  bool num_scanner_threads :1;
  bool debug_action :1;
  bool mem_limit :1;
  bool compression_codec :1;
  bool hbase_caching :1;
  bool hbase_cache_blocks :1;
  bool parquet_file_size :1;
  bool explain_level :1;
  bool sync_ddl :1;
  bool request_pool :1;
  bool disable_outermost_topn :1;
  bool query_timeout_s :1;
  bool buffer_pool_limit :1;
  bool appx_count_distinct :1;
  bool disable_unsafe_spills :1;
  bool exec_single_node_rows_threshold :1;
  bool optimize_partition_key_scans :1;
  bool replica_preference :1;
  bool schedule_random_replica :1;
  bool disable_streaming_preaggregations :1;
  bool runtime_filter_mode :1;
  bool runtime_bloom_filter_size :1;
  bool runtime_filter_wait_time_ms :1;
  bool disable_row_runtime_filtering :1;
  bool max_num_runtime_filters :1;
  bool parquet_annotate_strings_utf8 :1;
  bool parquet_fallback_schema_resolution :1;
  bool mt_dop :1;
  bool s3_skip_insert_staging :1;
  bool runtime_filter_min_size :1;
  bool runtime_filter_max_size :1;
  bool prefetch_mode :1;
  bool strict_mode :1;
  bool scratch_limit :1;
  bool enable_expr_rewrites :1;
  bool decimal_v2 :1;
  bool parquet_dictionary_filtering :1;
  bool parquet_array_resolution :1;
  bool parquet_read_statistics :1;
  bool default_join_distribution_mode :1;
  bool disable_codegen_rows_threshold :1;
  bool default_spillable_buffer_size :1;
  bool min_spillable_buffer_size :1;
  bool max_row_size :1;
  bool idle_session_timeout :1;
  bool compute_stats_min_sample_size :1;
  bool exec_time_limit_s :1;
  bool shuffle_distinct_exprs :1;
  bool max_mem_estimate_for_admission :1;
  bool thread_reservation_limit :1;
  bool thread_reservation_aggregate_limit :1;
  bool kudu_read_mode :1;
  bool allow_erasure_coded_files :1;
  bool timezone :1;
  bool scan_bytes_limit :1;
  bool cpu_limit_s :1;
  bool topn_bytes_limit :1;
  bool client_identifier :1;
  bool resource_trace_ratio :1;
  bool num_remote_executor_candidates :1;
  bool num_rows_produced_limit :1;
  bool planner_testcase_mode :1;
  bool default_file_format :1;
  bool parquet_timestamp_type :1;
  bool parquet_read_page_index :1;
  bool parquet_write_page_index :1;
  bool parquet_page_row_count_limit :1;
  bool disable_hdfs_num_rows_estimate :1;
  bool default_hints_insert_statement :1;
  bool spool_query_results :1;
  bool default_transactional_type :1;
  bool statement_expression_limit :1;
  bool max_statement_length_bytes :1;
  bool disable_data_cache :1;
  bool max_result_spooling_mem :1;
  bool max_spilled_result_spooling_mem :1;
  bool disable_hbase_num_rows_estimate :1;
  bool fetch_rows_timeout_ms :1;
  bool now_string :1;
  bool parquet_object_store_split_size :1;
  bool mem_limit_executors :1;
  bool broadcast_bytes_limit :1;
  bool preagg_bytes_limit :1;
  bool enable_cnf_rewrites :1;
  bool max_cnf_exprs :1;
  bool kudu_snapshot_read_timestamp_micros :1;
  bool retry_failed_queries :1;
  bool enabled_runtime_filter_types :1;
  bool async_codegen :1;
  bool enable_distinct_semi_join_optimization :1;
  bool sort_run_bytes_limit :1;
  bool max_fs_writers :1;
  bool refresh_updated_hms_partitions :1;
  bool spool_all_results_for_retries :1;
  bool runtime_filter_error_rate :1;
  bool use_local_tz_for_unix_timestamp_conversions :1;
  bool convert_legacy_hive_parquet_utc_timestamps :1;
  bool enable_outer_join_to_inner_transformation :1;
  bool targeted_kudu_scan_range_length :1;
  bool report_skew_limit :1;
  bool optimize_simple_limit :1;
  bool use_dop_for_costing :1;
  bool broadcast_to_partition_factor :1;
  bool join_rows_produced_limit :1;
  bool utf8_mode :1;
  bool analytic_rank_pushdown_threshold :1;
  bool minmax_filter_threshold :1;
  bool minmax_filtering_level :1;
  bool compute_column_minmax_stats :1;
  bool show_column_minmax_stats :1;
  bool default_ndv_scale :1;
  bool kudu_replica_selection :1;
  bool delete_stats_in_truncate :1;
  bool parquet_bloom_filtering :1;
  bool minmax_filter_sorted_columns :1;
  bool minmax_filter_fast_code_path :1;
  bool enable_kudu_transaction :1;
  bool minmax_filter_partition_columns :1;
  bool parquet_bloom_filter_write :1;
  bool orc_read_statistics :1;
  bool enable_async_ddl_execution :1;
  bool enable_async_load_data_execution :1;
  bool parquet_late_materialization_threshold :1;
  bool parquet_dictionary_runtime_filter_entry_limit :1;
  bool abort_java_udf_on_exception :1;
  bool orc_async_read :1;
  bool runtime_in_list_filter_entry_limit :1;
} _TQueryOptions__isset;

class TQueryOptions {
 public:

  TQueryOptions(const TQueryOptions&);
  TQueryOptions(TQueryOptions&&);
  TQueryOptions& operator=(const TQueryOptions&);
  TQueryOptions& operator=(TQueryOptions&&);
  TQueryOptions() : abort_on_error(false), max_errors(100), disable_codegen(false), batch_size(0), num_nodes(0), max_scan_range_length(0LL), num_scanner_threads(0), debug_action(""), mem_limit(0LL), hbase_caching(0), hbase_cache_blocks(false), parquet_file_size(0LL), explain_level(( ::impala::TExplainLevel::type)1), sync_ddl(false), request_pool(), disable_outermost_topn(false), query_timeout_s(0), buffer_pool_limit(0), appx_count_distinct(false), disable_unsafe_spills(false), exec_single_node_rows_threshold(100), optimize_partition_key_scans(false), replica_preference(( ::impala::TReplicaPreference::type)0), schedule_random_replica(false), disable_streaming_preaggregations(false), runtime_filter_mode(( ::impala::TRuntimeFilterMode::type)2), runtime_bloom_filter_size(1048576), runtime_filter_wait_time_ms(0), disable_row_runtime_filtering(false), max_num_runtime_filters(10), parquet_annotate_strings_utf8(false), parquet_fallback_schema_resolution((TSchemaResolutionStrategy::type)0), mt_dop(0), s3_skip_insert_staging(true), runtime_filter_min_size(1048576), runtime_filter_max_size(16777216), prefetch_mode(( ::impala::TPrefetchMode::type)1), strict_mode(false), scratch_limit(-1LL), enable_expr_rewrites(true), decimal_v2(true), parquet_dictionary_filtering(true), parquet_array_resolution((TParquetArrayResolution::type)0), parquet_read_statistics(true), default_join_distribution_mode((TJoinDistributionMode::type)0), disable_codegen_rows_threshold(50000), default_spillable_buffer_size(2097152LL), min_spillable_buffer_size(65536LL), max_row_size(524288LL), idle_session_timeout(0), compute_stats_min_sample_size(1073741824LL), exec_time_limit_s(0), shuffle_distinct_exprs(true), max_mem_estimate_for_admission(0LL), thread_reservation_limit(3000), thread_reservation_aggregate_limit(0), kudu_read_mode((TKuduReadMode::type)0), allow_erasure_coded_files(false), timezone(""), scan_bytes_limit(0LL), cpu_limit_s(0LL), topn_bytes_limit(536870912LL), client_identifier(), resource_trace_ratio(0), num_remote_executor_candidates(3), num_rows_produced_limit(0LL), planner_testcase_mode(false), default_file_format(( ::impala::THdfsFileFormat::type)0), parquet_timestamp_type((TParquetTimestampType::type)0), parquet_read_page_index(true), parquet_write_page_index(true), parquet_page_row_count_limit(0), disable_hdfs_num_rows_estimate(false), default_hints_insert_statement(), spool_query_results(true), default_transactional_type((TTransactionalType::type)0), statement_expression_limit(250000), max_statement_length_bytes(16777216), disable_data_cache(false), max_result_spooling_mem(104857600LL), max_spilled_result_spooling_mem(1073741824LL), disable_hbase_num_rows_estimate(false), fetch_rows_timeout_ms(10000LL), now_string(""), parquet_object_store_split_size(268435456LL), mem_limit_executors(0LL), broadcast_bytes_limit(34359738368LL), preagg_bytes_limit(-1LL), enable_cnf_rewrites(true), max_cnf_exprs(200), kudu_snapshot_read_timestamp_micros(0LL), retry_failed_queries(false), async_codegen(false), enable_distinct_semi_join_optimization(true), sort_run_bytes_limit(-1LL), max_fs_writers(0), refresh_updated_hms_partitions(false), spool_all_results_for_retries(true), runtime_filter_error_rate(0), use_local_tz_for_unix_timestamp_conversions(false), convert_legacy_hive_parquet_utc_timestamps(false), enable_outer_join_to_inner_transformation(false), targeted_kudu_scan_range_length(-1LL), report_skew_limit(1), optimize_simple_limit(false), use_dop_for_costing(true), broadcast_to_partition_factor(1), join_rows_produced_limit(0LL), utf8_mode(false), analytic_rank_pushdown_threshold(1000LL), minmax_filter_threshold(0), minmax_filtering_level(( ::impala::TMinmaxFilteringLevel::type)1), compute_column_minmax_stats(false), show_column_minmax_stats(false), default_ndv_scale(2), kudu_replica_selection((TKuduReplicaSelection::type)1), delete_stats_in_truncate(true), parquet_bloom_filtering(true), minmax_filter_sorted_columns(true), minmax_filter_fast_code_path((TMinmaxFilterFastCodePathMode::type)1), enable_kudu_transaction(false), minmax_filter_partition_columns(true), parquet_bloom_filter_write((TParquetBloomFilterWrite::type)1), orc_read_statistics(true), enable_async_ddl_execution(true), enable_async_load_data_execution(true), parquet_late_materialization_threshold(20), parquet_dictionary_runtime_filter_entry_limit(1024), abort_java_udf_on_exception(false), orc_async_read(true), runtime_in_list_filter_entry_limit(1024) {
    explain_level = ( ::impala::TExplainLevel::type)1;

    replica_preference = ( ::impala::TReplicaPreference::type)0;

    runtime_filter_mode = ( ::impala::TRuntimeFilterMode::type)2;

    parquet_fallback_schema_resolution = (TSchemaResolutionStrategy::type)0;

    prefetch_mode = ( ::impala::TPrefetchMode::type)1;

    parquet_array_resolution = (TParquetArrayResolution::type)0;

    default_join_distribution_mode = (TJoinDistributionMode::type)0;

    kudu_read_mode = (TKuduReadMode::type)0;

    default_file_format = ( ::impala::THdfsFileFormat::type)0;

    parquet_timestamp_type = (TParquetTimestampType::type)0;

    default_transactional_type = (TTransactionalType::type)0;

    enabled_runtime_filter_types.insert(( ::impala::TRuntimeFilterType::type)0);
    enabled_runtime_filter_types.insert(( ::impala::TRuntimeFilterType::type)1);

    minmax_filtering_level = ( ::impala::TMinmaxFilteringLevel::type)1;

    kudu_replica_selection = (TKuduReplicaSelection::type)1;

    minmax_filter_fast_code_path = (TMinmaxFilterFastCodePathMode::type)1;

    parquet_bloom_filter_write = (TParquetBloomFilterWrite::type)1;

  }

  virtual ~TQueryOptions() throw();
  bool abort_on_error;
  int32_t max_errors;
  bool disable_codegen;
  int32_t batch_size;
  int32_t num_nodes;
  int64_t max_scan_range_length;
  int32_t num_scanner_threads;
  std::string debug_action;
  int64_t mem_limit;
   ::impala::TCompressionCodec compression_codec;
  int32_t hbase_caching;
  bool hbase_cache_blocks;
  int64_t parquet_file_size;
   ::impala::TExplainLevel::type explain_level;
  bool sync_ddl;
  std::string request_pool;
  bool disable_outermost_topn;
  int32_t query_timeout_s;
  int64_t buffer_pool_limit;
  bool appx_count_distinct;
  bool disable_unsafe_spills;
  int32_t exec_single_node_rows_threshold;
  bool optimize_partition_key_scans;
   ::impala::TReplicaPreference::type replica_preference;
  bool schedule_random_replica;
  bool disable_streaming_preaggregations;
   ::impala::TRuntimeFilterMode::type runtime_filter_mode;
  int32_t runtime_bloom_filter_size;
  int32_t runtime_filter_wait_time_ms;
  bool disable_row_runtime_filtering;
  int32_t max_num_runtime_filters;
  bool parquet_annotate_strings_utf8;
  TSchemaResolutionStrategy::type parquet_fallback_schema_resolution;
  int32_t mt_dop;
  bool s3_skip_insert_staging;
  int32_t runtime_filter_min_size;
  int32_t runtime_filter_max_size;
   ::impala::TPrefetchMode::type prefetch_mode;
  bool strict_mode;
  int64_t scratch_limit;
  bool enable_expr_rewrites;
  bool decimal_v2;
  bool parquet_dictionary_filtering;
  TParquetArrayResolution::type parquet_array_resolution;
  bool parquet_read_statistics;
  TJoinDistributionMode::type default_join_distribution_mode;
  int32_t disable_codegen_rows_threshold;
  int64_t default_spillable_buffer_size;
  int64_t min_spillable_buffer_size;
  int64_t max_row_size;
  int32_t idle_session_timeout;
  int64_t compute_stats_min_sample_size;
  int32_t exec_time_limit_s;
  bool shuffle_distinct_exprs;
  int64_t max_mem_estimate_for_admission;
  int32_t thread_reservation_limit;
  int32_t thread_reservation_aggregate_limit;
  TKuduReadMode::type kudu_read_mode;
  bool allow_erasure_coded_files;
  std::string timezone;
  int64_t scan_bytes_limit;
  int64_t cpu_limit_s;
  int64_t topn_bytes_limit;
  std::string client_identifier;
  double resource_trace_ratio;
  int32_t num_remote_executor_candidates;
  int64_t num_rows_produced_limit;
  bool planner_testcase_mode;
   ::impala::THdfsFileFormat::type default_file_format;
  TParquetTimestampType::type parquet_timestamp_type;
  bool parquet_read_page_index;
  bool parquet_write_page_index;
  int32_t parquet_page_row_count_limit;
  bool disable_hdfs_num_rows_estimate;
  std::string default_hints_insert_statement;
  bool spool_query_results;
  TTransactionalType::type default_transactional_type;
  int32_t statement_expression_limit;
  int32_t max_statement_length_bytes;
  bool disable_data_cache;
  int64_t max_result_spooling_mem;
  int64_t max_spilled_result_spooling_mem;
  bool disable_hbase_num_rows_estimate;
  int64_t fetch_rows_timeout_ms;
  std::string now_string;
  int64_t parquet_object_store_split_size;
  int64_t mem_limit_executors;
  int64_t broadcast_bytes_limit;
  int64_t preagg_bytes_limit;
  bool enable_cnf_rewrites;
  int32_t max_cnf_exprs;
  int64_t kudu_snapshot_read_timestamp_micros;
  bool retry_failed_queries;
  std::set< ::impala::TRuntimeFilterType::type>  enabled_runtime_filter_types;
  bool async_codegen;
  bool enable_distinct_semi_join_optimization;
  int64_t sort_run_bytes_limit;
  int32_t max_fs_writers;
  bool refresh_updated_hms_partitions;
  bool spool_all_results_for_retries;
  double runtime_filter_error_rate;
  bool use_local_tz_for_unix_timestamp_conversions;
  bool convert_legacy_hive_parquet_utc_timestamps;
  bool enable_outer_join_to_inner_transformation;
  int64_t targeted_kudu_scan_range_length;
  double report_skew_limit;
  bool optimize_simple_limit;
  bool use_dop_for_costing;
  double broadcast_to_partition_factor;
  int64_t join_rows_produced_limit;
  bool utf8_mode;
  int64_t analytic_rank_pushdown_threshold;
  double minmax_filter_threshold;
   ::impala::TMinmaxFilteringLevel::type minmax_filtering_level;
  bool compute_column_minmax_stats;
  bool show_column_minmax_stats;
  int32_t default_ndv_scale;
  TKuduReplicaSelection::type kudu_replica_selection;
  bool delete_stats_in_truncate;
  bool parquet_bloom_filtering;
  bool minmax_filter_sorted_columns;
  TMinmaxFilterFastCodePathMode::type minmax_filter_fast_code_path;
  bool enable_kudu_transaction;
  bool minmax_filter_partition_columns;
  TParquetBloomFilterWrite::type parquet_bloom_filter_write;
  bool orc_read_statistics;
  bool enable_async_ddl_execution;
  bool enable_async_load_data_execution;
  int32_t parquet_late_materialization_threshold;
  int32_t parquet_dictionary_runtime_filter_entry_limit;
  bool abort_java_udf_on_exception;
  bool orc_async_read;
  int32_t runtime_in_list_filter_entry_limit;

  _TQueryOptions__isset __isset;

  void __set_abort_on_error(const bool val);

  void __set_max_errors(const int32_t val);

  void __set_disable_codegen(const bool val);

  void __set_batch_size(const int32_t val);

  void __set_num_nodes(const int32_t val);

  void __set_max_scan_range_length(const int64_t val);

  void __set_num_scanner_threads(const int32_t val);

  void __set_debug_action(const std::string& val);

  void __set_mem_limit(const int64_t val);

  void __set_compression_codec(const  ::impala::TCompressionCodec& val);

  void __set_hbase_caching(const int32_t val);

  void __set_hbase_cache_blocks(const bool val);

  void __set_parquet_file_size(const int64_t val);

  void __set_explain_level(const  ::impala::TExplainLevel::type val);

  void __set_sync_ddl(const bool val);

  void __set_request_pool(const std::string& val);

  void __set_disable_outermost_topn(const bool val);

  void __set_query_timeout_s(const int32_t val);

  void __set_buffer_pool_limit(const int64_t val);

  void __set_appx_count_distinct(const bool val);

  void __set_disable_unsafe_spills(const bool val);

  void __set_exec_single_node_rows_threshold(const int32_t val);

  void __set_optimize_partition_key_scans(const bool val);

  void __set_replica_preference(const  ::impala::TReplicaPreference::type val);

  void __set_schedule_random_replica(const bool val);

  void __set_disable_streaming_preaggregations(const bool val);

  void __set_runtime_filter_mode(const  ::impala::TRuntimeFilterMode::type val);

  void __set_runtime_bloom_filter_size(const int32_t val);

  void __set_runtime_filter_wait_time_ms(const int32_t val);

  void __set_disable_row_runtime_filtering(const bool val);

  void __set_max_num_runtime_filters(const int32_t val);

  void __set_parquet_annotate_strings_utf8(const bool val);

  void __set_parquet_fallback_schema_resolution(const TSchemaResolutionStrategy::type val);

  void __set_mt_dop(const int32_t val);

  void __set_s3_skip_insert_staging(const bool val);

  void __set_runtime_filter_min_size(const int32_t val);

  void __set_runtime_filter_max_size(const int32_t val);

  void __set_prefetch_mode(const  ::impala::TPrefetchMode::type val);

  void __set_strict_mode(const bool val);

  void __set_scratch_limit(const int64_t val);

  void __set_enable_expr_rewrites(const bool val);

  void __set_decimal_v2(const bool val);

  void __set_parquet_dictionary_filtering(const bool val);

  void __set_parquet_array_resolution(const TParquetArrayResolution::type val);

  void __set_parquet_read_statistics(const bool val);

  void __set_default_join_distribution_mode(const TJoinDistributionMode::type val);

  void __set_disable_codegen_rows_threshold(const int32_t val);

  void __set_default_spillable_buffer_size(const int64_t val);

  void __set_min_spillable_buffer_size(const int64_t val);

  void __set_max_row_size(const int64_t val);

  void __set_idle_session_timeout(const int32_t val);

  void __set_compute_stats_min_sample_size(const int64_t val);

  void __set_exec_time_limit_s(const int32_t val);

  void __set_shuffle_distinct_exprs(const bool val);

  void __set_max_mem_estimate_for_admission(const int64_t val);

  void __set_thread_reservation_limit(const int32_t val);

  void __set_thread_reservation_aggregate_limit(const int32_t val);

  void __set_kudu_read_mode(const TKuduReadMode::type val);

  void __set_allow_erasure_coded_files(const bool val);

  void __set_timezone(const std::string& val);

  void __set_scan_bytes_limit(const int64_t val);

  void __set_cpu_limit_s(const int64_t val);

  void __set_topn_bytes_limit(const int64_t val);

  void __set_client_identifier(const std::string& val);

  void __set_resource_trace_ratio(const double val);

  void __set_num_remote_executor_candidates(const int32_t val);

  void __set_num_rows_produced_limit(const int64_t val);

  void __set_planner_testcase_mode(const bool val);

  void __set_default_file_format(const  ::impala::THdfsFileFormat::type val);

  void __set_parquet_timestamp_type(const TParquetTimestampType::type val);

  void __set_parquet_read_page_index(const bool val);

  void __set_parquet_write_page_index(const bool val);

  void __set_parquet_page_row_count_limit(const int32_t val);

  void __set_disable_hdfs_num_rows_estimate(const bool val);

  void __set_default_hints_insert_statement(const std::string& val);

  void __set_spool_query_results(const bool val);

  void __set_default_transactional_type(const TTransactionalType::type val);

  void __set_statement_expression_limit(const int32_t val);

  void __set_max_statement_length_bytes(const int32_t val);

  void __set_disable_data_cache(const bool val);

  void __set_max_result_spooling_mem(const int64_t val);

  void __set_max_spilled_result_spooling_mem(const int64_t val);

  void __set_disable_hbase_num_rows_estimate(const bool val);

  void __set_fetch_rows_timeout_ms(const int64_t val);

  void __set_now_string(const std::string& val);

  void __set_parquet_object_store_split_size(const int64_t val);

  void __set_mem_limit_executors(const int64_t val);

  void __set_broadcast_bytes_limit(const int64_t val);

  void __set_preagg_bytes_limit(const int64_t val);

  void __set_enable_cnf_rewrites(const bool val);

  void __set_max_cnf_exprs(const int32_t val);

  void __set_kudu_snapshot_read_timestamp_micros(const int64_t val);

  void __set_retry_failed_queries(const bool val);

  void __set_enabled_runtime_filter_types(const std::set< ::impala::TRuntimeFilterType::type> & val);

  void __set_async_codegen(const bool val);

  void __set_enable_distinct_semi_join_optimization(const bool val);

  void __set_sort_run_bytes_limit(const int64_t val);

  void __set_max_fs_writers(const int32_t val);

  void __set_refresh_updated_hms_partitions(const bool val);

  void __set_spool_all_results_for_retries(const bool val);

  void __set_runtime_filter_error_rate(const double val);

  void __set_use_local_tz_for_unix_timestamp_conversions(const bool val);

  void __set_convert_legacy_hive_parquet_utc_timestamps(const bool val);

  void __set_enable_outer_join_to_inner_transformation(const bool val);

  void __set_targeted_kudu_scan_range_length(const int64_t val);

  void __set_report_skew_limit(const double val);

  void __set_optimize_simple_limit(const bool val);

  void __set_use_dop_for_costing(const bool val);

  void __set_broadcast_to_partition_factor(const double val);

  void __set_join_rows_produced_limit(const int64_t val);

  void __set_utf8_mode(const bool val);

  void __set_analytic_rank_pushdown_threshold(const int64_t val);

  void __set_minmax_filter_threshold(const double val);

  void __set_minmax_filtering_level(const  ::impala::TMinmaxFilteringLevel::type val);

  void __set_compute_column_minmax_stats(const bool val);

  void __set_show_column_minmax_stats(const bool val);

  void __set_default_ndv_scale(const int32_t val);

  void __set_kudu_replica_selection(const TKuduReplicaSelection::type val);

  void __set_delete_stats_in_truncate(const bool val);

  void __set_parquet_bloom_filtering(const bool val);

  void __set_minmax_filter_sorted_columns(const bool val);

  void __set_minmax_filter_fast_code_path(const TMinmaxFilterFastCodePathMode::type val);

  void __set_enable_kudu_transaction(const bool val);

  void __set_minmax_filter_partition_columns(const bool val);

  void __set_parquet_bloom_filter_write(const TParquetBloomFilterWrite::type val);

  void __set_orc_read_statistics(const bool val);

  void __set_enable_async_ddl_execution(const bool val);

  void __set_enable_async_load_data_execution(const bool val);

  void __set_parquet_late_materialization_threshold(const int32_t val);

  void __set_parquet_dictionary_runtime_filter_entry_limit(const int32_t val);

  void __set_abort_java_udf_on_exception(const bool val);

  void __set_orc_async_read(const bool val);

  void __set_runtime_in_list_filter_entry_limit(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryOptions &a, TQueryOptions &b);

std::ostream& operator<<(std::ostream& out, const TQueryOptions& obj);

typedef struct _TClientRequest__isset {
  _TClientRequest__isset() : redacted_stmt(false) {}
  bool redacted_stmt :1;
} _TClientRequest__isset;

class TClientRequest {
 public:

  TClientRequest(const TClientRequest&);
  TClientRequest(TClientRequest&&);
  TClientRequest& operator=(const TClientRequest&);
  TClientRequest& operator=(TClientRequest&&);
  TClientRequest() : stmt(), redacted_stmt() {
  }

  virtual ~TClientRequest() throw();
  std::string stmt;
  TQueryOptions query_options;
  std::string redacted_stmt;

  _TClientRequest__isset __isset;

  void __set_stmt(const std::string& val);

  void __set_query_options(const TQueryOptions& val);

  void __set_redacted_stmt(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TClientRequest &a, TClientRequest &b);

std::ostream& operator<<(std::ostream& out, const TClientRequest& obj);

typedef struct _TSessionState__isset {
  _TSessionState__isset() : delegated_user(false), kudu_latest_observed_ts(false) {}
  bool delegated_user :1;
  bool kudu_latest_observed_ts :1;
} _TSessionState__isset;

class TSessionState {
 public:

  TSessionState(const TSessionState&);
  TSessionState(TSessionState&&);
  TSessionState& operator=(const TSessionState&);
  TSessionState& operator=(TSessionState&&);
  TSessionState() : session_type((TSessionType::type)0), database(), connected_user(), delegated_user(), kudu_latest_observed_ts(0) {
  }

  virtual ~TSessionState() throw();
   ::impala::TUniqueId session_id;
  TSessionType::type session_type;
  std::string database;
  std::string connected_user;
  std::string delegated_user;
   ::impala::TNetworkAddress network_address;
  int64_t kudu_latest_observed_ts;

  _TSessionState__isset __isset;

  void __set_session_id(const  ::impala::TUniqueId& val);

  void __set_session_type(const TSessionType::type val);

  void __set_database(const std::string& val);

  void __set_connected_user(const std::string& val);

  void __set_delegated_user(const std::string& val);

  void __set_network_address(const  ::impala::TNetworkAddress& val);

  void __set_kudu_latest_observed_ts(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSessionState &a, TSessionState &b);

std::ostream& operator<<(std::ostream& out, const TSessionState& obj);

typedef struct _TQueryCtx__isset {
  _TQueryCtx__isset() : coord_hostname(false), coord_ip_address(false), tables_missing_stats(false), disable_spilling(false), parent_query_id(false), tables_with_corrupt_stats(false), snapshot_timestamp(true), desc_tbl_testonly(false), disable_codegen_hint(true), tables_missing_diskids(false), request_pool(false), disable_hbase_num_rows_estimate(true), status_report_interval_ms(false), status_report_max_retry_s(false), desc_tbl_serialized(false), transaction_id(false), overridden_mt_dop_value(false), coord_backend_id(false), gen_aggregated_profile(false) {}
  bool coord_hostname :1;
  bool coord_ip_address :1;
  bool tables_missing_stats :1;
  bool disable_spilling :1;
  bool parent_query_id :1;
  bool tables_with_corrupt_stats :1;
  bool snapshot_timestamp :1;
  bool desc_tbl_testonly :1;
  bool disable_codegen_hint :1;
  bool tables_missing_diskids :1;
  bool request_pool :1;
  bool disable_hbase_num_rows_estimate :1;
  bool status_report_interval_ms :1;
  bool status_report_max_retry_s :1;
  bool desc_tbl_serialized :1;
  bool transaction_id :1;
  bool overridden_mt_dop_value :1;
  bool coord_backend_id :1;
  bool gen_aggregated_profile :1;
} _TQueryCtx__isset;

class TQueryCtx {
 public:

  TQueryCtx(const TQueryCtx&);
  TQueryCtx(TQueryCtx&&);
  TQueryCtx& operator=(const TQueryCtx&);
  TQueryCtx& operator=(TQueryCtx&&);
  TQueryCtx() : now_string(), pid(0), coord_hostname(), disable_spilling(0), snapshot_timestamp(-1LL), start_unix_millis(0), disable_codegen_hint(false), request_pool(), utc_timestamp_string(), local_time_zone(), disable_hbase_num_rows_estimate(false), trace_resource_usage(false), status_report_interval_ms(0), status_report_max_retry_s(0), transaction_id(0), overridden_mt_dop_value(0), gen_aggregated_profile(0), is_kudu_transactional(false) {
  }

  virtual ~TQueryCtx() throw();
  TClientRequest client_request;
   ::impala::TUniqueId query_id;
  TSessionState session;
  std::string now_string;
  int32_t pid;
  std::string coord_hostname;
   ::impala::TNetworkAddress coord_ip_address;
  std::vector< ::impala::TTableName>  tables_missing_stats;
  bool disable_spilling;
   ::impala::TUniqueId parent_query_id;
  std::vector< ::impala::TTableName>  tables_with_corrupt_stats;
  int64_t snapshot_timestamp;
   ::impala::TDescriptorTable desc_tbl_testonly;
  int64_t start_unix_millis;
  bool disable_codegen_hint;
  std::vector< ::impala::TTableName>  tables_missing_diskids;
  std::string request_pool;
  std::string utc_timestamp_string;
  std::string local_time_zone;
  bool disable_hbase_num_rows_estimate;
  bool trace_resource_usage;
  int32_t status_report_interval_ms;
  int32_t status_report_max_retry_s;
   ::impala::TDescriptorTableSerialized desc_tbl_serialized;
  int64_t transaction_id;
  int32_t overridden_mt_dop_value;
   ::impala::TUniqueId coord_backend_id;
  bool gen_aggregated_profile;
  bool is_kudu_transactional;

  _TQueryCtx__isset __isset;

  void __set_client_request(const TClientRequest& val);

  void __set_query_id(const  ::impala::TUniqueId& val);

  void __set_session(const TSessionState& val);

  void __set_now_string(const std::string& val);

  void __set_pid(const int32_t val);

  void __set_coord_hostname(const std::string& val);

  void __set_coord_ip_address(const  ::impala::TNetworkAddress& val);

  void __set_tables_missing_stats(const std::vector< ::impala::TTableName> & val);

  void __set_disable_spilling(const bool val);

  void __set_parent_query_id(const  ::impala::TUniqueId& val);

  void __set_tables_with_corrupt_stats(const std::vector< ::impala::TTableName> & val);

  void __set_snapshot_timestamp(const int64_t val);

  void __set_desc_tbl_testonly(const  ::impala::TDescriptorTable& val);

  void __set_start_unix_millis(const int64_t val);

  void __set_disable_codegen_hint(const bool val);

  void __set_tables_missing_diskids(const std::vector< ::impala::TTableName> & val);

  void __set_request_pool(const std::string& val);

  void __set_utc_timestamp_string(const std::string& val);

  void __set_local_time_zone(const std::string& val);

  void __set_disable_hbase_num_rows_estimate(const bool val);

  void __set_trace_resource_usage(const bool val);

  void __set_status_report_interval_ms(const int32_t val);

  void __set_status_report_max_retry_s(const int32_t val);

  void __set_desc_tbl_serialized(const  ::impala::TDescriptorTableSerialized& val);

  void __set_transaction_id(const int64_t val);

  void __set_overridden_mt_dop_value(const int32_t val);

  void __set_coord_backend_id(const  ::impala::TUniqueId& val);

  void __set_gen_aggregated_profile(const bool val);

  void __set_is_kudu_transactional(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryCtx &a, TQueryCtx &b);

std::ostream& operator<<(std::ostream& out, const TQueryCtx& obj);

typedef struct _TPlanExecInfo__isset {
  _TPlanExecInfo__isset() : per_node_scan_ranges(false) {}
  bool per_node_scan_ranges :1;
} _TPlanExecInfo__isset;

class TPlanExecInfo {
 public:

  TPlanExecInfo(const TPlanExecInfo&);
  TPlanExecInfo(TPlanExecInfo&&);
  TPlanExecInfo& operator=(const TPlanExecInfo&);
  TPlanExecInfo& operator=(TPlanExecInfo&&);
  TPlanExecInfo() {
  }

  virtual ~TPlanExecInfo() throw();
  std::vector< ::impala::TPlanFragment>  fragments;
  std::map< ::impala::TPlanNodeId,  ::impala::TScanRangeSpec>  per_node_scan_ranges;

  _TPlanExecInfo__isset __isset;

  void __set_fragments(const std::vector< ::impala::TPlanFragment> & val);

  void __set_per_node_scan_ranges(const std::map< ::impala::TPlanNodeId,  ::impala::TScanRangeSpec> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanExecInfo &a, TPlanExecInfo &b);

std::ostream& operator<<(std::ostream& out, const TPlanExecInfo& obj);

typedef struct _TFinalizeParams__isset {
  _TFinalizeParams__isset() : staging_dir(false), table_id(false), transaction_id(false), write_id(false), spec_id(false) {}
  bool staging_dir :1;
  bool table_id :1;
  bool transaction_id :1;
  bool write_id :1;
  bool spec_id :1;
} _TFinalizeParams__isset;

class TFinalizeParams {
 public:

  TFinalizeParams(const TFinalizeParams&);
  TFinalizeParams(TFinalizeParams&&);
  TFinalizeParams& operator=(const TFinalizeParams&);
  TFinalizeParams& operator=(TFinalizeParams&&);
  TFinalizeParams() : is_overwrite(0), hdfs_base_dir(), table_name(), table_db(), staging_dir(), table_id(0), transaction_id(0), write_id(0), spec_id(0) {
  }

  virtual ~TFinalizeParams() throw();
  bool is_overwrite;
  std::string hdfs_base_dir;
  std::string table_name;
  std::string table_db;
  std::string staging_dir;
  int64_t table_id;
  int64_t transaction_id;
  int64_t write_id;
  int32_t spec_id;

  _TFinalizeParams__isset __isset;

  void __set_is_overwrite(const bool val);

  void __set_hdfs_base_dir(const std::string& val);

  void __set_table_name(const std::string& val);

  void __set_table_db(const std::string& val);

  void __set_staging_dir(const std::string& val);

  void __set_table_id(const int64_t val);

  void __set_transaction_id(const int64_t val);

  void __set_write_id(const int64_t val);

  void __set_spec_id(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFinalizeParams &a, TFinalizeParams &b);

std::ostream& operator<<(std::ostream& out, const TFinalizeParams& obj);

typedef struct _TQueryExecRequest__isset {
  _TQueryExecRequest__isset() : plan_exec_info(false), result_set_metadata(false), finalize_params(false), query_plan(false), lineage_graph(false), per_host_mem_estimate(false), max_per_host_min_mem_reservation(false), max_per_host_thread_reservation(false), dedicated_coord_mem_estimate(false) {}
  bool plan_exec_info :1;
  bool result_set_metadata :1;
  bool finalize_params :1;
  bool query_plan :1;
  bool lineage_graph :1;
  bool per_host_mem_estimate :1;
  bool max_per_host_min_mem_reservation :1;
  bool max_per_host_thread_reservation :1;
  bool dedicated_coord_mem_estimate :1;
} _TQueryExecRequest__isset;

class TQueryExecRequest {
 public:

  TQueryExecRequest(const TQueryExecRequest&);
  TQueryExecRequest(TQueryExecRequest&&);
  TQueryExecRequest& operator=(const TQueryExecRequest&);
  TQueryExecRequest& operator=(TQueryExecRequest&&);
  TQueryExecRequest() : query_plan(), stmt_type(( ::impala::TStmtType::type)0), per_host_mem_estimate(0), max_per_host_min_mem_reservation(0), max_per_host_thread_reservation(0), dedicated_coord_mem_estimate(0) {
  }

  virtual ~TQueryExecRequest() throw();
  std::vector<TPlanExecInfo>  plan_exec_info;
   ::impala::TResultSetMetadata result_set_metadata;
  TFinalizeParams finalize_params;
  TQueryCtx query_ctx;
  std::string query_plan;
   ::impala::TStmtType::type stmt_type;
  std::vector< ::impala::TNetworkAddress>  host_list;
   ::impala::TLineageGraph lineage_graph;
  int64_t per_host_mem_estimate;
  int64_t max_per_host_min_mem_reservation;
  int64_t max_per_host_thread_reservation;
  int64_t dedicated_coord_mem_estimate;

  _TQueryExecRequest__isset __isset;

  void __set_plan_exec_info(const std::vector<TPlanExecInfo> & val);

  void __set_result_set_metadata(const  ::impala::TResultSetMetadata& val);

  void __set_finalize_params(const TFinalizeParams& val);

  void __set_query_ctx(const TQueryCtx& val);

  void __set_query_plan(const std::string& val);

  void __set_stmt_type(const  ::impala::TStmtType::type val);

  void __set_host_list(const std::vector< ::impala::TNetworkAddress> & val);

  void __set_lineage_graph(const  ::impala::TLineageGraph& val);

  void __set_per_host_mem_estimate(const int64_t val);

  void __set_max_per_host_min_mem_reservation(const int64_t val);

  void __set_max_per_host_thread_reservation(const int64_t val);

  void __set_dedicated_coord_mem_estimate(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TQueryExecRequest &a, TQueryExecRequest &b);

std::ostream& operator<<(std::ostream& out, const TQueryExecRequest& obj);

} // namespace

#include "Query_types.tcc"

#endif
