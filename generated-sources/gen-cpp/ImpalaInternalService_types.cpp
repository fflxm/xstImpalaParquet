/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ImpalaInternalService_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kImpalaInternalServiceVersionValues[] = {
  ImpalaInternalServiceVersion::V1
};
const char* _kImpalaInternalServiceVersionNames[] = {
  "V1"
};
const std::map<int, const char*> _ImpalaInternalServiceVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kImpalaInternalServiceVersionValues, _kImpalaInternalServiceVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ImpalaInternalServiceVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _ImpalaInternalServiceVersion_VALUES_TO_NAMES.find(val);
  if (it != _ImpalaInternalServiceVersion_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TDebugOptions::~TDebugOptions() throw() {
}


void TDebugOptions::__set_node_id(const  ::impala::TPlanNodeId val) {
  this->node_id = val;
__isset.node_id = true;
}

void TDebugOptions::__set_phase(const  ::impala::TExecNodePhase::type val) {
  this->phase = val;
__isset.phase = true;
}

void TDebugOptions::__set_action(const  ::impala::TDebugAction::type val) {
  this->action = val;
__isset.action = true;
}

void TDebugOptions::__set_action_param(const std::string& val) {
  this->action_param = val;
__isset.action_param = true;
}
std::ostream& operator<<(std::ostream& out, const TDebugOptions& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDebugOptions &a, TDebugOptions &b) {
  using ::std::swap;
  swap(a.node_id, b.node_id);
  swap(a.phase, b.phase);
  swap(a.action, b.action);
  swap(a.action_param, b.action_param);
  swap(a.__isset, b.__isset);
}

TDebugOptions::TDebugOptions(const TDebugOptions& other2) {
  node_id = other2.node_id;
  phase = other2.phase;
  action = other2.action;
  action_param = other2.action_param;
  __isset = other2.__isset;
}
TDebugOptions::TDebugOptions( TDebugOptions&& other3) {
  node_id = std::move(other3.node_id);
  phase = std::move(other3.phase);
  action = std::move(other3.action);
  action_param = std::move(other3.action_param);
  __isset = std::move(other3.__isset);
}
TDebugOptions& TDebugOptions::operator=(const TDebugOptions& other4) {
  node_id = other4.node_id;
  phase = other4.phase;
  action = other4.action;
  action_param = other4.action_param;
  __isset = other4.__isset;
  return *this;
}
TDebugOptions& TDebugOptions::operator=(TDebugOptions&& other5) {
  node_id = std::move(other5.node_id);
  phase = std::move(other5.phase);
  action = std::move(other5.action);
  action_param = std::move(other5.action_param);
  __isset = std::move(other5.__isset);
  return *this;
}
void TDebugOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDebugOptions(";
  out << "node_id="; (__isset.node_id ? (out << to_string(node_id)) : (out << "<null>"));
  out << ", " << "phase="; (__isset.phase ? (out << to_string(phase)) : (out << "<null>"));
  out << ", " << "action="; (__isset.action ? (out << to_string(action)) : (out << "<null>"));
  out << ", " << "action_param="; (__isset.action_param ? (out << to_string(action_param)) : (out << "<null>"));
  out << ")";
}


TRuntimeFilterSource::~TRuntimeFilterSource() throw() {
}


void TRuntimeFilterSource::__set_src_node_id(const  ::impala::TPlanNodeId val) {
  this->src_node_id = val;
}

void TRuntimeFilterSource::__set_filter_id(const int32_t val) {
  this->filter_id = val;
}
std::ostream& operator<<(std::ostream& out, const TRuntimeFilterSource& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TRuntimeFilterSource &a, TRuntimeFilterSource &b) {
  using ::std::swap;
  swap(a.src_node_id, b.src_node_id);
  swap(a.filter_id, b.filter_id);
}

TRuntimeFilterSource::TRuntimeFilterSource(const TRuntimeFilterSource& other6) {
  src_node_id = other6.src_node_id;
  filter_id = other6.filter_id;
}
TRuntimeFilterSource::TRuntimeFilterSource( TRuntimeFilterSource&& other7) {
  src_node_id = std::move(other7.src_node_id);
  filter_id = std::move(other7.filter_id);
}
TRuntimeFilterSource& TRuntimeFilterSource::operator=(const TRuntimeFilterSource& other8) {
  src_node_id = other8.src_node_id;
  filter_id = other8.filter_id;
  return *this;
}
TRuntimeFilterSource& TRuntimeFilterSource::operator=(TRuntimeFilterSource&& other9) {
  src_node_id = std::move(other9.src_node_id);
  filter_id = std::move(other9.filter_id);
  return *this;
}
void TRuntimeFilterSource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRuntimeFilterSource(";
  out << "src_node_id=" << to_string(src_node_id);
  out << ", " << "filter_id=" << to_string(filter_id);
  out << ")";
}


TPlanFragmentInstanceCtx::~TPlanFragmentInstanceCtx() throw() {
}


void TPlanFragmentInstanceCtx::__set_fragment_idx(const  ::impala::TFragmentIdx val) {
  this->fragment_idx = val;
}

void TPlanFragmentInstanceCtx::__set_fragment_instance_id(const  ::impala::TUniqueId& val) {
  this->fragment_instance_id = val;
}

void TPlanFragmentInstanceCtx::__set_per_fragment_instance_idx(const int32_t val) {
  this->per_fragment_instance_idx = val;
}

void TPlanFragmentInstanceCtx::__set_per_exch_num_senders(const std::map< ::impala::TPlanNodeId, int32_t> & val) {
  this->per_exch_num_senders = val;
}

void TPlanFragmentInstanceCtx::__set_sender_id(const int32_t val) {
  this->sender_id = val;
__isset.sender_id = true;
}

void TPlanFragmentInstanceCtx::__set_debug_options(const TDebugOptions& val) {
  this->debug_options = val;
__isset.debug_options = true;
}

void TPlanFragmentInstanceCtx::__set_filters_produced(const std::vector<TRuntimeFilterSource> & val) {
  this->filters_produced = val;
__isset.filters_produced = true;
}

void TPlanFragmentInstanceCtx::__set_num_join_build_outputs(const int32_t val) {
  this->num_join_build_outputs = val;
__isset.num_join_build_outputs = true;
}

void TPlanFragmentInstanceCtx::__set_num_backends(const int32_t val) {
  this->num_backends = val;
__isset.num_backends = true;
}
std::ostream& operator<<(std::ostream& out, const TPlanFragmentInstanceCtx& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPlanFragmentInstanceCtx &a, TPlanFragmentInstanceCtx &b) {
  using ::std::swap;
  swap(a.fragment_idx, b.fragment_idx);
  swap(a.fragment_instance_id, b.fragment_instance_id);
  swap(a.per_fragment_instance_idx, b.per_fragment_instance_idx);
  swap(a.per_exch_num_senders, b.per_exch_num_senders);
  swap(a.sender_id, b.sender_id);
  swap(a.debug_options, b.debug_options);
  swap(a.filters_produced, b.filters_produced);
  swap(a.num_join_build_outputs, b.num_join_build_outputs);
  swap(a.num_backends, b.num_backends);
  swap(a.__isset, b.__isset);
}

TPlanFragmentInstanceCtx::TPlanFragmentInstanceCtx(const TPlanFragmentInstanceCtx& other24) {
  fragment_idx = other24.fragment_idx;
  fragment_instance_id = other24.fragment_instance_id;
  per_fragment_instance_idx = other24.per_fragment_instance_idx;
  per_exch_num_senders = other24.per_exch_num_senders;
  sender_id = other24.sender_id;
  debug_options = other24.debug_options;
  filters_produced = other24.filters_produced;
  num_join_build_outputs = other24.num_join_build_outputs;
  num_backends = other24.num_backends;
  __isset = other24.__isset;
}
TPlanFragmentInstanceCtx::TPlanFragmentInstanceCtx( TPlanFragmentInstanceCtx&& other25) {
  fragment_idx = std::move(other25.fragment_idx);
  fragment_instance_id = std::move(other25.fragment_instance_id);
  per_fragment_instance_idx = std::move(other25.per_fragment_instance_idx);
  per_exch_num_senders = std::move(other25.per_exch_num_senders);
  sender_id = std::move(other25.sender_id);
  debug_options = std::move(other25.debug_options);
  filters_produced = std::move(other25.filters_produced);
  num_join_build_outputs = std::move(other25.num_join_build_outputs);
  num_backends = std::move(other25.num_backends);
  __isset = std::move(other25.__isset);
}
TPlanFragmentInstanceCtx& TPlanFragmentInstanceCtx::operator=(const TPlanFragmentInstanceCtx& other26) {
  fragment_idx = other26.fragment_idx;
  fragment_instance_id = other26.fragment_instance_id;
  per_fragment_instance_idx = other26.per_fragment_instance_idx;
  per_exch_num_senders = other26.per_exch_num_senders;
  sender_id = other26.sender_id;
  debug_options = other26.debug_options;
  filters_produced = other26.filters_produced;
  num_join_build_outputs = other26.num_join_build_outputs;
  num_backends = other26.num_backends;
  __isset = other26.__isset;
  return *this;
}
TPlanFragmentInstanceCtx& TPlanFragmentInstanceCtx::operator=(TPlanFragmentInstanceCtx&& other27) {
  fragment_idx = std::move(other27.fragment_idx);
  fragment_instance_id = std::move(other27.fragment_instance_id);
  per_fragment_instance_idx = std::move(other27.per_fragment_instance_idx);
  per_exch_num_senders = std::move(other27.per_exch_num_senders);
  sender_id = std::move(other27.sender_id);
  debug_options = std::move(other27.debug_options);
  filters_produced = std::move(other27.filters_produced);
  num_join_build_outputs = std::move(other27.num_join_build_outputs);
  num_backends = std::move(other27.num_backends);
  __isset = std::move(other27.__isset);
  return *this;
}
void TPlanFragmentInstanceCtx::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPlanFragmentInstanceCtx(";
  out << "fragment_idx=" << to_string(fragment_idx);
  out << ", " << "fragment_instance_id=" << to_string(fragment_instance_id);
  out << ", " << "per_fragment_instance_idx=" << to_string(per_fragment_instance_idx);
  out << ", " << "per_exch_num_senders=" << to_string(per_exch_num_senders);
  out << ", " << "sender_id="; (__isset.sender_id ? (out << to_string(sender_id)) : (out << "<null>"));
  out << ", " << "debug_options="; (__isset.debug_options ? (out << to_string(debug_options)) : (out << "<null>"));
  out << ", " << "filters_produced="; (__isset.filters_produced ? (out << to_string(filters_produced)) : (out << "<null>"));
  out << ", " << "num_join_build_outputs="; (__isset.num_join_build_outputs ? (out << to_string(num_join_build_outputs)) : (out << "<null>"));
  out << ", " << "num_backends="; (__isset.num_backends ? (out << to_string(num_backends)) : (out << "<null>"));
  out << ")";
}


TExecPlanFragmentInfo::~TExecPlanFragmentInfo() throw() {
}


void TExecPlanFragmentInfo::__set_fragments(const std::vector< ::impala::TPlanFragment> & val) {
  this->fragments = val;
__isset.fragments = true;
}

void TExecPlanFragmentInfo::__set_fragment_instance_ctxs(const std::vector<TPlanFragmentInstanceCtx> & val) {
  this->fragment_instance_ctxs = val;
__isset.fragment_instance_ctxs = true;
}
std::ostream& operator<<(std::ostream& out, const TExecPlanFragmentInfo& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TExecPlanFragmentInfo &a, TExecPlanFragmentInfo &b) {
  using ::std::swap;
  swap(a.fragments, b.fragments);
  swap(a.fragment_instance_ctxs, b.fragment_instance_ctxs);
  swap(a.__isset, b.__isset);
}

TExecPlanFragmentInfo::TExecPlanFragmentInfo(const TExecPlanFragmentInfo& other40) {
  fragments = other40.fragments;
  fragment_instance_ctxs = other40.fragment_instance_ctxs;
  __isset = other40.__isset;
}
TExecPlanFragmentInfo::TExecPlanFragmentInfo( TExecPlanFragmentInfo&& other41) {
  fragments = std::move(other41.fragments);
  fragment_instance_ctxs = std::move(other41.fragment_instance_ctxs);
  __isset = std::move(other41.__isset);
}
TExecPlanFragmentInfo& TExecPlanFragmentInfo::operator=(const TExecPlanFragmentInfo& other42) {
  fragments = other42.fragments;
  fragment_instance_ctxs = other42.fragment_instance_ctxs;
  __isset = other42.__isset;
  return *this;
}
TExecPlanFragmentInfo& TExecPlanFragmentInfo::operator=(TExecPlanFragmentInfo&& other43) {
  fragments = std::move(other43.fragments);
  fragment_instance_ctxs = std::move(other43.fragment_instance_ctxs);
  __isset = std::move(other43.__isset);
  return *this;
}
void TExecPlanFragmentInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TExecPlanFragmentInfo(";
  out << "fragments="; (__isset.fragments ? (out << to_string(fragments)) : (out << "<null>"));
  out << ", " << "fragment_instance_ctxs="; (__isset.fragment_instance_ctxs ? (out << to_string(fragment_instance_ctxs)) : (out << "<null>"));
  out << ")";
}


TResolveRequestPoolParams::~TResolveRequestPoolParams() throw() {
}


void TResolveRequestPoolParams::__set_user(const std::string& val) {
  this->user = val;
}

void TResolveRequestPoolParams::__set_requested_pool(const std::string& val) {
  this->requested_pool = val;
}
std::ostream& operator<<(std::ostream& out, const TResolveRequestPoolParams& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TResolveRequestPoolParams &a, TResolveRequestPoolParams &b) {
  using ::std::swap;
  swap(a.user, b.user);
  swap(a.requested_pool, b.requested_pool);
}

TResolveRequestPoolParams::TResolveRequestPoolParams(const TResolveRequestPoolParams& other44) {
  user = other44.user;
  requested_pool = other44.requested_pool;
}
TResolveRequestPoolParams::TResolveRequestPoolParams( TResolveRequestPoolParams&& other45) {
  user = std::move(other45.user);
  requested_pool = std::move(other45.requested_pool);
}
TResolveRequestPoolParams& TResolveRequestPoolParams::operator=(const TResolveRequestPoolParams& other46) {
  user = other46.user;
  requested_pool = other46.requested_pool;
  return *this;
}
TResolveRequestPoolParams& TResolveRequestPoolParams::operator=(TResolveRequestPoolParams&& other47) {
  user = std::move(other47.user);
  requested_pool = std::move(other47.requested_pool);
  return *this;
}
void TResolveRequestPoolParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResolveRequestPoolParams(";
  out << "user=" << to_string(user);
  out << ", " << "requested_pool=" << to_string(requested_pool);
  out << ")";
}


TResolveRequestPoolResult::~TResolveRequestPoolResult() throw() {
}


void TResolveRequestPoolResult::__set_resolved_pool(const std::string& val) {
  this->resolved_pool = val;
__isset.resolved_pool = true;
}

void TResolveRequestPoolResult::__set_has_access(const bool val) {
  this->has_access = val;
__isset.has_access = true;
}

void TResolveRequestPoolResult::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
__isset.status = true;
}
std::ostream& operator<<(std::ostream& out, const TResolveRequestPoolResult& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TResolveRequestPoolResult &a, TResolveRequestPoolResult &b) {
  using ::std::swap;
  swap(a.resolved_pool, b.resolved_pool);
  swap(a.has_access, b.has_access);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

TResolveRequestPoolResult::TResolveRequestPoolResult(const TResolveRequestPoolResult& other48) {
  resolved_pool = other48.resolved_pool;
  has_access = other48.has_access;
  status = other48.status;
  __isset = other48.__isset;
}
TResolveRequestPoolResult::TResolveRequestPoolResult( TResolveRequestPoolResult&& other49) {
  resolved_pool = std::move(other49.resolved_pool);
  has_access = std::move(other49.has_access);
  status = std::move(other49.status);
  __isset = std::move(other49.__isset);
}
TResolveRequestPoolResult& TResolveRequestPoolResult::operator=(const TResolveRequestPoolResult& other50) {
  resolved_pool = other50.resolved_pool;
  has_access = other50.has_access;
  status = other50.status;
  __isset = other50.__isset;
  return *this;
}
TResolveRequestPoolResult& TResolveRequestPoolResult::operator=(TResolveRequestPoolResult&& other51) {
  resolved_pool = std::move(other51.resolved_pool);
  has_access = std::move(other51.has_access);
  status = std::move(other51.status);
  __isset = std::move(other51.__isset);
  return *this;
}
void TResolveRequestPoolResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TResolveRequestPoolResult(";
  out << "resolved_pool="; (__isset.resolved_pool ? (out << to_string(resolved_pool)) : (out << "<null>"));
  out << ", " << "has_access="; (__isset.has_access ? (out << to_string(has_access)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


TPoolConfigParams::~TPoolConfigParams() throw() {
}


void TPoolConfigParams::__set_pool(const std::string& val) {
  this->pool = val;
}
std::ostream& operator<<(std::ostream& out, const TPoolConfigParams& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPoolConfigParams &a, TPoolConfigParams &b) {
  using ::std::swap;
  swap(a.pool, b.pool);
}

TPoolConfigParams::TPoolConfigParams(const TPoolConfigParams& other52) {
  pool = other52.pool;
}
TPoolConfigParams::TPoolConfigParams( TPoolConfigParams&& other53) {
  pool = std::move(other53.pool);
}
TPoolConfigParams& TPoolConfigParams::operator=(const TPoolConfigParams& other54) {
  pool = other54.pool;
  return *this;
}
TPoolConfigParams& TPoolConfigParams::operator=(TPoolConfigParams&& other55) {
  pool = std::move(other55.pool);
  return *this;
}
void TPoolConfigParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPoolConfigParams(";
  out << "pool=" << to_string(pool);
  out << ")";
}


TPoolConfig::~TPoolConfig() throw() {
}


void TPoolConfig::__set_max_requests(const int64_t val) {
  this->max_requests = val;
}

void TPoolConfig::__set_max_queued(const int64_t val) {
  this->max_queued = val;
}

void TPoolConfig::__set_max_mem_resources(const int64_t val) {
  this->max_mem_resources = val;
}

void TPoolConfig::__set_queue_timeout_ms(const int64_t val) {
  this->queue_timeout_ms = val;
__isset.queue_timeout_ms = true;
}

void TPoolConfig::__set_default_query_options(const std::string& val) {
  this->default_query_options = val;
}

void TPoolConfig::__set_max_query_mem_limit(const int64_t val) {
  this->max_query_mem_limit = val;
}

void TPoolConfig::__set_min_query_mem_limit(const int64_t val) {
  this->min_query_mem_limit = val;
}

void TPoolConfig::__set_clamp_mem_limit_query_option(const bool val) {
  this->clamp_mem_limit_query_option = val;
}

void TPoolConfig::__set_max_mt_dop(const int64_t val) {
  this->max_mt_dop = val;
}
std::ostream& operator<<(std::ostream& out, const TPoolConfig& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPoolConfig &a, TPoolConfig &b) {
  using ::std::swap;
  swap(a.max_requests, b.max_requests);
  swap(a.max_queued, b.max_queued);
  swap(a.max_mem_resources, b.max_mem_resources);
  swap(a.queue_timeout_ms, b.queue_timeout_ms);
  swap(a.default_query_options, b.default_query_options);
  swap(a.max_query_mem_limit, b.max_query_mem_limit);
  swap(a.min_query_mem_limit, b.min_query_mem_limit);
  swap(a.clamp_mem_limit_query_option, b.clamp_mem_limit_query_option);
  swap(a.max_mt_dop, b.max_mt_dop);
  swap(a.__isset, b.__isset);
}

TPoolConfig::TPoolConfig(const TPoolConfig& other56) {
  max_requests = other56.max_requests;
  max_queued = other56.max_queued;
  max_mem_resources = other56.max_mem_resources;
  queue_timeout_ms = other56.queue_timeout_ms;
  default_query_options = other56.default_query_options;
  max_query_mem_limit = other56.max_query_mem_limit;
  min_query_mem_limit = other56.min_query_mem_limit;
  clamp_mem_limit_query_option = other56.clamp_mem_limit_query_option;
  max_mt_dop = other56.max_mt_dop;
  __isset = other56.__isset;
}
TPoolConfig::TPoolConfig( TPoolConfig&& other57) {
  max_requests = std::move(other57.max_requests);
  max_queued = std::move(other57.max_queued);
  max_mem_resources = std::move(other57.max_mem_resources);
  queue_timeout_ms = std::move(other57.queue_timeout_ms);
  default_query_options = std::move(other57.default_query_options);
  max_query_mem_limit = std::move(other57.max_query_mem_limit);
  min_query_mem_limit = std::move(other57.min_query_mem_limit);
  clamp_mem_limit_query_option = std::move(other57.clamp_mem_limit_query_option);
  max_mt_dop = std::move(other57.max_mt_dop);
  __isset = std::move(other57.__isset);
}
TPoolConfig& TPoolConfig::operator=(const TPoolConfig& other58) {
  max_requests = other58.max_requests;
  max_queued = other58.max_queued;
  max_mem_resources = other58.max_mem_resources;
  queue_timeout_ms = other58.queue_timeout_ms;
  default_query_options = other58.default_query_options;
  max_query_mem_limit = other58.max_query_mem_limit;
  min_query_mem_limit = other58.min_query_mem_limit;
  clamp_mem_limit_query_option = other58.clamp_mem_limit_query_option;
  max_mt_dop = other58.max_mt_dop;
  __isset = other58.__isset;
  return *this;
}
TPoolConfig& TPoolConfig::operator=(TPoolConfig&& other59) {
  max_requests = std::move(other59.max_requests);
  max_queued = std::move(other59.max_queued);
  max_mem_resources = std::move(other59.max_mem_resources);
  queue_timeout_ms = std::move(other59.queue_timeout_ms);
  default_query_options = std::move(other59.default_query_options);
  max_query_mem_limit = std::move(other59.max_query_mem_limit);
  min_query_mem_limit = std::move(other59.min_query_mem_limit);
  clamp_mem_limit_query_option = std::move(other59.clamp_mem_limit_query_option);
  max_mt_dop = std::move(other59.max_mt_dop);
  __isset = std::move(other59.__isset);
  return *this;
}
void TPoolConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPoolConfig(";
  out << "max_requests=" << to_string(max_requests);
  out << ", " << "max_queued=" << to_string(max_queued);
  out << ", " << "max_mem_resources=" << to_string(max_mem_resources);
  out << ", " << "queue_timeout_ms="; (__isset.queue_timeout_ms ? (out << to_string(queue_timeout_ms)) : (out << "<null>"));
  out << ", " << "default_query_options=" << to_string(default_query_options);
  out << ", " << "max_query_mem_limit=" << to_string(max_query_mem_limit);
  out << ", " << "min_query_mem_limit=" << to_string(min_query_mem_limit);
  out << ", " << "clamp_mem_limit_query_option=" << to_string(clamp_mem_limit_query_option);
  out << ", " << "max_mt_dop=" << to_string(max_mt_dop);
  out << ")";
}


TParseDateStringResult::~TParseDateStringResult() throw() {
}


void TParseDateStringResult::__set_valid(const bool val) {
  this->valid = val;
}

void TParseDateStringResult::__set_days_since_epoch(const int32_t val) {
  this->days_since_epoch = val;
__isset.days_since_epoch = true;
}

void TParseDateStringResult::__set_canonical_date_string(const std::string& val) {
  this->canonical_date_string = val;
__isset.canonical_date_string = true;
}
std::ostream& operator<<(std::ostream& out, const TParseDateStringResult& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TParseDateStringResult &a, TParseDateStringResult &b) {
  using ::std::swap;
  swap(a.valid, b.valid);
  swap(a.days_since_epoch, b.days_since_epoch);
  swap(a.canonical_date_string, b.canonical_date_string);
  swap(a.__isset, b.__isset);
}

TParseDateStringResult::TParseDateStringResult(const TParseDateStringResult& other60) {
  valid = other60.valid;
  days_since_epoch = other60.days_since_epoch;
  canonical_date_string = other60.canonical_date_string;
  __isset = other60.__isset;
}
TParseDateStringResult::TParseDateStringResult( TParseDateStringResult&& other61) {
  valid = std::move(other61.valid);
  days_since_epoch = std::move(other61.days_since_epoch);
  canonical_date_string = std::move(other61.canonical_date_string);
  __isset = std::move(other61.__isset);
}
TParseDateStringResult& TParseDateStringResult::operator=(const TParseDateStringResult& other62) {
  valid = other62.valid;
  days_since_epoch = other62.days_since_epoch;
  canonical_date_string = other62.canonical_date_string;
  __isset = other62.__isset;
  return *this;
}
TParseDateStringResult& TParseDateStringResult::operator=(TParseDateStringResult&& other63) {
  valid = std::move(other63.valid);
  days_since_epoch = std::move(other63.days_since_epoch);
  canonical_date_string = std::move(other63.canonical_date_string);
  __isset = std::move(other63.__isset);
  return *this;
}
void TParseDateStringResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TParseDateStringResult(";
  out << "valid=" << to_string(valid);
  out << ", " << "days_since_epoch="; (__isset.days_since_epoch ? (out << to_string(days_since_epoch)) : (out << "<null>"));
  out << ", " << "canonical_date_string="; (__isset.canonical_date_string ? (out << to_string(canonical_date_string)) : (out << "<null>"));
  out << ")";
}

} // namespace
