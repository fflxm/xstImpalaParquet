/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ExecStats_TYPES_TCC
#define ExecStats_TYPES_TCC

#include "Status_types.tcc"
#include "Types_types.tcc"
#include "ExecStats_types.h"

namespace impala {

template <class Protocol_>
uint32_t TExecStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->latency_ns);
          this->__isset.latency_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_time_ns);
          this->__isset.cpu_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cardinality);
          this->__isset.cardinality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory_used);
          this->__isset.memory_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TExecStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecStats");

  if (this->__isset.latency_ns) {
    xfer += oprot->writeFieldBegin("latency_ns", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->latency_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cpu_time_ns) {
    xfer += oprot->writeFieldBegin("cpu_time_ns", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->cpu_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cardinality) {
    xfer += oprot->writeFieldBegin("cardinality", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->cardinality);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.memory_used) {
    xfer += oprot->writeFieldBegin("memory_used", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->memory_used);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPlanNodeExecSummary::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_node_id = false;
  bool isset_fragment_idx = false;
  bool isset_label = false;
  bool isset_num_children = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          isset_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fragment_idx);
          isset_fragment_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label);
          isset_label = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->label_detail);
          this->__isset.label_detail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_children);
          isset_num_children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->estimated_stats.read(iprot);
          this->__isset.estimated_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exec_stats.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->exec_stats.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->exec_stats[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exec_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_broadcast);
          this->__isset.is_broadcast = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_hosts);
          this->__isset.num_hosts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_label)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_children)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPlanNodeExecSummary::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanNodeExecSummary");

  xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_idx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->fragment_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("label", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->label);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.label_detail) {
    xfer += oprot->writeFieldBegin("label_detail", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->label_detail);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("num_children", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->num_children);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.estimated_stats) {
    xfer += oprot->writeFieldBegin("estimated_stats", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->estimated_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exec_stats) {
    xfer += oprot->writeFieldBegin("exec_stats", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exec_stats.size()));
      std::vector<TExecStats> ::const_iterator _iter9;
      for (_iter9 = this->exec_stats.begin(); _iter9 != this->exec_stats.end(); ++_iter9)
      {
        xfer += (*_iter9).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_broadcast) {
    xfer += oprot->writeFieldBegin("is_broadcast", ::apache::thrift::protocol::T_BOOL, 8);
    xfer += oprot->writeBool(this->is_broadcast);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_hosts) {
    xfer += oprot->writeFieldBegin("num_hosts", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->num_hosts);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExecProgress::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_scan_ranges);
          this->__isset.total_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_completed_scan_ranges);
          this->__isset.num_completed_scan_ranges = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TExecProgress::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecProgress");

  if (this->__isset.total_scan_ranges) {
    xfer += oprot->writeFieldBegin("total_scan_ranges", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->total_scan_ranges);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_completed_scan_ranges) {
    xfer += oprot->writeFieldBegin("num_completed_scan_ranges", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->num_completed_scan_ranges);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExecSummary::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_state = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->state = (TExecState::type)ecast18;
          isset_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->nodes.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->nodes.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->nodes[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.nodes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->exch_to_sender_map.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _ktype25;
            ::apache::thrift::protocol::TType _vtype26;
            xfer += iprot->readMapBegin(_ktype25, _vtype26, _size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              int32_t _key29;
              xfer += iprot->readI32(_key29);
              int32_t& _val30 = this->exch_to_sender_map[_key29];
              xfer += iprot->readI32(_val30);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.exch_to_sender_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->error_logs.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->error_logs.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += iprot->readString(this->error_logs[_i35]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.error_logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->progress.read(iprot);
          this->__isset.progress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_queued);
          this->__isset.is_queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->queued_reason);
          this->__isset.queued_reason = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_state)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TExecSummary::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecSummary");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nodes) {
    xfer += oprot->writeFieldBegin("nodes", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->nodes.size()));
      std::vector<TPlanNodeExecSummary> ::const_iterator _iter36;
      for (_iter36 = this->nodes.begin(); _iter36 != this->nodes.end(); ++_iter36)
      {
        xfer += (*_iter36).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exch_to_sender_map) {
    xfer += oprot->writeFieldBegin("exch_to_sender_map", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->exch_to_sender_map.size()));
      std::map<int32_t, int32_t> ::const_iterator _iter37;
      for (_iter37 = this->exch_to_sender_map.begin(); _iter37 != this->exch_to_sender_map.end(); ++_iter37)
      {
        xfer += oprot->writeI32(_iter37->first);
        xfer += oprot->writeI32(_iter37->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_logs) {
    xfer += oprot->writeFieldBegin("error_logs", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->error_logs.size()));
      std::vector<std::string> ::const_iterator _iter38;
      for (_iter38 = this->error_logs.begin(); _iter38 != this->error_logs.end(); ++_iter38)
      {
        xfer += oprot->writeString((*_iter38));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.progress) {
    xfer += oprot->writeFieldBegin("progress", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->progress.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_queued) {
    xfer += oprot->writeFieldBegin("is_queued", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->is_queued);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queued_reason) {
    xfer += oprot->writeFieldBegin("queued_reason", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->queued_reason);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
