/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Types_TYPES_H
#define Types_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace impala {

struct TPrimitiveType {
  enum type {
    INVALID_TYPE = 0,
    NULL_TYPE = 1,
    BOOLEAN = 2,
    TINYINT = 3,
    SMALLINT = 4,
    INT = 5,
    BIGINT = 6,
    FLOAT = 7,
    DOUBLE = 8,
    DATE = 9,
    DATETIME = 10,
    TIMESTAMP = 11,
    STRING = 12,
    BINARY = 13,
    DECIMAL = 14,
    CHAR = 15,
    VARCHAR = 16,
    FIXED_UDA_INTERMEDIATE = 17
  };
};

extern const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrimitiveType::type& val);

struct TTypeNodeType {
  enum type {
    SCALAR = 0,
    ARRAY = 1,
    MAP = 2,
    STRUCT = 3
  };
};

extern const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TTypeNodeType::type& val);

struct TStmtType {
  enum type {
    QUERY = 0,
    DDL = 1,
    DML = 2,
    EXPLAIN = 3,
    LOAD = 4,
    SET = 5,
    ADMIN_FN = 6,
    TESTCASE = 7
  };
};

extern const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TStmtType::type& val);

struct TExplainLevel {
  enum type {
    MINIMAL = 0,
    STANDARD = 1,
    EXTENDED = 2,
    VERBOSE = 3
  };
};

extern const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TExplainLevel::type& val);

struct TRuntimeFilterMode {
  enum type {
    OFF = 0,
    LOCAL = 1,
    GLOBAL = 2
  };
};

extern const std::map<int, const char*> _TRuntimeFilterMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterMode::type& val);

struct TPrefetchMode {
  enum type {
    NONE = 0,
    HT_BUCKET = 1
  };
};

extern const std::map<int, const char*> _TPrefetchMode_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPrefetchMode::type& val);

struct TFunctionCategory {
  enum type {
    SCALAR = 0,
    AGGREGATE = 1,
    ANALYTIC = 2
  };
};

extern const std::map<int, const char*> _TFunctionCategory_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TFunctionCategory::type& val);

struct TFunctionBinaryType {
  enum type {
    BUILTIN = 0,
    JAVA = 1,
    NATIVE = 2,
    IR = 3
  };
};

extern const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TFunctionBinaryType::type& val);

struct TSortingOrder {
  enum type {
    LEXICAL = 0,
    ZORDER = 1
  };
};

extern const std::map<int, const char*> _TSortingOrder_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSortingOrder::type& val);

typedef int64_t TTimestamp;

typedef int32_t TFragmentIdx;

typedef int32_t TPlanNodeId;

typedef int32_t TDataSinkId;

typedef int32_t TTupleId;

typedef int32_t TSlotId;

typedef int32_t TTableId;

typedef class TUniqueId TBackendId;

class TScalarType;

class TStructField;

class TTypeNode;

class TColumnType;

class TNetworkAddress;

class TUniqueId;

class TFunctionName;

class TScalarFunction;

class TAggregateFunction;

class TFunction;

typedef struct _TScalarType__isset {
  _TScalarType__isset() : len(false), precision(false), scale(false) {}
  bool len :1;
  bool precision :1;
  bool scale :1;
} _TScalarType__isset;

class TScalarType {
 public:

  TScalarType(const TScalarType&);
  TScalarType(TScalarType&&);
  TScalarType& operator=(const TScalarType&);
  TScalarType& operator=(TScalarType&&);
  TScalarType() : type((TPrimitiveType::type)0), len(0), precision(0), scale(0) {
  }

  virtual ~TScalarType() throw();
  TPrimitiveType::type type;
  int32_t len;
  int32_t precision;
  int32_t scale;

  _TScalarType__isset __isset;

  void __set_type(const TPrimitiveType::type val);

  void __set_len(const int32_t val);

  void __set_precision(const int32_t val);

  void __set_scale(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScalarType &a, TScalarType &b);

std::ostream& operator<<(std::ostream& out, const TScalarType& obj);

typedef struct _TStructField__isset {
  _TStructField__isset() : comment(false), field_id(false) {}
  bool comment :1;
  bool field_id :1;
} _TStructField__isset;

class TStructField {
 public:

  TStructField(const TStructField&);
  TStructField(TStructField&&);
  TStructField& operator=(const TStructField&);
  TStructField& operator=(TStructField&&);
  TStructField() : name(), comment(), field_id(0) {
  }

  virtual ~TStructField() throw();
  std::string name;
  std::string comment;
  int32_t field_id;

  _TStructField__isset __isset;

  void __set_name(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_field_id(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TStructField &a, TStructField &b);

std::ostream& operator<<(std::ostream& out, const TStructField& obj);

typedef struct _TTypeNode__isset {
  _TTypeNode__isset() : scalar_type(false), struct_fields(false) {}
  bool scalar_type :1;
  bool struct_fields :1;
} _TTypeNode__isset;

class TTypeNode {
 public:

  TTypeNode(const TTypeNode&);
  TTypeNode(TTypeNode&&);
  TTypeNode& operator=(const TTypeNode&);
  TTypeNode& operator=(TTypeNode&&);
  TTypeNode() : type((TTypeNodeType::type)0) {
  }

  virtual ~TTypeNode() throw();
  TTypeNodeType::type type;
  TScalarType scalar_type;
  std::vector<TStructField>  struct_fields;

  _TTypeNode__isset __isset;

  void __set_type(const TTypeNodeType::type val);

  void __set_scalar_type(const TScalarType& val);

  void __set_struct_fields(const std::vector<TStructField> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTypeNode &a, TTypeNode &b);

std::ostream& operator<<(std::ostream& out, const TTypeNode& obj);

typedef struct _TColumnType__isset {
  _TColumnType__isset() : types(false) {}
  bool types :1;
} _TColumnType__isset;

class TColumnType {
 public:

  TColumnType(const TColumnType&);
  TColumnType(TColumnType&&);
  TColumnType& operator=(const TColumnType&);
  TColumnType& operator=(TColumnType&&);
  TColumnType() {
  }

  virtual ~TColumnType() throw();
  std::vector<TTypeNode>  types;

  _TColumnType__isset __isset;

  void __set_types(const std::vector<TTypeNode> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TColumnType &a, TColumnType &b);

std::ostream& operator<<(std::ostream& out, const TColumnType& obj);


class TNetworkAddress {
 public:

  TNetworkAddress(const TNetworkAddress&);
  TNetworkAddress(TNetworkAddress&&);
  TNetworkAddress& operator=(const TNetworkAddress&);
  TNetworkAddress& operator=(TNetworkAddress&&);
  TNetworkAddress() : hostname(), port(0) {
  }

  virtual ~TNetworkAddress() throw();
  std::string hostname;
  int32_t port;

  void __set_hostname(const std::string& val);

  void __set_port(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNetworkAddress &a, TNetworkAddress &b);

std::ostream& operator<<(std::ostream& out, const TNetworkAddress& obj);


class TUniqueId {
 public:

  TUniqueId(const TUniqueId&);
  TUniqueId(TUniqueId&&);
  TUniqueId& operator=(const TUniqueId&);
  TUniqueId& operator=(TUniqueId&&);
  TUniqueId() : hi(0), lo(0) {
  }

  virtual ~TUniqueId() throw();
  int64_t hi;
  int64_t lo;

  void __set_hi(const int64_t val);

  void __set_lo(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUniqueId &a, TUniqueId &b);

std::ostream& operator<<(std::ostream& out, const TUniqueId& obj);

typedef struct _TFunctionName__isset {
  _TFunctionName__isset() : db_name(false) {}
  bool db_name :1;
} _TFunctionName__isset;

class TFunctionName {
 public:

  TFunctionName(const TFunctionName&);
  TFunctionName(TFunctionName&&);
  TFunctionName& operator=(const TFunctionName&);
  TFunctionName& operator=(TFunctionName&&);
  TFunctionName() : db_name(), function_name() {
  }

  virtual ~TFunctionName() throw();
  std::string db_name;
  std::string function_name;

  _TFunctionName__isset __isset;

  void __set_db_name(const std::string& val);

  void __set_function_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFunctionName &a, TFunctionName &b);

std::ostream& operator<<(std::ostream& out, const TFunctionName& obj);

typedef struct _TScalarFunction__isset {
  _TScalarFunction__isset() : prepare_fn_symbol(false), close_fn_symbol(false) {}
  bool prepare_fn_symbol :1;
  bool close_fn_symbol :1;
} _TScalarFunction__isset;

class TScalarFunction {
 public:

  TScalarFunction(const TScalarFunction&);
  TScalarFunction(TScalarFunction&&);
  TScalarFunction& operator=(const TScalarFunction&);
  TScalarFunction& operator=(TScalarFunction&&);
  TScalarFunction() : symbol(), prepare_fn_symbol(), close_fn_symbol() {
  }

  virtual ~TScalarFunction() throw();
  std::string symbol;
  std::string prepare_fn_symbol;
  std::string close_fn_symbol;

  _TScalarFunction__isset __isset;

  void __set_symbol(const std::string& val);

  void __set_prepare_fn_symbol(const std::string& val);

  void __set_close_fn_symbol(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScalarFunction &a, TScalarFunction &b);

std::ostream& operator<<(std::ostream& out, const TScalarFunction& obj);

typedef struct _TAggregateFunction__isset {
  _TAggregateFunction__isset() : serialize_fn_symbol(false), merge_fn_symbol(false), finalize_fn_symbol(false), get_value_fn_symbol(false), remove_fn_symbol(false), ignores_distinct(false) {}
  bool serialize_fn_symbol :1;
  bool merge_fn_symbol :1;
  bool finalize_fn_symbol :1;
  bool get_value_fn_symbol :1;
  bool remove_fn_symbol :1;
  bool ignores_distinct :1;
} _TAggregateFunction__isset;

class TAggregateFunction {
 public:

  TAggregateFunction(const TAggregateFunction&);
  TAggregateFunction(TAggregateFunction&&);
  TAggregateFunction& operator=(const TAggregateFunction&);
  TAggregateFunction& operator=(TAggregateFunction&&);
  TAggregateFunction() : is_analytic_only_fn(0), update_fn_symbol(), init_fn_symbol(), serialize_fn_symbol(), merge_fn_symbol(), finalize_fn_symbol(), get_value_fn_symbol(), remove_fn_symbol(), ignores_distinct(0) {
  }

  virtual ~TAggregateFunction() throw();
  TColumnType intermediate_type;
  bool is_analytic_only_fn;
  std::string update_fn_symbol;
  std::string init_fn_symbol;
  std::string serialize_fn_symbol;
  std::string merge_fn_symbol;
  std::string finalize_fn_symbol;
  std::string get_value_fn_symbol;
  std::string remove_fn_symbol;
  bool ignores_distinct;

  _TAggregateFunction__isset __isset;

  void __set_intermediate_type(const TColumnType& val);

  void __set_is_analytic_only_fn(const bool val);

  void __set_update_fn_symbol(const std::string& val);

  void __set_init_fn_symbol(const std::string& val);

  void __set_serialize_fn_symbol(const std::string& val);

  void __set_merge_fn_symbol(const std::string& val);

  void __set_finalize_fn_symbol(const std::string& val);

  void __set_get_value_fn_symbol(const std::string& val);

  void __set_remove_fn_symbol(const std::string& val);

  void __set_ignores_distinct(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregateFunction &a, TAggregateFunction &b);

std::ostream& operator<<(std::ostream& out, const TAggregateFunction& obj);

typedef struct _TFunction__isset {
  _TFunction__isset() : binary_type(false), arg_types(false), ret_type(false), has_var_args(false), comment(false), signature(false), hdfs_location(false), scalar_fn(false), aggregate_fn(false), is_persistent(false), last_modified_time(false) {}
  bool binary_type :1;
  bool arg_types :1;
  bool ret_type :1;
  bool has_var_args :1;
  bool comment :1;
  bool signature :1;
  bool hdfs_location :1;
  bool scalar_fn :1;
  bool aggregate_fn :1;
  bool is_persistent :1;
  bool last_modified_time :1;
} _TFunction__isset;

class TFunction {
 public:

  TFunction(const TFunction&);
  TFunction(TFunction&&);
  TFunction& operator=(const TFunction&);
  TFunction& operator=(TFunction&&);
  TFunction() : binary_type((TFunctionBinaryType::type)0), has_var_args(0), comment(), signature(), hdfs_location(), is_persistent(0), last_modified_time(0) {
  }

  virtual ~TFunction() throw();
  TFunctionName name;
  TFunctionBinaryType::type binary_type;
  std::vector<TColumnType>  arg_types;
  TColumnType ret_type;
  bool has_var_args;
  std::string comment;
  std::string signature;
  std::string hdfs_location;
  TScalarFunction scalar_fn;
  TAggregateFunction aggregate_fn;
  bool is_persistent;
  int64_t last_modified_time;

  _TFunction__isset __isset;

  void __set_name(const TFunctionName& val);

  void __set_binary_type(const TFunctionBinaryType::type val);

  void __set_arg_types(const std::vector<TColumnType> & val);

  void __set_ret_type(const TColumnType& val);

  void __set_has_var_args(const bool val);

  void __set_comment(const std::string& val);

  void __set_signature(const std::string& val);

  void __set_hdfs_location(const std::string& val);

  void __set_scalar_fn(const TScalarFunction& val);

  void __set_aggregate_fn(const TAggregateFunction& val);

  void __set_is_persistent(const bool val);

  void __set_last_modified_time(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFunction &a, TFunction &b);

std::ostream& operator<<(std::ostream& out, const TFunction& obj);

} // namespace

#include "Types_types.tcc"

#endif
