/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CatalogService_TYPES_H
#define CatalogService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "CatalogObjects_types.h"
#include "JniCatalog_types.h"
#include "Types_types.h"
#include "Status_types.h"
#include "Results_types.h"
#include "hive_metastore_types.h"
#include "SqlConstraints_types.h"


namespace impala {

struct CatalogServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _CatalogServiceVersion_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CatalogServiceVersion::type& val);

struct CatalogLookupStatus {
  enum type {
    OK = 0,
    DB_NOT_FOUND = 1,
    TABLE_NOT_FOUND = 2,
    TABLE_NOT_LOADED = 3,
    FUNCTION_NOT_FOUND = 4,
    PARTITION_NOT_FOUND = 5
  };
};

extern const std::map<int, const char*> _CatalogLookupStatus_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CatalogLookupStatus::type& val);

class TCatalogServiceRequestHeader;

class TCatalogUpdateResult;

class TDdlExecRequest;

class TDdlExecResponse;

class TIcebergOperationParam;

class TUpdatedPartition;

class TUpdateCatalogRequest;

class TUpdateCatalogResponse;

class TResetMetadataRequest;

class TResetMetadataResponse;

class TGetFunctionsRequest;

class TGetFunctionsResponse;

class TCatalogInfoSelector;

class TPartialCatalogInfo;

class TTableInfoSelector;

class TPartialPartitionInfo;

class TIcebergSnapshot;

class TPartialTableInfo;

class TBriefTableMeta;

class TDbInfoSelector;

class TPartialDbInfo;

class TGetPartialCatalogObjectRequest;

class TGetPartialCatalogObjectResponse;

class TGetCatalogObjectRequest;

class TGetCatalogObjectResponse;

class TGetPartitionStatsRequest;

class TGetPartitionStatsResponse;

class TPrioritizeLoadRequest;

class TPrioritizeLoadResponse;

class TTableUsage;

class TUpdateTableUsageRequest;

class TUpdateTableUsageResponse;

typedef struct _TCatalogServiceRequestHeader__isset {
  _TCatalogServiceRequestHeader__isset() : requesting_user(false), redacted_sql_stmt(false), client_ip(false), want_minimal_response(false) {}
  bool requesting_user :1;
  bool redacted_sql_stmt :1;
  bool client_ip :1;
  bool want_minimal_response :1;
} _TCatalogServiceRequestHeader__isset;

class TCatalogServiceRequestHeader {
 public:

  TCatalogServiceRequestHeader(const TCatalogServiceRequestHeader&);
  TCatalogServiceRequestHeader(TCatalogServiceRequestHeader&&);
  TCatalogServiceRequestHeader& operator=(const TCatalogServiceRequestHeader&);
  TCatalogServiceRequestHeader& operator=(TCatalogServiceRequestHeader&&);
  TCatalogServiceRequestHeader() : requesting_user(), redacted_sql_stmt(), client_ip(), want_minimal_response(0) {
  }

  virtual ~TCatalogServiceRequestHeader() throw();
  std::string requesting_user;
  std::string redacted_sql_stmt;
  std::string client_ip;
  bool want_minimal_response;

  _TCatalogServiceRequestHeader__isset __isset;

  void __set_requesting_user(const std::string& val);

  void __set_redacted_sql_stmt(const std::string& val);

  void __set_client_ip(const std::string& val);

  void __set_want_minimal_response(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogServiceRequestHeader &a, TCatalogServiceRequestHeader &b);

std::ostream& operator<<(std::ostream& out, const TCatalogServiceRequestHeader& obj);

typedef struct _TCatalogUpdateResult__isset {
  _TCatalogUpdateResult__isset() : updated_catalog_objects(false), removed_catalog_objects(false) {}
  bool updated_catalog_objects :1;
  bool removed_catalog_objects :1;
} _TCatalogUpdateResult__isset;

class TCatalogUpdateResult {
 public:

  TCatalogUpdateResult(const TCatalogUpdateResult&);
  TCatalogUpdateResult(TCatalogUpdateResult&&);
  TCatalogUpdateResult& operator=(const TCatalogUpdateResult&);
  TCatalogUpdateResult& operator=(TCatalogUpdateResult&&);
  TCatalogUpdateResult() : version(0), is_invalidate(0) {
  }

  virtual ~TCatalogUpdateResult() throw();
   ::impala::TUniqueId catalog_service_id;
  int64_t version;
   ::impala::TStatus status;
  bool is_invalidate;
  std::vector< ::impala::TCatalogObject>  updated_catalog_objects;
  std::vector< ::impala::TCatalogObject>  removed_catalog_objects;

  _TCatalogUpdateResult__isset __isset;

  void __set_catalog_service_id(const  ::impala::TUniqueId& val);

  void __set_version(const int64_t val);

  void __set_status(const  ::impala::TStatus& val);

  void __set_is_invalidate(const bool val);

  void __set_updated_catalog_objects(const std::vector< ::impala::TCatalogObject> & val);

  void __set_removed_catalog_objects(const std::vector< ::impala::TCatalogObject> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogUpdateResult &a, TCatalogUpdateResult &b);

std::ostream& operator<<(std::ostream& out, const TCatalogUpdateResult& obj);

typedef struct _TDdlExecRequest__isset {
  _TDdlExecRequest__isset() : header(false), alter_table_params(false), alter_view_params(false), create_db_params(false), create_table_params(false), create_table_like_params(false), create_view_params(false), create_fn_params(false), drop_db_params(false), drop_table_or_view_params(false), truncate_params(false), drop_fn_params(false), compute_stats_params(false), create_data_source_params(false), drop_data_source_params(false), drop_stats_params(false), create_drop_role_params(false), grant_revoke_role_params(false), grant_revoke_priv_params(false), comment_on_params(false), alter_db_params(false), copy_test_case_params(false), debug_action(false) {}
  bool header :1;
  bool alter_table_params :1;
  bool alter_view_params :1;
  bool create_db_params :1;
  bool create_table_params :1;
  bool create_table_like_params :1;
  bool create_view_params :1;
  bool create_fn_params :1;
  bool drop_db_params :1;
  bool drop_table_or_view_params :1;
  bool truncate_params :1;
  bool drop_fn_params :1;
  bool compute_stats_params :1;
  bool create_data_source_params :1;
  bool drop_data_source_params :1;
  bool drop_stats_params :1;
  bool create_drop_role_params :1;
  bool grant_revoke_role_params :1;
  bool grant_revoke_priv_params :1;
  bool comment_on_params :1;
  bool alter_db_params :1;
  bool copy_test_case_params :1;
  bool debug_action :1;
} _TDdlExecRequest__isset;

class TDdlExecRequest {
 public:

  TDdlExecRequest(const TDdlExecRequest&);
  TDdlExecRequest(TDdlExecRequest&&);
  TDdlExecRequest& operator=(const TDdlExecRequest&);
  TDdlExecRequest& operator=(TDdlExecRequest&&);
  TDdlExecRequest() : protocol_version((CatalogServiceVersion::type)0), ddl_type(( ::impala::TDdlType::type)0), sync_ddl(0), debug_action() {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TDdlExecRequest() throw();
  CatalogServiceVersion::type protocol_version;
  TCatalogServiceRequestHeader header;
   ::impala::TDdlType::type ddl_type;
   ::impala::TAlterTableParams alter_table_params;
   ::impala::TCreateOrAlterViewParams alter_view_params;
   ::impala::TCreateDbParams create_db_params;
   ::impala::TCreateTableParams create_table_params;
   ::impala::TCreateTableLikeParams create_table_like_params;
   ::impala::TCreateOrAlterViewParams create_view_params;
   ::impala::TCreateFunctionParams create_fn_params;
   ::impala::TDropDbParams drop_db_params;
   ::impala::TDropTableOrViewParams drop_table_or_view_params;
   ::impala::TTruncateParams truncate_params;
   ::impala::TDropFunctionParams drop_fn_params;
   ::impala::TComputeStatsParams compute_stats_params;
   ::impala::TCreateDataSourceParams create_data_source_params;
   ::impala::TDropDataSourceParams drop_data_source_params;
   ::impala::TDropStatsParams drop_stats_params;
   ::impala::TCreateDropRoleParams create_drop_role_params;
   ::impala::TGrantRevokeRoleParams grant_revoke_role_params;
   ::impala::TGrantRevokePrivParams grant_revoke_priv_params;
  bool sync_ddl;
   ::impala::TCommentOnParams comment_on_params;
   ::impala::TAlterDbParams alter_db_params;
   ::impala::TCopyTestCaseReq copy_test_case_params;
  std::string debug_action;

  _TDdlExecRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_header(const TCatalogServiceRequestHeader& val);

  void __set_ddl_type(const  ::impala::TDdlType::type val);

  void __set_alter_table_params(const  ::impala::TAlterTableParams& val);

  void __set_alter_view_params(const  ::impala::TCreateOrAlterViewParams& val);

  void __set_create_db_params(const  ::impala::TCreateDbParams& val);

  void __set_create_table_params(const  ::impala::TCreateTableParams& val);

  void __set_create_table_like_params(const  ::impala::TCreateTableLikeParams& val);

  void __set_create_view_params(const  ::impala::TCreateOrAlterViewParams& val);

  void __set_create_fn_params(const  ::impala::TCreateFunctionParams& val);

  void __set_drop_db_params(const  ::impala::TDropDbParams& val);

  void __set_drop_table_or_view_params(const  ::impala::TDropTableOrViewParams& val);

  void __set_truncate_params(const  ::impala::TTruncateParams& val);

  void __set_drop_fn_params(const  ::impala::TDropFunctionParams& val);

  void __set_compute_stats_params(const  ::impala::TComputeStatsParams& val);

  void __set_create_data_source_params(const  ::impala::TCreateDataSourceParams& val);

  void __set_drop_data_source_params(const  ::impala::TDropDataSourceParams& val);

  void __set_drop_stats_params(const  ::impala::TDropStatsParams& val);

  void __set_create_drop_role_params(const  ::impala::TCreateDropRoleParams& val);

  void __set_grant_revoke_role_params(const  ::impala::TGrantRevokeRoleParams& val);

  void __set_grant_revoke_priv_params(const  ::impala::TGrantRevokePrivParams& val);

  void __set_sync_ddl(const bool val);

  void __set_comment_on_params(const  ::impala::TCommentOnParams& val);

  void __set_alter_db_params(const  ::impala::TAlterDbParams& val);

  void __set_copy_test_case_params(const  ::impala::TCopyTestCaseReq& val);

  void __set_debug_action(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDdlExecRequest &a, TDdlExecRequest &b);

std::ostream& operator<<(std::ostream& out, const TDdlExecRequest& obj);

typedef struct _TDdlExecResponse__isset {
  _TDdlExecResponse__isset() : new_table_created(false), result_set(false), table_name(false), table_create_time(false), table_location(false) {}
  bool new_table_created :1;
  bool result_set :1;
  bool table_name :1;
  bool table_create_time :1;
  bool table_location :1;
} _TDdlExecResponse__isset;

class TDdlExecResponse {
 public:

  TDdlExecResponse(const TDdlExecResponse&);
  TDdlExecResponse(TDdlExecResponse&&);
  TDdlExecResponse& operator=(const TDdlExecResponse&);
  TDdlExecResponse& operator=(TDdlExecResponse&&);
  TDdlExecResponse() : new_table_created(0), table_name(), table_create_time(0), table_location() {
  }

  virtual ~TDdlExecResponse() throw();
  TCatalogUpdateResult result;
  bool new_table_created;
   ::impala::TResultSet result_set;
  std::string table_name;
  int64_t table_create_time;
  std::string table_location;

  _TDdlExecResponse__isset __isset;

  void __set_result(const TCatalogUpdateResult& val);

  void __set_new_table_created(const bool val);

  void __set_result_set(const  ::impala::TResultSet& val);

  void __set_table_name(const std::string& val);

  void __set_table_create_time(const int64_t val);

  void __set_table_location(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDdlExecResponse &a, TDdlExecResponse &b);

std::ostream& operator<<(std::ostream& out, const TDdlExecResponse& obj);

typedef struct _TIcebergOperationParam__isset {
  _TIcebergOperationParam__isset() : spec_id(false) {}
  bool spec_id :1;
} _TIcebergOperationParam__isset;

class TIcebergOperationParam {
 public:

  TIcebergOperationParam(const TIcebergOperationParam&);
  TIcebergOperationParam(TIcebergOperationParam&&);
  TIcebergOperationParam& operator=(const TIcebergOperationParam&);
  TIcebergOperationParam& operator=(TIcebergOperationParam&&);
  TIcebergOperationParam() : spec_id(0), is_overwrite(false) {
  }

  virtual ~TIcebergOperationParam() throw();
  int32_t spec_id;
  std::vector<std::string>  iceberg_data_files_fb;
  bool is_overwrite;

  _TIcebergOperationParam__isset __isset;

  void __set_spec_id(const int32_t val);

  void __set_iceberg_data_files_fb(const std::vector<std::string> & val);

  void __set_is_overwrite(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIcebergOperationParam &a, TIcebergOperationParam &b);

std::ostream& operator<<(std::ostream& out, const TIcebergOperationParam& obj);


class TUpdatedPartition {
 public:

  TUpdatedPartition(const TUpdatedPartition&);
  TUpdatedPartition(TUpdatedPartition&&);
  TUpdatedPartition& operator=(const TUpdatedPartition&);
  TUpdatedPartition& operator=(TUpdatedPartition&&);
  TUpdatedPartition() {
  }

  virtual ~TUpdatedPartition() throw();
  std::vector<std::string>  files;

  void __set_files(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdatedPartition &a, TUpdatedPartition &b);

std::ostream& operator<<(std::ostream& out, const TUpdatedPartition& obj);

typedef struct _TUpdateCatalogRequest__isset {
  _TUpdateCatalogRequest__isset() : header(false), transaction_id(false), write_id(false), iceberg_operation(false) {}
  bool header :1;
  bool transaction_id :1;
  bool write_id :1;
  bool iceberg_operation :1;
} _TUpdateCatalogRequest__isset;

class TUpdateCatalogRequest {
 public:

  TUpdateCatalogRequest(const TUpdateCatalogRequest&);
  TUpdateCatalogRequest(TUpdateCatalogRequest&&);
  TUpdateCatalogRequest& operator=(const TUpdateCatalogRequest&);
  TUpdateCatalogRequest& operator=(TUpdateCatalogRequest&&);
  TUpdateCatalogRequest() : protocol_version((CatalogServiceVersion::type)0), sync_ddl(0), target_table(), db_name(), is_overwrite(0), transaction_id(0), write_id(0) {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TUpdateCatalogRequest() throw();
  CatalogServiceVersion::type protocol_version;
  bool sync_ddl;
  TCatalogServiceRequestHeader header;
  std::string target_table;
  std::string db_name;
  std::map<std::string, TUpdatedPartition>  updated_partitions;
  bool is_overwrite;
  int64_t transaction_id;
  int64_t write_id;
  TIcebergOperationParam iceberg_operation;

  _TUpdateCatalogRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_sync_ddl(const bool val);

  void __set_header(const TCatalogServiceRequestHeader& val);

  void __set_target_table(const std::string& val);

  void __set_db_name(const std::string& val);

  void __set_updated_partitions(const std::map<std::string, TUpdatedPartition> & val);

  void __set_is_overwrite(const bool val);

  void __set_transaction_id(const int64_t val);

  void __set_write_id(const int64_t val);

  void __set_iceberg_operation(const TIcebergOperationParam& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateCatalogRequest &a, TUpdateCatalogRequest &b);

std::ostream& operator<<(std::ostream& out, const TUpdateCatalogRequest& obj);


class TUpdateCatalogResponse {
 public:

  TUpdateCatalogResponse(const TUpdateCatalogResponse&);
  TUpdateCatalogResponse(TUpdateCatalogResponse&&);
  TUpdateCatalogResponse& operator=(const TUpdateCatalogResponse&);
  TUpdateCatalogResponse& operator=(TUpdateCatalogResponse&&);
  TUpdateCatalogResponse() {
  }

  virtual ~TUpdateCatalogResponse() throw();
  TCatalogUpdateResult result;

  void __set_result(const TCatalogUpdateResult& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateCatalogResponse &a, TUpdateCatalogResponse &b);

std::ostream& operator<<(std::ostream& out, const TUpdateCatalogResponse& obj);

typedef struct _TResetMetadataRequest__isset {
  _TResetMetadataRequest__isset() : header(false), table_name(false), partition_spec(false), db_name(false), authorization(false), refresh_updated_hms_partitions(false), debug_action(false) {}
  bool header :1;
  bool table_name :1;
  bool partition_spec :1;
  bool db_name :1;
  bool authorization :1;
  bool refresh_updated_hms_partitions :1;
  bool debug_action :1;
} _TResetMetadataRequest__isset;

class TResetMetadataRequest {
 public:

  TResetMetadataRequest(const TResetMetadataRequest&);
  TResetMetadataRequest(TResetMetadataRequest&&);
  TResetMetadataRequest& operator=(const TResetMetadataRequest&);
  TResetMetadataRequest& operator=(TResetMetadataRequest&&);
  TResetMetadataRequest() : protocol_version((CatalogServiceVersion::type)0), is_refresh(0), db_name(), sync_ddl(0), authorization(0), refresh_updated_hms_partitions(0), debug_action() {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TResetMetadataRequest() throw();
  CatalogServiceVersion::type protocol_version;
  TCatalogServiceRequestHeader header;
  bool is_refresh;
   ::impala::TTableName table_name;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;
  std::string db_name;
  bool sync_ddl;
  bool authorization;
  bool refresh_updated_hms_partitions;
  std::string debug_action;

  _TResetMetadataRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_header(const TCatalogServiceRequestHeader& val);

  void __set_is_refresh(const bool val);

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val);

  void __set_db_name(const std::string& val);

  void __set_sync_ddl(const bool val);

  void __set_authorization(const bool val);

  void __set_refresh_updated_hms_partitions(const bool val);

  void __set_debug_action(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TResetMetadataRequest &a, TResetMetadataRequest &b);

std::ostream& operator<<(std::ostream& out, const TResetMetadataRequest& obj);


class TResetMetadataResponse {
 public:

  TResetMetadataResponse(const TResetMetadataResponse&);
  TResetMetadataResponse(TResetMetadataResponse&&);
  TResetMetadataResponse& operator=(const TResetMetadataResponse&);
  TResetMetadataResponse& operator=(TResetMetadataResponse&&);
  TResetMetadataResponse() {
  }

  virtual ~TResetMetadataResponse() throw();
  TCatalogUpdateResult result;

  void __set_result(const TCatalogUpdateResult& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TResetMetadataResponse &a, TResetMetadataResponse &b);

std::ostream& operator<<(std::ostream& out, const TResetMetadataResponse& obj);

typedef struct _TGetFunctionsRequest__isset {
  _TGetFunctionsRequest__isset() : header(false), db_name(false) {}
  bool header :1;
  bool db_name :1;
} _TGetFunctionsRequest__isset;

class TGetFunctionsRequest {
 public:

  TGetFunctionsRequest(const TGetFunctionsRequest&);
  TGetFunctionsRequest(TGetFunctionsRequest&&);
  TGetFunctionsRequest& operator=(const TGetFunctionsRequest&);
  TGetFunctionsRequest& operator=(TGetFunctionsRequest&&);
  TGetFunctionsRequest() : protocol_version((CatalogServiceVersion::type)0), db_name() {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TGetFunctionsRequest() throw();
  CatalogServiceVersion::type protocol_version;
  TCatalogServiceRequestHeader header;
  std::string db_name;

  _TGetFunctionsRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_header(const TCatalogServiceRequestHeader& val);

  void __set_db_name(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetFunctionsRequest &a, TGetFunctionsRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetFunctionsRequest& obj);

typedef struct _TGetFunctionsResponse__isset {
  _TGetFunctionsResponse__isset() : status(false), functions(false) {}
  bool status :1;
  bool functions :1;
} _TGetFunctionsResponse__isset;

class TGetFunctionsResponse {
 public:

  TGetFunctionsResponse(const TGetFunctionsResponse&);
  TGetFunctionsResponse(TGetFunctionsResponse&&);
  TGetFunctionsResponse& operator=(const TGetFunctionsResponse&);
  TGetFunctionsResponse& operator=(TGetFunctionsResponse&&);
  TGetFunctionsResponse() {
  }

  virtual ~TGetFunctionsResponse() throw();
   ::impala::TStatus status;
  std::vector< ::impala::TFunction>  functions;

  _TGetFunctionsResponse__isset __isset;

  void __set_status(const  ::impala::TStatus& val);

  void __set_functions(const std::vector< ::impala::TFunction> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetFunctionsResponse &a, TGetFunctionsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetFunctionsResponse& obj);

typedef struct _TCatalogInfoSelector__isset {
  _TCatalogInfoSelector__isset() : want_db_names(false) {}
  bool want_db_names :1;
} _TCatalogInfoSelector__isset;

class TCatalogInfoSelector {
 public:

  TCatalogInfoSelector(const TCatalogInfoSelector&);
  TCatalogInfoSelector(TCatalogInfoSelector&&);
  TCatalogInfoSelector& operator=(const TCatalogInfoSelector&);
  TCatalogInfoSelector& operator=(TCatalogInfoSelector&&);
  TCatalogInfoSelector() : want_db_names(0) {
  }

  virtual ~TCatalogInfoSelector() throw();
  bool want_db_names;

  _TCatalogInfoSelector__isset __isset;

  void __set_want_db_names(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCatalogInfoSelector &a, TCatalogInfoSelector &b);

std::ostream& operator<<(std::ostream& out, const TCatalogInfoSelector& obj);

typedef struct _TPartialCatalogInfo__isset {
  _TPartialCatalogInfo__isset() : db_names(false) {}
  bool db_names :1;
} _TPartialCatalogInfo__isset;

class TPartialCatalogInfo {
 public:

  TPartialCatalogInfo(const TPartialCatalogInfo&);
  TPartialCatalogInfo(TPartialCatalogInfo&&);
  TPartialCatalogInfo& operator=(const TPartialCatalogInfo&);
  TPartialCatalogInfo& operator=(TPartialCatalogInfo&&);
  TPartialCatalogInfo() {
  }

  virtual ~TPartialCatalogInfo() throw();
  std::vector<std::string>  db_names;

  _TPartialCatalogInfo__isset __isset;

  void __set_db_names(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartialCatalogInfo &a, TPartialCatalogInfo &b);

std::ostream& operator<<(std::ostream& out, const TPartialCatalogInfo& obj);

typedef struct _TTableInfoSelector__isset {
  _TTableInfoSelector__isset() : want_hms_table(false), partition_ids(false), want_partition_names(false), want_partition_metadata(false), want_partition_files(false), want_stats_for_column_names(false), want_partition_stats(false), want_table_constraints(false), valid_write_ids(false), table_id(true), want_stats_for_all_columns(false), want_hms_partition(false), want_iceberg_snapshot(false) {}
  bool want_hms_table :1;
  bool partition_ids :1;
  bool want_partition_names :1;
  bool want_partition_metadata :1;
  bool want_partition_files :1;
  bool want_stats_for_column_names :1;
  bool want_partition_stats :1;
  bool want_table_constraints :1;
  bool valid_write_ids :1;
  bool table_id :1;
  bool want_stats_for_all_columns :1;
  bool want_hms_partition :1;
  bool want_iceberg_snapshot :1;
} _TTableInfoSelector__isset;

class TTableInfoSelector {
 public:

  TTableInfoSelector(const TTableInfoSelector&);
  TTableInfoSelector(TTableInfoSelector&&);
  TTableInfoSelector& operator=(const TTableInfoSelector&);
  TTableInfoSelector& operator=(TTableInfoSelector&&);
  TTableInfoSelector() : want_hms_table(0), want_partition_names(0), want_partition_metadata(0), want_partition_files(0), want_partition_stats(0), want_table_constraints(0), table_id(-1LL), want_stats_for_all_columns(0), want_hms_partition(0), want_iceberg_snapshot(0) {
  }

  virtual ~TTableInfoSelector() throw();
  bool want_hms_table;
  std::vector<int64_t>  partition_ids;
  bool want_partition_names;
  bool want_partition_metadata;
  bool want_partition_files;
  std::vector<std::string>  want_stats_for_column_names;
  bool want_partition_stats;
  bool want_table_constraints;
   ::impala::TValidWriteIdList valid_write_ids;
  int64_t table_id;
  bool want_stats_for_all_columns;
  bool want_hms_partition;
  bool want_iceberg_snapshot;

  _TTableInfoSelector__isset __isset;

  void __set_want_hms_table(const bool val);

  void __set_partition_ids(const std::vector<int64_t> & val);

  void __set_want_partition_names(const bool val);

  void __set_want_partition_metadata(const bool val);

  void __set_want_partition_files(const bool val);

  void __set_want_stats_for_column_names(const std::vector<std::string> & val);

  void __set_want_partition_stats(const bool val);

  void __set_want_table_constraints(const bool val);

  void __set_valid_write_ids(const  ::impala::TValidWriteIdList& val);

  void __set_table_id(const int64_t val);

  void __set_want_stats_for_all_columns(const bool val);

  void __set_want_hms_partition(const bool val);

  void __set_want_iceberg_snapshot(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableInfoSelector &a, TTableInfoSelector &b);

std::ostream& operator<<(std::ostream& out, const TTableInfoSelector& obj);

typedef struct _TPartialPartitionInfo__isset {
  _TPartialPartitionInfo__isset() : name(false), hms_partition(false), file_descriptors(false), insert_file_descriptors(false), delete_file_descriptors(false), last_compaction_id(false), partition_stats(false), has_incremental_stats(false), is_marked_cached(false), hms_parameters(false), write_id(false), hdfs_storage_descriptor(false), location(false) {}
  bool name :1;
  bool hms_partition :1;
  bool file_descriptors :1;
  bool insert_file_descriptors :1;
  bool delete_file_descriptors :1;
  bool last_compaction_id :1;
  bool partition_stats :1;
  bool has_incremental_stats :1;
  bool is_marked_cached :1;
  bool hms_parameters :1;
  bool write_id :1;
  bool hdfs_storage_descriptor :1;
  bool location :1;
} _TPartialPartitionInfo__isset;

class TPartialPartitionInfo {
 public:

  TPartialPartitionInfo(const TPartialPartitionInfo&);
  TPartialPartitionInfo(TPartialPartitionInfo&&);
  TPartialPartitionInfo& operator=(const TPartialPartitionInfo&);
  TPartialPartitionInfo& operator=(TPartialPartitionInfo&&);
  TPartialPartitionInfo() : id(0), name(), last_compaction_id(0), partition_stats(), has_incremental_stats(0), is_marked_cached(0), write_id(0) {
  }

  virtual ~TPartialPartitionInfo() throw();
  int64_t id;
  std::string name;
   ::Apache::Hadoop::Hive::Partition hms_partition;
  std::vector< ::impala::THdfsFileDesc>  file_descriptors;
  std::vector< ::impala::THdfsFileDesc>  insert_file_descriptors;
  std::vector< ::impala::THdfsFileDesc>  delete_file_descriptors;
  int64_t last_compaction_id;
  std::string partition_stats;
  bool has_incremental_stats;
  bool is_marked_cached;
  std::map<std::string, std::string>  hms_parameters;
  int64_t write_id;
   ::impala::THdfsStorageDescriptor hdfs_storage_descriptor;
   ::impala::THdfsPartitionLocation location;

  _TPartialPartitionInfo__isset __isset;

  void __set_id(const int64_t val);

  void __set_name(const std::string& val);

  void __set_hms_partition(const  ::Apache::Hadoop::Hive::Partition& val);

  void __set_file_descriptors(const std::vector< ::impala::THdfsFileDesc> & val);

  void __set_insert_file_descriptors(const std::vector< ::impala::THdfsFileDesc> & val);

  void __set_delete_file_descriptors(const std::vector< ::impala::THdfsFileDesc> & val);

  void __set_last_compaction_id(const int64_t val);

  void __set_partition_stats(const std::string& val);

  void __set_has_incremental_stats(const bool val);

  void __set_is_marked_cached(const bool val);

  void __set_hms_parameters(const std::map<std::string, std::string> & val);

  void __set_write_id(const int64_t val);

  void __set_hdfs_storage_descriptor(const  ::impala::THdfsStorageDescriptor& val);

  void __set_location(const  ::impala::THdfsPartitionLocation& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartialPartitionInfo &a, TPartialPartitionInfo &b);

std::ostream& operator<<(std::ostream& out, const TPartialPartitionInfo& obj);

typedef struct _TIcebergSnapshot__isset {
  _TIcebergSnapshot__isset() : iceberg_file_desc_map(false) {}
  bool iceberg_file_desc_map :1;
} _TIcebergSnapshot__isset;

class TIcebergSnapshot {
 public:

  TIcebergSnapshot(const TIcebergSnapshot&);
  TIcebergSnapshot(TIcebergSnapshot&&);
  TIcebergSnapshot& operator=(const TIcebergSnapshot&);
  TIcebergSnapshot& operator=(TIcebergSnapshot&&);
  TIcebergSnapshot() : snapshot_id(0) {
  }

  virtual ~TIcebergSnapshot() throw();
  int64_t snapshot_id;
  std::map<std::string,  ::impala::THdfsFileDesc>  iceberg_file_desc_map;

  _TIcebergSnapshot__isset __isset;

  void __set_snapshot_id(const int64_t val);

  void __set_iceberg_file_desc_map(const std::map<std::string,  ::impala::THdfsFileDesc> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TIcebergSnapshot &a, TIcebergSnapshot &b);

std::ostream& operator<<(std::ostream& out, const TIcebergSnapshot& obj);

typedef struct _TPartialTableInfo__isset {
  _TPartialTableInfo__isset() : hms_table(false), partitions(false), column_stats(false), storage_metadata_load_time_ns(false), network_addresses(false), sql_constraints(false), valid_write_ids(false), is_marked_cached(false), partition_prefixes(false), iceberg_snapshot(false) {}
  bool hms_table :1;
  bool partitions :1;
  bool column_stats :1;
  bool storage_metadata_load_time_ns :1;
  bool network_addresses :1;
  bool sql_constraints :1;
  bool valid_write_ids :1;
  bool is_marked_cached :1;
  bool partition_prefixes :1;
  bool iceberg_snapshot :1;
} _TPartialTableInfo__isset;

class TPartialTableInfo {
 public:

  TPartialTableInfo(const TPartialTableInfo&);
  TPartialTableInfo(TPartialTableInfo&&);
  TPartialTableInfo& operator=(const TPartialTableInfo&);
  TPartialTableInfo& operator=(TPartialTableInfo&&);
  TPartialTableInfo() : storage_metadata_load_time_ns(0), is_marked_cached(0) {
  }

  virtual ~TPartialTableInfo() throw();
   ::Apache::Hadoop::Hive::Table hms_table;
  std::vector<TPartialPartitionInfo>  partitions;
  std::vector< ::Apache::Hadoop::Hive::ColumnStatisticsObj>  column_stats;
  int64_t storage_metadata_load_time_ns;
  std::vector< ::impala::TNetworkAddress>  network_addresses;
   ::impala::TSqlConstraints sql_constraints;
   ::impala::TValidWriteIdList valid_write_ids;
  bool is_marked_cached;
  std::vector<std::string>  partition_prefixes;
  TIcebergSnapshot iceberg_snapshot;

  _TPartialTableInfo__isset __isset;

  void __set_hms_table(const  ::Apache::Hadoop::Hive::Table& val);

  void __set_partitions(const std::vector<TPartialPartitionInfo> & val);

  void __set_column_stats(const std::vector< ::Apache::Hadoop::Hive::ColumnStatisticsObj> & val);

  void __set_storage_metadata_load_time_ns(const int64_t val);

  void __set_network_addresses(const std::vector< ::impala::TNetworkAddress> & val);

  void __set_sql_constraints(const  ::impala::TSqlConstraints& val);

  void __set_valid_write_ids(const  ::impala::TValidWriteIdList& val);

  void __set_is_marked_cached(const bool val);

  void __set_partition_prefixes(const std::vector<std::string> & val);

  void __set_iceberg_snapshot(const TIcebergSnapshot& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartialTableInfo &a, TPartialTableInfo &b);

std::ostream& operator<<(std::ostream& out, const TPartialTableInfo& obj);

typedef struct _TBriefTableMeta__isset {
  _TBriefTableMeta__isset() : msType(false), comment(false) {}
  bool msType :1;
  bool comment :1;
} _TBriefTableMeta__isset;

class TBriefTableMeta {
 public:

  TBriefTableMeta(const TBriefTableMeta&);
  TBriefTableMeta(TBriefTableMeta&&);
  TBriefTableMeta& operator=(const TBriefTableMeta&);
  TBriefTableMeta& operator=(TBriefTableMeta&&);
  TBriefTableMeta() : name(), msType(), comment() {
  }

  virtual ~TBriefTableMeta() throw();
  std::string name;
  std::string msType;
  std::string comment;

  _TBriefTableMeta__isset __isset;

  void __set_name(const std::string& val);

  void __set_msType(const std::string& val);

  void __set_comment(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TBriefTableMeta &a, TBriefTableMeta &b);

std::ostream& operator<<(std::ostream& out, const TBriefTableMeta& obj);

typedef struct _TDbInfoSelector__isset {
  _TDbInfoSelector__isset() : want_hms_database(false), want_brief_meta_of_tables(false), want_function_names(false) {}
  bool want_hms_database :1;
  bool want_brief_meta_of_tables :1;
  bool want_function_names :1;
} _TDbInfoSelector__isset;

class TDbInfoSelector {
 public:

  TDbInfoSelector(const TDbInfoSelector&);
  TDbInfoSelector(TDbInfoSelector&&);
  TDbInfoSelector& operator=(const TDbInfoSelector&);
  TDbInfoSelector& operator=(TDbInfoSelector&&);
  TDbInfoSelector() : want_hms_database(0), want_brief_meta_of_tables(0), want_function_names(0) {
  }

  virtual ~TDbInfoSelector() throw();
  bool want_hms_database;
  bool want_brief_meta_of_tables;
  bool want_function_names;

  _TDbInfoSelector__isset __isset;

  void __set_want_hms_database(const bool val);

  void __set_want_brief_meta_of_tables(const bool val);

  void __set_want_function_names(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDbInfoSelector &a, TDbInfoSelector &b);

std::ostream& operator<<(std::ostream& out, const TDbInfoSelector& obj);

typedef struct _TPartialDbInfo__isset {
  _TPartialDbInfo__isset() : hms_database(false), brief_meta_of_tables(false), function_names(false) {}
  bool hms_database :1;
  bool brief_meta_of_tables :1;
  bool function_names :1;
} _TPartialDbInfo__isset;

class TPartialDbInfo {
 public:

  TPartialDbInfo(const TPartialDbInfo&);
  TPartialDbInfo(TPartialDbInfo&&);
  TPartialDbInfo& operator=(const TPartialDbInfo&);
  TPartialDbInfo& operator=(TPartialDbInfo&&);
  TPartialDbInfo() {
  }

  virtual ~TPartialDbInfo() throw();
   ::Apache::Hadoop::Hive::Database hms_database;
  std::vector<TBriefTableMeta>  brief_meta_of_tables;
  std::vector<std::string>  function_names;

  _TPartialDbInfo__isset __isset;

  void __set_hms_database(const  ::Apache::Hadoop::Hive::Database& val);

  void __set_brief_meta_of_tables(const std::vector<TBriefTableMeta> & val);

  void __set_function_names(const std::vector<std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPartialDbInfo &a, TPartialDbInfo &b);

std::ostream& operator<<(std::ostream& out, const TPartialDbInfo& obj);

typedef struct _TGetPartialCatalogObjectRequest__isset {
  _TGetPartialCatalogObjectRequest__isset() : table_info_selector(false), db_info_selector(false), catalog_info_selector(false) {}
  bool table_info_selector :1;
  bool db_info_selector :1;
  bool catalog_info_selector :1;
} _TGetPartialCatalogObjectRequest__isset;

class TGetPartialCatalogObjectRequest {
 public:

  TGetPartialCatalogObjectRequest(const TGetPartialCatalogObjectRequest&);
  TGetPartialCatalogObjectRequest(TGetPartialCatalogObjectRequest&&);
  TGetPartialCatalogObjectRequest& operator=(const TGetPartialCatalogObjectRequest&);
  TGetPartialCatalogObjectRequest& operator=(TGetPartialCatalogObjectRequest&&);
  TGetPartialCatalogObjectRequest() : protocol_version((CatalogServiceVersion::type)0) {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TGetPartialCatalogObjectRequest() throw();
  CatalogServiceVersion::type protocol_version;
   ::impala::TCatalogObject object_desc;
  TTableInfoSelector table_info_selector;
  TDbInfoSelector db_info_selector;
  TCatalogInfoSelector catalog_info_selector;

  _TGetPartialCatalogObjectRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_object_desc(const  ::impala::TCatalogObject& val);

  void __set_table_info_selector(const TTableInfoSelector& val);

  void __set_db_info_selector(const TDbInfoSelector& val);

  void __set_catalog_info_selector(const TCatalogInfoSelector& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetPartialCatalogObjectRequest &a, TGetPartialCatalogObjectRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetPartialCatalogObjectRequest& obj);

typedef struct _TGetPartialCatalogObjectResponse__isset {
  _TGetPartialCatalogObjectResponse__isset() : status(false), lookup_status(true), object_version_number(false), table_info(false), db_info(false), catalog_info(false), functions(false) {}
  bool status :1;
  bool lookup_status :1;
  bool object_version_number :1;
  bool table_info :1;
  bool db_info :1;
  bool catalog_info :1;
  bool functions :1;
} _TGetPartialCatalogObjectResponse__isset;

class TGetPartialCatalogObjectResponse {
 public:

  TGetPartialCatalogObjectResponse(const TGetPartialCatalogObjectResponse&);
  TGetPartialCatalogObjectResponse(TGetPartialCatalogObjectResponse&&);
  TGetPartialCatalogObjectResponse& operator=(const TGetPartialCatalogObjectResponse&);
  TGetPartialCatalogObjectResponse& operator=(TGetPartialCatalogObjectResponse&&);
  TGetPartialCatalogObjectResponse() : lookup_status((CatalogLookupStatus::type)0), object_version_number(0) {
    lookup_status = (CatalogLookupStatus::type)0;

  }

  virtual ~TGetPartialCatalogObjectResponse() throw();
   ::impala::TStatus status;
  CatalogLookupStatus::type lookup_status;
  int64_t object_version_number;
  TPartialTableInfo table_info;
  TPartialDbInfo db_info;
  TPartialCatalogInfo catalog_info;
  std::vector< ::impala::TFunction>  functions;

  _TGetPartialCatalogObjectResponse__isset __isset;

  void __set_status(const  ::impala::TStatus& val);

  void __set_lookup_status(const CatalogLookupStatus::type val);

  void __set_object_version_number(const int64_t val);

  void __set_table_info(const TPartialTableInfo& val);

  void __set_db_info(const TPartialDbInfo& val);

  void __set_catalog_info(const TPartialCatalogInfo& val);

  void __set_functions(const std::vector< ::impala::TFunction> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetPartialCatalogObjectResponse &a, TGetPartialCatalogObjectResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetPartialCatalogObjectResponse& obj);

typedef struct _TGetCatalogObjectRequest__isset {
  _TGetCatalogObjectRequest__isset() : header(false) {}
  bool header :1;
} _TGetCatalogObjectRequest__isset;

class TGetCatalogObjectRequest {
 public:

  TGetCatalogObjectRequest(const TGetCatalogObjectRequest&);
  TGetCatalogObjectRequest(TGetCatalogObjectRequest&&);
  TGetCatalogObjectRequest& operator=(const TGetCatalogObjectRequest&);
  TGetCatalogObjectRequest& operator=(TGetCatalogObjectRequest&&);
  TGetCatalogObjectRequest() : protocol_version((CatalogServiceVersion::type)0) {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TGetCatalogObjectRequest() throw();
  CatalogServiceVersion::type protocol_version;
  TCatalogServiceRequestHeader header;
   ::impala::TCatalogObject object_desc;

  _TGetCatalogObjectRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_header(const TCatalogServiceRequestHeader& val);

  void __set_object_desc(const  ::impala::TCatalogObject& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogObjectRequest &a, TGetCatalogObjectRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetCatalogObjectRequest& obj);


class TGetCatalogObjectResponse {
 public:

  TGetCatalogObjectResponse(const TGetCatalogObjectResponse&);
  TGetCatalogObjectResponse(TGetCatalogObjectResponse&&);
  TGetCatalogObjectResponse& operator=(const TGetCatalogObjectResponse&);
  TGetCatalogObjectResponse& operator=(TGetCatalogObjectResponse&&);
  TGetCatalogObjectResponse() {
  }

  virtual ~TGetCatalogObjectResponse() throw();
   ::impala::TCatalogObject catalog_object;

  void __set_catalog_object(const  ::impala::TCatalogObject& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetCatalogObjectResponse &a, TGetCatalogObjectResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetCatalogObjectResponse& obj);

typedef struct _TGetPartitionStatsRequest__isset {
  _TGetPartitionStatsRequest__isset() : valid_write_ids(false), table_id(true) {}
  bool valid_write_ids :1;
  bool table_id :1;
} _TGetPartitionStatsRequest__isset;

class TGetPartitionStatsRequest {
 public:

  TGetPartitionStatsRequest(const TGetPartitionStatsRequest&);
  TGetPartitionStatsRequest(TGetPartitionStatsRequest&&);
  TGetPartitionStatsRequest& operator=(const TGetPartitionStatsRequest&);
  TGetPartitionStatsRequest& operator=(TGetPartitionStatsRequest&&);
  TGetPartitionStatsRequest() : protocol_version((CatalogServiceVersion::type)0), table_id(-1LL) {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TGetPartitionStatsRequest() throw();
  CatalogServiceVersion::type protocol_version;
   ::impala::TTableName table_name;
   ::impala::TValidWriteIdList valid_write_ids;
  int64_t table_id;

  _TGetPartitionStatsRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_valid_write_ids(const  ::impala::TValidWriteIdList& val);

  void __set_table_id(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetPartitionStatsRequest &a, TGetPartitionStatsRequest &b);

std::ostream& operator<<(std::ostream& out, const TGetPartitionStatsRequest& obj);

typedef struct _TGetPartitionStatsResponse__isset {
  _TGetPartitionStatsResponse__isset() : status(false), partition_stats(false) {}
  bool status :1;
  bool partition_stats :1;
} _TGetPartitionStatsResponse__isset;

class TGetPartitionStatsResponse {
 public:

  TGetPartitionStatsResponse(const TGetPartitionStatsResponse&);
  TGetPartitionStatsResponse(TGetPartitionStatsResponse&&);
  TGetPartitionStatsResponse& operator=(const TGetPartitionStatsResponse&);
  TGetPartitionStatsResponse& operator=(TGetPartitionStatsResponse&&);
  TGetPartitionStatsResponse() {
  }

  virtual ~TGetPartitionStatsResponse() throw();
   ::impala::TStatus status;
  std::map<std::string, std::string>  partition_stats;

  _TGetPartitionStatsResponse__isset __isset;

  void __set_status(const  ::impala::TStatus& val);

  void __set_partition_stats(const std::map<std::string, std::string> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TGetPartitionStatsResponse &a, TGetPartitionStatsResponse &b);

std::ostream& operator<<(std::ostream& out, const TGetPartitionStatsResponse& obj);

typedef struct _TPrioritizeLoadRequest__isset {
  _TPrioritizeLoadRequest__isset() : header(false) {}
  bool header :1;
} _TPrioritizeLoadRequest__isset;

class TPrioritizeLoadRequest {
 public:

  TPrioritizeLoadRequest(const TPrioritizeLoadRequest&);
  TPrioritizeLoadRequest(TPrioritizeLoadRequest&&);
  TPrioritizeLoadRequest& operator=(const TPrioritizeLoadRequest&);
  TPrioritizeLoadRequest& operator=(TPrioritizeLoadRequest&&);
  TPrioritizeLoadRequest() : protocol_version((CatalogServiceVersion::type)0) {
    protocol_version = (CatalogServiceVersion::type)0;

  }

  virtual ~TPrioritizeLoadRequest() throw();
  CatalogServiceVersion::type protocol_version;
  TCatalogServiceRequestHeader header;
  std::vector< ::impala::TCatalogObject>  object_descs;

  _TPrioritizeLoadRequest__isset __isset;

  void __set_protocol_version(const CatalogServiceVersion::type val);

  void __set_header(const TCatalogServiceRequestHeader& val);

  void __set_object_descs(const std::vector< ::impala::TCatalogObject> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPrioritizeLoadRequest &a, TPrioritizeLoadRequest &b);

std::ostream& operator<<(std::ostream& out, const TPrioritizeLoadRequest& obj);


class TPrioritizeLoadResponse {
 public:

  TPrioritizeLoadResponse(const TPrioritizeLoadResponse&);
  TPrioritizeLoadResponse(TPrioritizeLoadResponse&&);
  TPrioritizeLoadResponse& operator=(const TPrioritizeLoadResponse&);
  TPrioritizeLoadResponse& operator=(TPrioritizeLoadResponse&&);
  TPrioritizeLoadResponse() {
  }

  virtual ~TPrioritizeLoadResponse() throw();
   ::impala::TStatus status;

  void __set_status(const  ::impala::TStatus& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPrioritizeLoadResponse &a, TPrioritizeLoadResponse &b);

std::ostream& operator<<(std::ostream& out, const TPrioritizeLoadResponse& obj);


class TTableUsage {
 public:

  TTableUsage(const TTableUsage&);
  TTableUsage(TTableUsage&&);
  TTableUsage& operator=(const TTableUsage&);
  TTableUsage& operator=(TTableUsage&&);
  TTableUsage() : num_usages(0) {
  }

  virtual ~TTableUsage() throw();
   ::impala::TTableName table_name;
  int32_t num_usages;

  void __set_table_name(const  ::impala::TTableName& val);

  void __set_num_usages(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TTableUsage &a, TTableUsage &b);

std::ostream& operator<<(std::ostream& out, const TTableUsage& obj);


class TUpdateTableUsageRequest {
 public:

  TUpdateTableUsageRequest(const TUpdateTableUsageRequest&);
  TUpdateTableUsageRequest(TUpdateTableUsageRequest&&);
  TUpdateTableUsageRequest& operator=(const TUpdateTableUsageRequest&);
  TUpdateTableUsageRequest& operator=(TUpdateTableUsageRequest&&);
  TUpdateTableUsageRequest() {
  }

  virtual ~TUpdateTableUsageRequest() throw();
  std::vector<TTableUsage>  usages;

  void __set_usages(const std::vector<TTableUsage> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateTableUsageRequest &a, TUpdateTableUsageRequest &b);

std::ostream& operator<<(std::ostream& out, const TUpdateTableUsageRequest& obj);

typedef struct _TUpdateTableUsageResponse__isset {
  _TUpdateTableUsageResponse__isset() : status(false) {}
  bool status :1;
} _TUpdateTableUsageResponse__isset;

class TUpdateTableUsageResponse {
 public:

  TUpdateTableUsageResponse(const TUpdateTableUsageResponse&);
  TUpdateTableUsageResponse(TUpdateTableUsageResponse&&);
  TUpdateTableUsageResponse& operator=(const TUpdateTableUsageResponse&);
  TUpdateTableUsageResponse& operator=(TUpdateTableUsageResponse&&);
  TUpdateTableUsageResponse() {
  }

  virtual ~TUpdateTableUsageResponse() throw();
   ::impala::TStatus status;

  _TUpdateTableUsageResponse__isset __isset;

  void __set_status(const  ::impala::TStatus& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUpdateTableUsageResponse &a, TUpdateTableUsageResponse &b);

std::ostream& operator<<(std::ostream& out, const TUpdateTableUsageResponse& obj);

} // namespace

#include "CatalogService_types.tcc"

#endif
