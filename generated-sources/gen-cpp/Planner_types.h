/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Planner_TYPES_H
#define Planner_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "Types_types.h"
#include "Exprs_types.h"
#include "DataSinks_types.h"
#include "PlanNodes_types.h"
#include "Partitions_types.h"


namespace impala {

class TPlanFragment;

class TScanRangeLocation;

class TScanRangeLocationList;

class TScanRangeSpec;

class TPlanFragmentTree;

typedef struct _TPlanFragment__isset {
  _TPlanFragment__isset() : plan(false), output_sink(false), backend_min_mem_reservation_bytes(false), instance_min_mem_reservation_bytes(false), instance_initial_mem_reservation_total_claims(false), backend_initial_mem_reservation_total_claims(false), produced_runtime_filters_reservation_bytes(false), consumed_runtime_filters_reservation_bytes(false), thread_reservation(false) {}
  bool plan :1;
  bool output_sink :1;
  bool backend_min_mem_reservation_bytes :1;
  bool instance_min_mem_reservation_bytes :1;
  bool instance_initial_mem_reservation_total_claims :1;
  bool backend_initial_mem_reservation_total_claims :1;
  bool produced_runtime_filters_reservation_bytes :1;
  bool consumed_runtime_filters_reservation_bytes :1;
  bool thread_reservation :1;
} _TPlanFragment__isset;

class TPlanFragment {
 public:

  TPlanFragment(const TPlanFragment&);
  TPlanFragment(TPlanFragment&&);
  TPlanFragment& operator=(const TPlanFragment&);
  TPlanFragment& operator=(TPlanFragment&&);
  TPlanFragment() : idx(0), display_name(), backend_min_mem_reservation_bytes(0), instance_min_mem_reservation_bytes(0), instance_initial_mem_reservation_total_claims(0), backend_initial_mem_reservation_total_claims(0), produced_runtime_filters_reservation_bytes(0), consumed_runtime_filters_reservation_bytes(0), thread_reservation(0) {
  }

  virtual ~TPlanFragment() throw();
   ::impala::TFragmentIdx idx;
  std::string display_name;
   ::impala::TPlan plan;
   ::impala::TDataSink output_sink;
   ::impala::TDataPartition partition;
  int64_t backend_min_mem_reservation_bytes;
  int64_t instance_min_mem_reservation_bytes;
  int64_t instance_initial_mem_reservation_total_claims;
  int64_t backend_initial_mem_reservation_total_claims;
  int64_t produced_runtime_filters_reservation_bytes;
  int64_t consumed_runtime_filters_reservation_bytes;
  int64_t thread_reservation;

  _TPlanFragment__isset __isset;

  void __set_idx(const  ::impala::TFragmentIdx val);

  void __set_display_name(const std::string& val);

  void __set_plan(const  ::impala::TPlan& val);

  void __set_output_sink(const  ::impala::TDataSink& val);

  void __set_partition(const  ::impala::TDataPartition& val);

  void __set_backend_min_mem_reservation_bytes(const int64_t val);

  void __set_instance_min_mem_reservation_bytes(const int64_t val);

  void __set_instance_initial_mem_reservation_total_claims(const int64_t val);

  void __set_backend_initial_mem_reservation_total_claims(const int64_t val);

  void __set_produced_runtime_filters_reservation_bytes(const int64_t val);

  void __set_consumed_runtime_filters_reservation_bytes(const int64_t val);

  void __set_thread_reservation(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanFragment &a, TPlanFragment &b);

std::ostream& operator<<(std::ostream& out, const TPlanFragment& obj);

typedef struct _TScanRangeLocation__isset {
  _TScanRangeLocation__isset() : volume_id(true), is_cached(true) {}
  bool volume_id :1;
  bool is_cached :1;
} _TScanRangeLocation__isset;

class TScanRangeLocation {
 public:

  TScanRangeLocation(const TScanRangeLocation&);
  TScanRangeLocation(TScanRangeLocation&&);
  TScanRangeLocation& operator=(const TScanRangeLocation&);
  TScanRangeLocation& operator=(TScanRangeLocation&&);
  TScanRangeLocation() : host_idx(0), volume_id(-1), is_cached(false) {
  }

  virtual ~TScanRangeLocation() throw();
  int32_t host_idx;
  int32_t volume_id;
  bool is_cached;

  _TScanRangeLocation__isset __isset;

  void __set_host_idx(const int32_t val);

  void __set_volume_id(const int32_t val);

  void __set_is_cached(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScanRangeLocation &a, TScanRangeLocation &b);

std::ostream& operator<<(std::ostream& out, const TScanRangeLocation& obj);

typedef struct _TScanRangeLocationList__isset {
  _TScanRangeLocationList__isset() : locations(false) {}
  bool locations :1;
} _TScanRangeLocationList__isset;

class TScanRangeLocationList {
 public:

  TScanRangeLocationList(const TScanRangeLocationList&);
  TScanRangeLocationList(TScanRangeLocationList&&);
  TScanRangeLocationList& operator=(const TScanRangeLocationList&);
  TScanRangeLocationList& operator=(TScanRangeLocationList&&);
  TScanRangeLocationList() {
  }

  virtual ~TScanRangeLocationList() throw();
   ::impala::TScanRange scan_range;
  std::vector<TScanRangeLocation>  locations;

  _TScanRangeLocationList__isset __isset;

  void __set_scan_range(const  ::impala::TScanRange& val);

  void __set_locations(const std::vector<TScanRangeLocation> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScanRangeLocationList &a, TScanRangeLocationList &b);

std::ostream& operator<<(std::ostream& out, const TScanRangeLocationList& obj);

typedef struct _TScanRangeSpec__isset {
  _TScanRangeSpec__isset() : concrete_ranges(false), split_specs(false) {}
  bool concrete_ranges :1;
  bool split_specs :1;
} _TScanRangeSpec__isset;

class TScanRangeSpec {
 public:

  TScanRangeSpec(const TScanRangeSpec&);
  TScanRangeSpec(TScanRangeSpec&&);
  TScanRangeSpec& operator=(const TScanRangeSpec&);
  TScanRangeSpec& operator=(TScanRangeSpec&&);
  TScanRangeSpec() {
  }

  virtual ~TScanRangeSpec() throw();
  std::vector<TScanRangeLocationList>  concrete_ranges;
  std::vector< ::impala::TFileSplitGeneratorSpec>  split_specs;

  _TScanRangeSpec__isset __isset;

  void __set_concrete_ranges(const std::vector<TScanRangeLocationList> & val);

  void __set_split_specs(const std::vector< ::impala::TFileSplitGeneratorSpec> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScanRangeSpec &a, TScanRangeSpec &b);

std::ostream& operator<<(std::ostream& out, const TScanRangeSpec& obj);


class TPlanFragmentTree {
 public:

  TPlanFragmentTree(const TPlanFragmentTree&);
  TPlanFragmentTree(TPlanFragmentTree&&);
  TPlanFragmentTree& operator=(const TPlanFragmentTree&);
  TPlanFragmentTree& operator=(TPlanFragmentTree&&);
  TPlanFragmentTree() : cohort_id(0) {
  }

  virtual ~TPlanFragmentTree() throw();
  int32_t cohort_id;
  std::vector<TPlanFragment>  fragments;

  void __set_cohort_id(const int32_t val);

  void __set_fragments(const std::vector<TPlanFragment> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanFragmentTree &a, TPlanFragmentTree &b);

std::ostream& operator<<(std::ostream& out, const TPlanFragmentTree& obj);

} // namespace

#include "Planner_types.tcc"

#endif
