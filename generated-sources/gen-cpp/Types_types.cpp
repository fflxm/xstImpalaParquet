/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Types_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTPrimitiveTypeValues[] = {
  TPrimitiveType::INVALID_TYPE,
  TPrimitiveType::NULL_TYPE,
  TPrimitiveType::BOOLEAN,
  TPrimitiveType::TINYINT,
  TPrimitiveType::SMALLINT,
  TPrimitiveType::INT,
  TPrimitiveType::BIGINT,
  TPrimitiveType::FLOAT,
  TPrimitiveType::DOUBLE,
  TPrimitiveType::DATE,
  TPrimitiveType::DATETIME,
  TPrimitiveType::TIMESTAMP,
  TPrimitiveType::STRING,
  TPrimitiveType::BINARY,
  TPrimitiveType::DECIMAL,
  TPrimitiveType::CHAR,
  TPrimitiveType::VARCHAR,
  TPrimitiveType::FIXED_UDA_INTERMEDIATE
};
const char* _kTPrimitiveTypeNames[] = {
  "INVALID_TYPE",
  "NULL_TYPE",
  "BOOLEAN",
  "TINYINT",
  "SMALLINT",
  "INT",
  "BIGINT",
  "FLOAT",
  "DOUBLE",
  "DATE",
  "DATETIME",
  "TIMESTAMP",
  "STRING",
  "BINARY",
  "DECIMAL",
  "CHAR",
  "VARCHAR",
  "FIXED_UDA_INTERMEDIATE"
};
const std::map<int, const char*> _TPrimitiveType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(18, _kTPrimitiveTypeValues, _kTPrimitiveTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPrimitiveType::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrimitiveType_VALUES_TO_NAMES.find(val);
  if (it != _TPrimitiveType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTTypeNodeTypeValues[] = {
  TTypeNodeType::SCALAR,
  TTypeNodeType::ARRAY,
  TTypeNodeType::MAP,
  TTypeNodeType::STRUCT
};
const char* _kTTypeNodeTypeNames[] = {
  "SCALAR",
  "ARRAY",
  "MAP",
  "STRUCT"
};
const std::map<int, const char*> _TTypeNodeType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTTypeNodeTypeValues, _kTTypeNodeTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TTypeNodeType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTypeNodeType_VALUES_TO_NAMES.find(val);
  if (it != _TTypeNodeType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTStmtTypeValues[] = {
  TStmtType::QUERY,
  TStmtType::DDL,
  TStmtType::DML,
  TStmtType::EXPLAIN,
  TStmtType::LOAD,
  TStmtType::SET,
  TStmtType::ADMIN_FN,
  TStmtType::TESTCASE
};
const char* _kTStmtTypeNames[] = {
  "QUERY",
  "DDL",
  "DML",
  "EXPLAIN",
  "LOAD",
  "SET",
  "ADMIN_FN",
  "TESTCASE"
};
const std::map<int, const char*> _TStmtType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTStmtTypeValues, _kTStmtTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TStmtType::type& val) {
  std::map<int, const char*>::const_iterator it = _TStmtType_VALUES_TO_NAMES.find(val);
  if (it != _TStmtType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTExplainLevelValues[] = {
  TExplainLevel::MINIMAL,
  TExplainLevel::STANDARD,
  TExplainLevel::EXTENDED,
  TExplainLevel::VERBOSE
};
const char* _kTExplainLevelNames[] = {
  "MINIMAL",
  "STANDARD",
  "EXTENDED",
  "VERBOSE"
};
const std::map<int, const char*> _TExplainLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTExplainLevelValues, _kTExplainLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TExplainLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _TExplainLevel_VALUES_TO_NAMES.find(val);
  if (it != _TExplainLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTRuntimeFilterModeValues[] = {
  TRuntimeFilterMode::OFF,
  TRuntimeFilterMode::LOCAL,
  TRuntimeFilterMode::GLOBAL
};
const char* _kTRuntimeFilterModeNames[] = {
  "OFF",
  "LOCAL",
  "GLOBAL"
};
const std::map<int, const char*> _TRuntimeFilterMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTRuntimeFilterModeValues, _kTRuntimeFilterModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TRuntimeFilterMode_VALUES_TO_NAMES.find(val);
  if (it != _TRuntimeFilterMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPrefetchModeValues[] = {
  TPrefetchMode::NONE,
  TPrefetchMode::HT_BUCKET
};
const char* _kTPrefetchModeNames[] = {
  "NONE",
  "HT_BUCKET"
};
const std::map<int, const char*> _TPrefetchMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTPrefetchModeValues, _kTPrefetchModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPrefetchMode::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrefetchMode_VALUES_TO_NAMES.find(val);
  if (it != _TPrefetchMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTFunctionCategoryValues[] = {
  TFunctionCategory::SCALAR,
  TFunctionCategory::AGGREGATE,
  TFunctionCategory::ANALYTIC
};
const char* _kTFunctionCategoryNames[] = {
  "SCALAR",
  "AGGREGATE",
  "ANALYTIC"
};
const std::map<int, const char*> _TFunctionCategory_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTFunctionCategoryValues, _kTFunctionCategoryNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TFunctionCategory::type& val) {
  std::map<int, const char*>::const_iterator it = _TFunctionCategory_VALUES_TO_NAMES.find(val);
  if (it != _TFunctionCategory_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTFunctionBinaryTypeValues[] = {
  TFunctionBinaryType::BUILTIN,
  TFunctionBinaryType::JAVA,
  TFunctionBinaryType::NATIVE,
  TFunctionBinaryType::IR
};
const char* _kTFunctionBinaryTypeNames[] = {
  "BUILTIN",
  "JAVA",
  "NATIVE",
  "IR"
};
const std::map<int, const char*> _TFunctionBinaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTFunctionBinaryTypeValues, _kTFunctionBinaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TFunctionBinaryType::type& val) {
  std::map<int, const char*>::const_iterator it = _TFunctionBinaryType_VALUES_TO_NAMES.find(val);
  if (it != _TFunctionBinaryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTSortingOrderValues[] = {
  TSortingOrder::LEXICAL,
  TSortingOrder::ZORDER
};
const char* _kTSortingOrderNames[] = {
  "LEXICAL",
  "ZORDER"
};
const std::map<int, const char*> _TSortingOrder_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTSortingOrderValues, _kTSortingOrderNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TSortingOrder::type& val) {
  std::map<int, const char*>::const_iterator it = _TSortingOrder_VALUES_TO_NAMES.find(val);
  if (it != _TSortingOrder_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TScalarType::~TScalarType() throw() {
}


void TScalarType::__set_type(const TPrimitiveType::type val) {
  this->type = val;
}

void TScalarType::__set_len(const int32_t val) {
  this->len = val;
__isset.len = true;
}

void TScalarType::__set_precision(const int32_t val) {
  this->precision = val;
__isset.precision = true;
}

void TScalarType::__set_scale(const int32_t val) {
  this->scale = val;
__isset.scale = true;
}
std::ostream& operator<<(std::ostream& out, const TScalarType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TScalarType &a, TScalarType &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.len, b.len);
  swap(a.precision, b.precision);
  swap(a.scale, b.scale);
  swap(a.__isset, b.__isset);
}

TScalarType::TScalarType(const TScalarType& other1) {
  type = other1.type;
  len = other1.len;
  precision = other1.precision;
  scale = other1.scale;
  __isset = other1.__isset;
}
TScalarType::TScalarType( TScalarType&& other2) {
  type = std::move(other2.type);
  len = std::move(other2.len);
  precision = std::move(other2.precision);
  scale = std::move(other2.scale);
  __isset = std::move(other2.__isset);
}
TScalarType& TScalarType::operator=(const TScalarType& other3) {
  type = other3.type;
  len = other3.len;
  precision = other3.precision;
  scale = other3.scale;
  __isset = other3.__isset;
  return *this;
}
TScalarType& TScalarType::operator=(TScalarType&& other4) {
  type = std::move(other4.type);
  len = std::move(other4.len);
  precision = std::move(other4.precision);
  scale = std::move(other4.scale);
  __isset = std::move(other4.__isset);
  return *this;
}
void TScalarType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScalarType(";
  out << "type=" << to_string(type);
  out << ", " << "len="; (__isset.len ? (out << to_string(len)) : (out << "<null>"));
  out << ", " << "precision="; (__isset.precision ? (out << to_string(precision)) : (out << "<null>"));
  out << ", " << "scale="; (__isset.scale ? (out << to_string(scale)) : (out << "<null>"));
  out << ")";
}


TStructField::~TStructField() throw() {
}


void TStructField::__set_name(const std::string& val) {
  this->name = val;
}

void TStructField::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void TStructField::__set_field_id(const int32_t val) {
  this->field_id = val;
__isset.field_id = true;
}
std::ostream& operator<<(std::ostream& out, const TStructField& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TStructField &a, TStructField &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.comment, b.comment);
  swap(a.field_id, b.field_id);
  swap(a.__isset, b.__isset);
}

TStructField::TStructField(const TStructField& other5) {
  name = other5.name;
  comment = other5.comment;
  field_id = other5.field_id;
  __isset = other5.__isset;
}
TStructField::TStructField( TStructField&& other6) {
  name = std::move(other6.name);
  comment = std::move(other6.comment);
  field_id = std::move(other6.field_id);
  __isset = std::move(other6.__isset);
}
TStructField& TStructField::operator=(const TStructField& other7) {
  name = other7.name;
  comment = other7.comment;
  field_id = other7.field_id;
  __isset = other7.__isset;
  return *this;
}
TStructField& TStructField::operator=(TStructField&& other8) {
  name = std::move(other8.name);
  comment = std::move(other8.comment);
  field_id = std::move(other8.field_id);
  __isset = std::move(other8.__isset);
  return *this;
}
void TStructField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TStructField(";
  out << "name=" << to_string(name);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "field_id="; (__isset.field_id ? (out << to_string(field_id)) : (out << "<null>"));
  out << ")";
}


TTypeNode::~TTypeNode() throw() {
}


void TTypeNode::__set_type(const TTypeNodeType::type val) {
  this->type = val;
}

void TTypeNode::__set_scalar_type(const TScalarType& val) {
  this->scalar_type = val;
__isset.scalar_type = true;
}

void TTypeNode::__set_struct_fields(const std::vector<TStructField> & val) {
  this->struct_fields = val;
__isset.struct_fields = true;
}
std::ostream& operator<<(std::ostream& out, const TTypeNode& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTypeNode &a, TTypeNode &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.scalar_type, b.scalar_type);
  swap(a.struct_fields, b.struct_fields);
  swap(a.__isset, b.__isset);
}

TTypeNode::TTypeNode(const TTypeNode& other16) {
  type = other16.type;
  scalar_type = other16.scalar_type;
  struct_fields = other16.struct_fields;
  __isset = other16.__isset;
}
TTypeNode::TTypeNode( TTypeNode&& other17) {
  type = std::move(other17.type);
  scalar_type = std::move(other17.scalar_type);
  struct_fields = std::move(other17.struct_fields);
  __isset = std::move(other17.__isset);
}
TTypeNode& TTypeNode::operator=(const TTypeNode& other18) {
  type = other18.type;
  scalar_type = other18.scalar_type;
  struct_fields = other18.struct_fields;
  __isset = other18.__isset;
  return *this;
}
TTypeNode& TTypeNode::operator=(TTypeNode&& other19) {
  type = std::move(other19.type);
  scalar_type = std::move(other19.scalar_type);
  struct_fields = std::move(other19.struct_fields);
  __isset = std::move(other19.__isset);
  return *this;
}
void TTypeNode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTypeNode(";
  out << "type=" << to_string(type);
  out << ", " << "scalar_type="; (__isset.scalar_type ? (out << to_string(scalar_type)) : (out << "<null>"));
  out << ", " << "struct_fields="; (__isset.struct_fields ? (out << to_string(struct_fields)) : (out << "<null>"));
  out << ")";
}


TColumnType::~TColumnType() throw() {
}


void TColumnType::__set_types(const std::vector<TTypeNode> & val) {
  this->types = val;
}
std::ostream& operator<<(std::ostream& out, const TColumnType& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TColumnType &a, TColumnType &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.__isset, b.__isset);
}

TColumnType::TColumnType(const TColumnType& other26) {
  types = other26.types;
  __isset = other26.__isset;
}
TColumnType::TColumnType( TColumnType&& other27) {
  types = std::move(other27.types);
  __isset = std::move(other27.__isset);
}
TColumnType& TColumnType::operator=(const TColumnType& other28) {
  types = other28.types;
  __isset = other28.__isset;
  return *this;
}
TColumnType& TColumnType::operator=(TColumnType&& other29) {
  types = std::move(other29.types);
  __isset = std::move(other29.__isset);
  return *this;
}
void TColumnType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnType(";
  out << "types=" << to_string(types);
  out << ")";
}


TNetworkAddress::~TNetworkAddress() throw() {
}


void TNetworkAddress::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void TNetworkAddress::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const TNetworkAddress& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TNetworkAddress &a, TNetworkAddress &b) {
  using ::std::swap;
  swap(a.hostname, b.hostname);
  swap(a.port, b.port);
}

TNetworkAddress::TNetworkAddress(const TNetworkAddress& other30) {
  hostname = other30.hostname;
  port = other30.port;
}
TNetworkAddress::TNetworkAddress( TNetworkAddress&& other31) {
  hostname = std::move(other31.hostname);
  port = std::move(other31.port);
}
TNetworkAddress& TNetworkAddress::operator=(const TNetworkAddress& other32) {
  hostname = other32.hostname;
  port = other32.port;
  return *this;
}
TNetworkAddress& TNetworkAddress::operator=(TNetworkAddress&& other33) {
  hostname = std::move(other33.hostname);
  port = std::move(other33.port);
  return *this;
}
void TNetworkAddress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TNetworkAddress(";
  out << "hostname=" << to_string(hostname);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


TUniqueId::~TUniqueId() throw() {
}


void TUniqueId::__set_hi(const int64_t val) {
  this->hi = val;
}

void TUniqueId::__set_lo(const int64_t val) {
  this->lo = val;
}
std::ostream& operator<<(std::ostream& out, const TUniqueId& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TUniqueId &a, TUniqueId &b) {
  using ::std::swap;
  swap(a.hi, b.hi);
  swap(a.lo, b.lo);
}

TUniqueId::TUniqueId(const TUniqueId& other34) {
  hi = other34.hi;
  lo = other34.lo;
}
TUniqueId::TUniqueId( TUniqueId&& other35) {
  hi = std::move(other35.hi);
  lo = std::move(other35.lo);
}
TUniqueId& TUniqueId::operator=(const TUniqueId& other36) {
  hi = other36.hi;
  lo = other36.lo;
  return *this;
}
TUniqueId& TUniqueId::operator=(TUniqueId&& other37) {
  hi = std::move(other37.hi);
  lo = std::move(other37.lo);
  return *this;
}
void TUniqueId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TUniqueId(";
  out << "hi=" << to_string(hi);
  out << ", " << "lo=" << to_string(lo);
  out << ")";
}


TFunctionName::~TFunctionName() throw() {
}


void TFunctionName::__set_db_name(const std::string& val) {
  this->db_name = val;
__isset.db_name = true;
}

void TFunctionName::__set_function_name(const std::string& val) {
  this->function_name = val;
}
std::ostream& operator<<(std::ostream& out, const TFunctionName& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TFunctionName &a, TFunctionName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.function_name, b.function_name);
  swap(a.__isset, b.__isset);
}

TFunctionName::TFunctionName(const TFunctionName& other38) {
  db_name = other38.db_name;
  function_name = other38.function_name;
  __isset = other38.__isset;
}
TFunctionName::TFunctionName( TFunctionName&& other39) {
  db_name = std::move(other39.db_name);
  function_name = std::move(other39.function_name);
  __isset = std::move(other39.__isset);
}
TFunctionName& TFunctionName::operator=(const TFunctionName& other40) {
  db_name = other40.db_name;
  function_name = other40.function_name;
  __isset = other40.__isset;
  return *this;
}
TFunctionName& TFunctionName::operator=(TFunctionName&& other41) {
  db_name = std::move(other41.db_name);
  function_name = std::move(other41.function_name);
  __isset = std::move(other41.__isset);
  return *this;
}
void TFunctionName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunctionName(";
  out << "db_name="; (__isset.db_name ? (out << to_string(db_name)) : (out << "<null>"));
  out << ", " << "function_name=" << to_string(function_name);
  out << ")";
}


TScalarFunction::~TScalarFunction() throw() {
}


void TScalarFunction::__set_symbol(const std::string& val) {
  this->symbol = val;
}

void TScalarFunction::__set_prepare_fn_symbol(const std::string& val) {
  this->prepare_fn_symbol = val;
__isset.prepare_fn_symbol = true;
}

void TScalarFunction::__set_close_fn_symbol(const std::string& val) {
  this->close_fn_symbol = val;
__isset.close_fn_symbol = true;
}
std::ostream& operator<<(std::ostream& out, const TScalarFunction& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TScalarFunction &a, TScalarFunction &b) {
  using ::std::swap;
  swap(a.symbol, b.symbol);
  swap(a.prepare_fn_symbol, b.prepare_fn_symbol);
  swap(a.close_fn_symbol, b.close_fn_symbol);
  swap(a.__isset, b.__isset);
}

TScalarFunction::TScalarFunction(const TScalarFunction& other42) {
  symbol = other42.symbol;
  prepare_fn_symbol = other42.prepare_fn_symbol;
  close_fn_symbol = other42.close_fn_symbol;
  __isset = other42.__isset;
}
TScalarFunction::TScalarFunction( TScalarFunction&& other43) {
  symbol = std::move(other43.symbol);
  prepare_fn_symbol = std::move(other43.prepare_fn_symbol);
  close_fn_symbol = std::move(other43.close_fn_symbol);
  __isset = std::move(other43.__isset);
}
TScalarFunction& TScalarFunction::operator=(const TScalarFunction& other44) {
  symbol = other44.symbol;
  prepare_fn_symbol = other44.prepare_fn_symbol;
  close_fn_symbol = other44.close_fn_symbol;
  __isset = other44.__isset;
  return *this;
}
TScalarFunction& TScalarFunction::operator=(TScalarFunction&& other45) {
  symbol = std::move(other45.symbol);
  prepare_fn_symbol = std::move(other45.prepare_fn_symbol);
  close_fn_symbol = std::move(other45.close_fn_symbol);
  __isset = std::move(other45.__isset);
  return *this;
}
void TScalarFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TScalarFunction(";
  out << "symbol=" << to_string(symbol);
  out << ", " << "prepare_fn_symbol="; (__isset.prepare_fn_symbol ? (out << to_string(prepare_fn_symbol)) : (out << "<null>"));
  out << ", " << "close_fn_symbol="; (__isset.close_fn_symbol ? (out << to_string(close_fn_symbol)) : (out << "<null>"));
  out << ")";
}


TAggregateFunction::~TAggregateFunction() throw() {
}


void TAggregateFunction::__set_intermediate_type(const TColumnType& val) {
  this->intermediate_type = val;
}

void TAggregateFunction::__set_is_analytic_only_fn(const bool val) {
  this->is_analytic_only_fn = val;
}

void TAggregateFunction::__set_update_fn_symbol(const std::string& val) {
  this->update_fn_symbol = val;
}

void TAggregateFunction::__set_init_fn_symbol(const std::string& val) {
  this->init_fn_symbol = val;
}

void TAggregateFunction::__set_serialize_fn_symbol(const std::string& val) {
  this->serialize_fn_symbol = val;
__isset.serialize_fn_symbol = true;
}

void TAggregateFunction::__set_merge_fn_symbol(const std::string& val) {
  this->merge_fn_symbol = val;
__isset.merge_fn_symbol = true;
}

void TAggregateFunction::__set_finalize_fn_symbol(const std::string& val) {
  this->finalize_fn_symbol = val;
__isset.finalize_fn_symbol = true;
}

void TAggregateFunction::__set_get_value_fn_symbol(const std::string& val) {
  this->get_value_fn_symbol = val;
__isset.get_value_fn_symbol = true;
}

void TAggregateFunction::__set_remove_fn_symbol(const std::string& val) {
  this->remove_fn_symbol = val;
__isset.remove_fn_symbol = true;
}

void TAggregateFunction::__set_ignores_distinct(const bool val) {
  this->ignores_distinct = val;
__isset.ignores_distinct = true;
}
std::ostream& operator<<(std::ostream& out, const TAggregateFunction& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAggregateFunction &a, TAggregateFunction &b) {
  using ::std::swap;
  swap(a.intermediate_type, b.intermediate_type);
  swap(a.is_analytic_only_fn, b.is_analytic_only_fn);
  swap(a.update_fn_symbol, b.update_fn_symbol);
  swap(a.init_fn_symbol, b.init_fn_symbol);
  swap(a.serialize_fn_symbol, b.serialize_fn_symbol);
  swap(a.merge_fn_symbol, b.merge_fn_symbol);
  swap(a.finalize_fn_symbol, b.finalize_fn_symbol);
  swap(a.get_value_fn_symbol, b.get_value_fn_symbol);
  swap(a.remove_fn_symbol, b.remove_fn_symbol);
  swap(a.ignores_distinct, b.ignores_distinct);
  swap(a.__isset, b.__isset);
}

TAggregateFunction::TAggregateFunction(const TAggregateFunction& other46) {
  intermediate_type = other46.intermediate_type;
  is_analytic_only_fn = other46.is_analytic_only_fn;
  update_fn_symbol = other46.update_fn_symbol;
  init_fn_symbol = other46.init_fn_symbol;
  serialize_fn_symbol = other46.serialize_fn_symbol;
  merge_fn_symbol = other46.merge_fn_symbol;
  finalize_fn_symbol = other46.finalize_fn_symbol;
  get_value_fn_symbol = other46.get_value_fn_symbol;
  remove_fn_symbol = other46.remove_fn_symbol;
  ignores_distinct = other46.ignores_distinct;
  __isset = other46.__isset;
}
TAggregateFunction::TAggregateFunction( TAggregateFunction&& other47) {
  intermediate_type = std::move(other47.intermediate_type);
  is_analytic_only_fn = std::move(other47.is_analytic_only_fn);
  update_fn_symbol = std::move(other47.update_fn_symbol);
  init_fn_symbol = std::move(other47.init_fn_symbol);
  serialize_fn_symbol = std::move(other47.serialize_fn_symbol);
  merge_fn_symbol = std::move(other47.merge_fn_symbol);
  finalize_fn_symbol = std::move(other47.finalize_fn_symbol);
  get_value_fn_symbol = std::move(other47.get_value_fn_symbol);
  remove_fn_symbol = std::move(other47.remove_fn_symbol);
  ignores_distinct = std::move(other47.ignores_distinct);
  __isset = std::move(other47.__isset);
}
TAggregateFunction& TAggregateFunction::operator=(const TAggregateFunction& other48) {
  intermediate_type = other48.intermediate_type;
  is_analytic_only_fn = other48.is_analytic_only_fn;
  update_fn_symbol = other48.update_fn_symbol;
  init_fn_symbol = other48.init_fn_symbol;
  serialize_fn_symbol = other48.serialize_fn_symbol;
  merge_fn_symbol = other48.merge_fn_symbol;
  finalize_fn_symbol = other48.finalize_fn_symbol;
  get_value_fn_symbol = other48.get_value_fn_symbol;
  remove_fn_symbol = other48.remove_fn_symbol;
  ignores_distinct = other48.ignores_distinct;
  __isset = other48.__isset;
  return *this;
}
TAggregateFunction& TAggregateFunction::operator=(TAggregateFunction&& other49) {
  intermediate_type = std::move(other49.intermediate_type);
  is_analytic_only_fn = std::move(other49.is_analytic_only_fn);
  update_fn_symbol = std::move(other49.update_fn_symbol);
  init_fn_symbol = std::move(other49.init_fn_symbol);
  serialize_fn_symbol = std::move(other49.serialize_fn_symbol);
  merge_fn_symbol = std::move(other49.merge_fn_symbol);
  finalize_fn_symbol = std::move(other49.finalize_fn_symbol);
  get_value_fn_symbol = std::move(other49.get_value_fn_symbol);
  remove_fn_symbol = std::move(other49.remove_fn_symbol);
  ignores_distinct = std::move(other49.ignores_distinct);
  __isset = std::move(other49.__isset);
  return *this;
}
void TAggregateFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAggregateFunction(";
  out << "intermediate_type=" << to_string(intermediate_type);
  out << ", " << "is_analytic_only_fn=" << to_string(is_analytic_only_fn);
  out << ", " << "update_fn_symbol=" << to_string(update_fn_symbol);
  out << ", " << "init_fn_symbol=" << to_string(init_fn_symbol);
  out << ", " << "serialize_fn_symbol="; (__isset.serialize_fn_symbol ? (out << to_string(serialize_fn_symbol)) : (out << "<null>"));
  out << ", " << "merge_fn_symbol="; (__isset.merge_fn_symbol ? (out << to_string(merge_fn_symbol)) : (out << "<null>"));
  out << ", " << "finalize_fn_symbol="; (__isset.finalize_fn_symbol ? (out << to_string(finalize_fn_symbol)) : (out << "<null>"));
  out << ", " << "get_value_fn_symbol="; (__isset.get_value_fn_symbol ? (out << to_string(get_value_fn_symbol)) : (out << "<null>"));
  out << ", " << "remove_fn_symbol="; (__isset.remove_fn_symbol ? (out << to_string(remove_fn_symbol)) : (out << "<null>"));
  out << ", " << "ignores_distinct="; (__isset.ignores_distinct ? (out << to_string(ignores_distinct)) : (out << "<null>"));
  out << ")";
}


TFunction::~TFunction() throw() {
}


void TFunction::__set_name(const TFunctionName& val) {
  this->name = val;
}

void TFunction::__set_binary_type(const TFunctionBinaryType::type val) {
  this->binary_type = val;
__isset.binary_type = true;
}

void TFunction::__set_arg_types(const std::vector<TColumnType> & val) {
  this->arg_types = val;
__isset.arg_types = true;
}

void TFunction::__set_ret_type(const TColumnType& val) {
  this->ret_type = val;
__isset.ret_type = true;
}

void TFunction::__set_has_var_args(const bool val) {
  this->has_var_args = val;
__isset.has_var_args = true;
}

void TFunction::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void TFunction::__set_signature(const std::string& val) {
  this->signature = val;
__isset.signature = true;
}

void TFunction::__set_hdfs_location(const std::string& val) {
  this->hdfs_location = val;
__isset.hdfs_location = true;
}

void TFunction::__set_scalar_fn(const TScalarFunction& val) {
  this->scalar_fn = val;
__isset.scalar_fn = true;
}

void TFunction::__set_aggregate_fn(const TAggregateFunction& val) {
  this->aggregate_fn = val;
__isset.aggregate_fn = true;
}

void TFunction::__set_is_persistent(const bool val) {
  this->is_persistent = val;
__isset.is_persistent = true;
}

void TFunction::__set_last_modified_time(const int64_t val) {
  this->last_modified_time = val;
__isset.last_modified_time = true;
}
std::ostream& operator<<(std::ostream& out, const TFunction& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TFunction &a, TFunction &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.binary_type, b.binary_type);
  swap(a.arg_types, b.arg_types);
  swap(a.ret_type, b.ret_type);
  swap(a.has_var_args, b.has_var_args);
  swap(a.comment, b.comment);
  swap(a.signature, b.signature);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.scalar_fn, b.scalar_fn);
  swap(a.aggregate_fn, b.aggregate_fn);
  swap(a.is_persistent, b.is_persistent);
  swap(a.last_modified_time, b.last_modified_time);
  swap(a.__isset, b.__isset);
}

TFunction::TFunction(const TFunction& other57) {
  name = other57.name;
  binary_type = other57.binary_type;
  arg_types = other57.arg_types;
  ret_type = other57.ret_type;
  has_var_args = other57.has_var_args;
  comment = other57.comment;
  signature = other57.signature;
  hdfs_location = other57.hdfs_location;
  scalar_fn = other57.scalar_fn;
  aggregate_fn = other57.aggregate_fn;
  is_persistent = other57.is_persistent;
  last_modified_time = other57.last_modified_time;
  __isset = other57.__isset;
}
TFunction::TFunction( TFunction&& other58) {
  name = std::move(other58.name);
  binary_type = std::move(other58.binary_type);
  arg_types = std::move(other58.arg_types);
  ret_type = std::move(other58.ret_type);
  has_var_args = std::move(other58.has_var_args);
  comment = std::move(other58.comment);
  signature = std::move(other58.signature);
  hdfs_location = std::move(other58.hdfs_location);
  scalar_fn = std::move(other58.scalar_fn);
  aggregate_fn = std::move(other58.aggregate_fn);
  is_persistent = std::move(other58.is_persistent);
  last_modified_time = std::move(other58.last_modified_time);
  __isset = std::move(other58.__isset);
}
TFunction& TFunction::operator=(const TFunction& other59) {
  name = other59.name;
  binary_type = other59.binary_type;
  arg_types = other59.arg_types;
  ret_type = other59.ret_type;
  has_var_args = other59.has_var_args;
  comment = other59.comment;
  signature = other59.signature;
  hdfs_location = other59.hdfs_location;
  scalar_fn = other59.scalar_fn;
  aggregate_fn = other59.aggregate_fn;
  is_persistent = other59.is_persistent;
  last_modified_time = other59.last_modified_time;
  __isset = other59.__isset;
  return *this;
}
TFunction& TFunction::operator=(TFunction&& other60) {
  name = std::move(other60.name);
  binary_type = std::move(other60.binary_type);
  arg_types = std::move(other60.arg_types);
  ret_type = std::move(other60.ret_type);
  has_var_args = std::move(other60.has_var_args);
  comment = std::move(other60.comment);
  signature = std::move(other60.signature);
  hdfs_location = std::move(other60.hdfs_location);
  scalar_fn = std::move(other60.scalar_fn);
  aggregate_fn = std::move(other60.aggregate_fn);
  is_persistent = std::move(other60.is_persistent);
  last_modified_time = std::move(other60.last_modified_time);
  __isset = std::move(other60.__isset);
  return *this;
}
void TFunction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TFunction(";
  out << "name=" << to_string(name);
  out << ", " << "binary_type="; (__isset.binary_type ? (out << to_string(binary_type)) : (out << "<null>"));
  out << ", " << "arg_types="; (__isset.arg_types ? (out << to_string(arg_types)) : (out << "<null>"));
  out << ", " << "ret_type="; (__isset.ret_type ? (out << to_string(ret_type)) : (out << "<null>"));
  out << ", " << "has_var_args="; (__isset.has_var_args ? (out << to_string(has_var_args)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "hdfs_location="; (__isset.hdfs_location ? (out << to_string(hdfs_location)) : (out << "<null>"));
  out << ", " << "scalar_fn="; (__isset.scalar_fn ? (out << to_string(scalar_fn)) : (out << "<null>"));
  out << ", " << "aggregate_fn="; (__isset.aggregate_fn ? (out << to_string(aggregate_fn)) : (out << "<null>"));
  out << ", " << "is_persistent="; (__isset.is_persistent ? (out << to_string(is_persistent)) : (out << "<null>"));
  out << ", " << "last_modified_time="; (__isset.last_modified_time ? (out << to_string(last_modified_time)) : (out << "<null>"));
  out << ")";
}

} // namespace
