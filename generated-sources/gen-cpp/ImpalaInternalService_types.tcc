/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ImpalaInternalService_TYPES_TCC
#define ImpalaInternalService_TYPES_TCC

#include "Status_types.tcc"
#include "ErrorCodes_types.tcc"
#include "Types_types.tcc"
#include "Exprs_types.tcc"
#include "CatalogObjects_types.tcc"
#include "Descriptors_types.tcc"
#include "PlanNodes_types.tcc"
#include "Planner_types.tcc"
#include "DataSinks_types.tcc"
#include "Results_types.tcc"
#include "RuntimeProfile_types.tcc"
#include "ImpalaService_types.tcc"
#include "Data_types.tcc"
#include "Query_types.tcc"
#include "ImpalaInternalService_types.h"

namespace impala {

template <class Protocol_>
uint32_t TDebugOptions::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->node_id);
          this->__isset.node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->phase = ( ::impala::TExecNodePhase::type)ecast0;
          this->__isset.phase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast1;
          xfer += iprot->readI32(ecast1);
          this->action = ( ::impala::TDebugAction::type)ecast1;
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->action_param);
          this->__isset.action_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TDebugOptions::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDebugOptions");

  if (this->__isset.node_id) {
    xfer += oprot->writeFieldBegin("node_id", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->node_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.phase) {
    xfer += oprot->writeFieldBegin("phase", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->phase);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.action) {
    xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.action_param) {
    xfer += oprot->writeFieldBegin("action_param", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->action_param);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TRuntimeFilterSource::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_src_node_id = false;
  bool isset_filter_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->src_node_id);
          isset_src_node_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->filter_id);
          isset_filter_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_src_node_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_filter_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TRuntimeFilterSource::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRuntimeFilterSource");

  xfer += oprot->writeFieldBegin("src_node_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->src_node_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("filter_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->filter_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPlanFragmentInstanceCtx::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fragment_idx = false;
  bool isset_fragment_instance_id = false;
  bool isset_per_fragment_instance_idx = false;
  bool isset_per_exch_num_senders = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fragment_idx);
          isset_fragment_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fragment_instance_id.read(iprot);
          isset_fragment_instance_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->per_fragment_instance_idx);
          isset_per_fragment_instance_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->per_exch_num_senders.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _ktype11;
            ::apache::thrift::protocol::TType _vtype12;
            xfer += iprot->readMapBegin(_ktype11, _vtype12, _size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
               ::impala::TPlanNodeId _key15;
              xfer += iprot->readI32(_key15);
              int32_t& _val16 = this->per_exch_num_senders[_key15];
              xfer += iprot->readI32(_val16);
            }
            xfer += iprot->readMapEnd();
          }
          isset_per_exch_num_senders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sender_id);
          this->__isset.sender_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->debug_options.read(iprot);
          this->__isset.debug_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->filters_produced.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->filters_produced.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->filters_produced[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.filters_produced = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_join_build_outputs);
          this->__isset.num_join_build_outputs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_backends);
          this->__isset.num_backends = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fragment_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fragment_instance_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_fragment_instance_idx)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_per_exch_num_senders)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPlanFragmentInstanceCtx::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPlanFragmentInstanceCtx");

  xfer += oprot->writeFieldBegin("fragment_idx", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fragment_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fragment_instance_id", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->fragment_instance_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("per_fragment_instance_idx", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->per_fragment_instance_idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("per_exch_num_senders", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->per_exch_num_senders.size()));
    std::map< ::impala::TPlanNodeId, int32_t> ::const_iterator _iter22;
    for (_iter22 = this->per_exch_num_senders.begin(); _iter22 != this->per_exch_num_senders.end(); ++_iter22)
    {
      xfer += oprot->writeI32(_iter22->first);
      xfer += oprot->writeI32(_iter22->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sender_id) {
    xfer += oprot->writeFieldBegin("sender_id", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->sender_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.debug_options) {
    xfer += oprot->writeFieldBegin("debug_options", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->debug_options.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.filters_produced) {
    xfer += oprot->writeFieldBegin("filters_produced", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->filters_produced.size()));
      std::vector<TRuntimeFilterSource> ::const_iterator _iter23;
      for (_iter23 = this->filters_produced.begin(); _iter23 != this->filters_produced.end(); ++_iter23)
      {
        xfer += (*_iter23).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_join_build_outputs) {
    xfer += oprot->writeFieldBegin("num_join_build_outputs", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->num_join_build_outputs);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_backends) {
    xfer += oprot->writeFieldBegin("num_backends", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->num_backends);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExecPlanFragmentInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fragments.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->fragments.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->fragments[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fragments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fragment_instance_ctxs.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->fragment_instance_ctxs.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->fragment_instance_ctxs[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fragment_instance_ctxs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TExecPlanFragmentInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecPlanFragmentInfo");

  if (this->__isset.fragments) {
    xfer += oprot->writeFieldBegin("fragments", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fragments.size()));
      std::vector< ::impala::TPlanFragment> ::const_iterator _iter38;
      for (_iter38 = this->fragments.begin(); _iter38 != this->fragments.end(); ++_iter38)
      {
        xfer += (*_iter38).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fragment_instance_ctxs) {
    xfer += oprot->writeFieldBegin("fragment_instance_ctxs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fragment_instance_ctxs.size()));
      std::vector<TPlanFragmentInstanceCtx> ::const_iterator _iter39;
      for (_iter39 = this->fragment_instance_ctxs.begin(); _iter39 != this->fragment_instance_ctxs.end(); ++_iter39)
      {
        xfer += (*_iter39).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TResolveRequestPoolParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;
  bool isset_requested_pool = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requested_pool);
          isset_requested_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_requested_pool)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TResolveRequestPoolParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResolveRequestPoolParams");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("requested_pool", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->requested_pool);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TResolveRequestPoolResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resolved_pool);
          this->__isset.resolved_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_access);
          this->__isset.has_access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TResolveRequestPoolResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TResolveRequestPoolResult");

  if (this->__isset.resolved_pool) {
    xfer += oprot->writeFieldBegin("resolved_pool", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->resolved_pool);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_access) {
    xfer += oprot->writeFieldBegin("has_access", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->has_access);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPoolConfigParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pool = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pool);
          isset_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pool)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPoolConfigParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPoolConfigParams");

  xfer += oprot->writeFieldBegin("pool", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pool);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPoolConfig::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_max_requests = false;
  bool isset_max_queued = false;
  bool isset_max_mem_resources = false;
  bool isset_default_query_options = false;
  bool isset_max_query_mem_limit = false;
  bool isset_min_query_mem_limit = false;
  bool isset_clamp_mem_limit_query_option = false;
  bool isset_max_mt_dop = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_requests);
          isset_max_requests = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_queued);
          isset_max_queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_mem_resources);
          isset_max_mem_resources = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queue_timeout_ms);
          this->__isset.queue_timeout_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->default_query_options);
          isset_default_query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_query_mem_limit);
          isset_max_query_mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_query_mem_limit);
          isset_min_query_mem_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->clamp_mem_limit_query_option);
          isset_clamp_mem_limit_query_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_mt_dop);
          isset_max_mt_dop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_max_requests)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_queued)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_mem_resources)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_default_query_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_query_mem_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_min_query_mem_limit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_clamp_mem_limit_query_option)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_mt_dop)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPoolConfig::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPoolConfig");

  xfer += oprot->writeFieldBegin("max_requests", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->max_requests);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_queued", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max_queued);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_mem_resources", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max_mem_resources);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queue_timeout_ms) {
    xfer += oprot->writeFieldBegin("queue_timeout_ms", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->queue_timeout_ms);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("default_query_options", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->default_query_options);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_query_mem_limit", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->max_query_mem_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min_query_mem_limit", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->min_query_mem_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clamp_mem_limit_query_option", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->clamp_mem_limit_query_option);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_mt_dop", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->max_mt_dop);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TParseDateStringResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_valid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->valid);
          isset_valid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->days_since_epoch);
          this->__isset.days_since_epoch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->canonical_date_string);
          this->__isset.canonical_date_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_valid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TParseDateStringResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TParseDateStringResult");

  xfer += oprot->writeFieldBegin("valid", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->valid);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.days_since_epoch) {
    xfer += oprot->writeFieldBegin("days_since_epoch", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->days_since_epoch);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.canonical_date_string) {
    xfer += oprot->writeFieldBegin("canonical_date_string", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->canonical_date_string);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
