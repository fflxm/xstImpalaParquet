/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef parquet_TYPES_H
#define parquet_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace parquet {

struct Type {
  enum type {
    BOOLEAN = 0,
    INT32 = 1,
    INT64 = 2,
    INT96 = 3,
    FLOAT = 4,
    DOUBLE = 5,
    BYTE_ARRAY = 6,
    FIXED_LEN_BYTE_ARRAY = 7,
    UBSAN_FORCE_WIDTH = 134217727
  };
};

extern const std::map<int, const char*> _Type_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Type::type& val);

struct ConvertedType {
  enum type {
    UTF8 = 0,
    MAP = 1,
    MAP_KEY_VALUE = 2,
    LIST = 3,
    ENUM = 4,
    DECIMAL = 5,
    DATE = 6,
    TIME_MILLIS = 7,
    TIME_MICROS = 8,
    TIMESTAMP_MILLIS = 9,
    TIMESTAMP_MICROS = 10,
    UINT_8 = 11,
    UINT_16 = 12,
    UINT_32 = 13,
    UINT_64 = 14,
    INT_8 = 15,
    INT_16 = 16,
    INT_32 = 17,
    INT_64 = 18,
    JSON = 19,
    BSON = 20,
    INTERVAL = 21
  };
};

extern const std::map<int, const char*> _ConvertedType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ConvertedType::type& val);

struct FieldRepetitionType {
  enum type {
    REQUIRED = 0,
    OPTIONAL = 1,
    REPEATED = 2
  };
};

extern const std::map<int, const char*> _FieldRepetitionType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FieldRepetitionType::type& val);

struct Encoding {
  enum type {
    PLAIN = 0,
    PLAIN_DICTIONARY = 2,
    RLE = 3,
    BIT_PACKED = 4,
    DELTA_BINARY_PACKED = 5,
    DELTA_LENGTH_BYTE_ARRAY = 6,
    DELTA_BYTE_ARRAY = 7,
    RLE_DICTIONARY = 8,
    BYTE_STREAM_SPLIT = 9,
    MAX_ENUM_VALUE = 9
  };
};

extern const std::map<int, const char*> _Encoding_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Encoding::type& val);

struct CompressionCodec {
  enum type {
    UNCOMPRESSED = 0,
    SNAPPY = 1,
    GZIP = 2,
    LZO = 3,
    BROTLI = 4,
    LZ4 = 5,
    ZSTD = 6
  };
};

extern const std::map<int, const char*> _CompressionCodec_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CompressionCodec::type& val);

struct PageType {
  enum type {
    DATA_PAGE = 0,
    INDEX_PAGE = 1,
    DICTIONARY_PAGE = 2,
    DATA_PAGE_V2 = 3
  };
};

extern const std::map<int, const char*> _PageType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const PageType::type& val);

struct BoundaryOrder {
  enum type {
    UNORDERED = 0,
    ASCENDING = 1,
    DESCENDING = 2
  };
};

extern const std::map<int, const char*> _BoundaryOrder_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const BoundaryOrder::type& val);

class Statistics;

class StringType;

class UUIDType;

class MapType;

class ListType;

class EnumType;

class DateType;

class NullType;

class DecimalType;

class MilliSeconds;

class MicroSeconds;

class NanoSeconds;

class TimeUnit;

class TimestampType;

class TimeType;

class IntType;

class JsonType;

class BsonType;

class LogicalType;

class SchemaElement;

class DataPageHeader;

class IndexPageHeader;

class DictionaryPageHeader;

class DataPageHeaderV2;

class SplitBlockAlgorithm;

class BloomFilterAlgorithm;

class XxHash;

class BloomFilterHash;

class Uncompressed;

class BloomFilterCompression;

class BloomFilterHeader;

class PageHeader;

class KeyValue;

class SortingColumn;

class PageEncodingStats;

class ColumnMetaData;

class EncryptionWithFooterKey;

class EncryptionWithColumnKey;

class ColumnCryptoMetaData;

class ColumnChunk;

class RowGroup;

class TypeDefinedOrder;

class ColumnOrder;

class PageLocation;

class OffsetIndex;

class ColumnIndex;

class AesGcmV1;

class AesGcmCtrV1;

class EncryptionAlgorithm;

class FileMetaData;

class FileCryptoMetaData;

typedef struct _Statistics__isset {
  _Statistics__isset() : max(false), min(false), null_count(false), distinct_count(false), max_value(false), min_value(false) {}
  bool max :1;
  bool min :1;
  bool null_count :1;
  bool distinct_count :1;
  bool max_value :1;
  bool min_value :1;
} _Statistics__isset;

class Statistics {
 public:

  Statistics(const Statistics&);
  Statistics(Statistics&&);
  Statistics& operator=(const Statistics&);
  Statistics& operator=(Statistics&&);
  Statistics() : max(), min(), null_count(0), distinct_count(0), max_value(), min_value() {
  }

  virtual ~Statistics() throw();
  std::string max;
  std::string min;
  int64_t null_count;
  int64_t distinct_count;
  std::string max_value;
  std::string min_value;

  _Statistics__isset __isset;

  void __set_max(const std::string& val);

  void __set_min(const std::string& val);

  void __set_null_count(const int64_t val);

  void __set_distinct_count(const int64_t val);

  void __set_max_value(const std::string& val);

  void __set_min_value(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Statistics &a, Statistics &b);

std::ostream& operator<<(std::ostream& out, const Statistics& obj);


class StringType {
 public:

  StringType(const StringType&);
  StringType(StringType&&);
  StringType& operator=(const StringType&);
  StringType& operator=(StringType&&);
  StringType() {
  }

  virtual ~StringType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(StringType &a, StringType &b);

std::ostream& operator<<(std::ostream& out, const StringType& obj);


class UUIDType {
 public:

  UUIDType(const UUIDType&);
  UUIDType(UUIDType&&);
  UUIDType& operator=(const UUIDType&);
  UUIDType& operator=(UUIDType&&);
  UUIDType() {
  }

  virtual ~UUIDType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UUIDType &a, UUIDType &b);

std::ostream& operator<<(std::ostream& out, const UUIDType& obj);


class MapType {
 public:

  MapType(const MapType&);
  MapType(MapType&&);
  MapType& operator=(const MapType&);
  MapType& operator=(MapType&&);
  MapType() {
  }

  virtual ~MapType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MapType &a, MapType &b);

std::ostream& operator<<(std::ostream& out, const MapType& obj);


class ListType {
 public:

  ListType(const ListType&);
  ListType(ListType&&);
  ListType& operator=(const ListType&);
  ListType& operator=(ListType&&);
  ListType() {
  }

  virtual ~ListType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListType &a, ListType &b);

std::ostream& operator<<(std::ostream& out, const ListType& obj);


class EnumType {
 public:

  EnumType(const EnumType&);
  EnumType(EnumType&&);
  EnumType& operator=(const EnumType&);
  EnumType& operator=(EnumType&&);
  EnumType() {
  }

  virtual ~EnumType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EnumType &a, EnumType &b);

std::ostream& operator<<(std::ostream& out, const EnumType& obj);


class DateType {
 public:

  DateType(const DateType&);
  DateType(DateType&&);
  DateType& operator=(const DateType&);
  DateType& operator=(DateType&&);
  DateType() {
  }

  virtual ~DateType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DateType &a, DateType &b);

std::ostream& operator<<(std::ostream& out, const DateType& obj);


class NullType {
 public:

  NullType(const NullType&);
  NullType(NullType&&);
  NullType& operator=(const NullType&);
  NullType& operator=(NullType&&);
  NullType() {
  }

  virtual ~NullType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NullType &a, NullType &b);

std::ostream& operator<<(std::ostream& out, const NullType& obj);


class DecimalType {
 public:

  DecimalType(const DecimalType&);
  DecimalType(DecimalType&&);
  DecimalType& operator=(const DecimalType&);
  DecimalType& operator=(DecimalType&&);
  DecimalType() : scale(0), precision(0) {
  }

  virtual ~DecimalType() throw();
  int32_t scale;
  int32_t precision;

  void __set_scale(const int32_t val);

  void __set_precision(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DecimalType &a, DecimalType &b);

std::ostream& operator<<(std::ostream& out, const DecimalType& obj);


class MilliSeconds {
 public:

  MilliSeconds(const MilliSeconds&);
  MilliSeconds(MilliSeconds&&);
  MilliSeconds& operator=(const MilliSeconds&);
  MilliSeconds& operator=(MilliSeconds&&);
  MilliSeconds() {
  }

  virtual ~MilliSeconds() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MilliSeconds &a, MilliSeconds &b);

std::ostream& operator<<(std::ostream& out, const MilliSeconds& obj);


class MicroSeconds {
 public:

  MicroSeconds(const MicroSeconds&);
  MicroSeconds(MicroSeconds&&);
  MicroSeconds& operator=(const MicroSeconds&);
  MicroSeconds& operator=(MicroSeconds&&);
  MicroSeconds() {
  }

  virtual ~MicroSeconds() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MicroSeconds &a, MicroSeconds &b);

std::ostream& operator<<(std::ostream& out, const MicroSeconds& obj);


class NanoSeconds {
 public:

  NanoSeconds(const NanoSeconds&);
  NanoSeconds(NanoSeconds&&);
  NanoSeconds& operator=(const NanoSeconds&);
  NanoSeconds& operator=(NanoSeconds&&);
  NanoSeconds() {
  }

  virtual ~NanoSeconds() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NanoSeconds &a, NanoSeconds &b);

std::ostream& operator<<(std::ostream& out, const NanoSeconds& obj);

typedef struct _TimeUnit__isset {
  _TimeUnit__isset() : MILLIS(false), MICROS(false), NANOS(false) {}
  bool MILLIS :1;
  bool MICROS :1;
  bool NANOS :1;
} _TimeUnit__isset;

class TimeUnit {
 public:

  TimeUnit(const TimeUnit&);
  TimeUnit(TimeUnit&&);
  TimeUnit& operator=(const TimeUnit&);
  TimeUnit& operator=(TimeUnit&&);
  TimeUnit() {
  }

  virtual ~TimeUnit() throw();
  MilliSeconds MILLIS;
  MicroSeconds MICROS;
  NanoSeconds NANOS;

  _TimeUnit__isset __isset;

  void __set_MILLIS(const MilliSeconds& val);

  void __set_MICROS(const MicroSeconds& val);

  void __set_NANOS(const NanoSeconds& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimeUnit &a, TimeUnit &b);

std::ostream& operator<<(std::ostream& out, const TimeUnit& obj);


class TimestampType {
 public:

  TimestampType(const TimestampType&);
  TimestampType(TimestampType&&);
  TimestampType& operator=(const TimestampType&);
  TimestampType& operator=(TimestampType&&);
  TimestampType() : isAdjustedToUTC(0) {
  }

  virtual ~TimestampType() throw();
  bool isAdjustedToUTC;
  TimeUnit unit;

  void __set_isAdjustedToUTC(const bool val);

  void __set_unit(const TimeUnit& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimestampType &a, TimestampType &b);

std::ostream& operator<<(std::ostream& out, const TimestampType& obj);


class TimeType {
 public:

  TimeType(const TimeType&);
  TimeType(TimeType&&);
  TimeType& operator=(const TimeType&);
  TimeType& operator=(TimeType&&);
  TimeType() : isAdjustedToUTC(0) {
  }

  virtual ~TimeType() throw();
  bool isAdjustedToUTC;
  TimeUnit unit;

  void __set_isAdjustedToUTC(const bool val);

  void __set_unit(const TimeUnit& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TimeType &a, TimeType &b);

std::ostream& operator<<(std::ostream& out, const TimeType& obj);


class IntType {
 public:

  IntType(const IntType&);
  IntType(IntType&&);
  IntType& operator=(const IntType&);
  IntType& operator=(IntType&&);
  IntType() : bitWidth(0), isSigned(0) {
  }

  virtual ~IntType() throw();
  int8_t bitWidth;
  bool isSigned;

  void __set_bitWidth(const int8_t val);

  void __set_isSigned(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntType &a, IntType &b);

std::ostream& operator<<(std::ostream& out, const IntType& obj);


class JsonType {
 public:

  JsonType(const JsonType&);
  JsonType(JsonType&&);
  JsonType& operator=(const JsonType&);
  JsonType& operator=(JsonType&&);
  JsonType() {
  }

  virtual ~JsonType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(JsonType &a, JsonType &b);

std::ostream& operator<<(std::ostream& out, const JsonType& obj);


class BsonType {
 public:

  BsonType(const BsonType&);
  BsonType(BsonType&&);
  BsonType& operator=(const BsonType&);
  BsonType& operator=(BsonType&&);
  BsonType() {
  }

  virtual ~BsonType() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BsonType &a, BsonType &b);

std::ostream& operator<<(std::ostream& out, const BsonType& obj);

typedef struct _LogicalType__isset {
  _LogicalType__isset() : STRING(false), MAP(false), LIST(false), ENUM(false), DECIMAL(false), DATE(false), TIME(false), TIMESTAMP(false), INTEGER(false), UNKNOWN(false), JSON(false), BSON(false), UUID(false) {}
  bool STRING :1;
  bool MAP :1;
  bool LIST :1;
  bool ENUM :1;
  bool DECIMAL :1;
  bool DATE :1;
  bool TIME :1;
  bool TIMESTAMP :1;
  bool INTEGER :1;
  bool UNKNOWN :1;
  bool JSON :1;
  bool BSON :1;
  bool UUID :1;
} _LogicalType__isset;

class LogicalType {
 public:

  LogicalType(const LogicalType&);
  LogicalType(LogicalType&&);
  LogicalType& operator=(const LogicalType&);
  LogicalType& operator=(LogicalType&&);
  LogicalType() {
  }

  virtual ~LogicalType() throw();
  StringType STRING;
  MapType MAP;
  ListType LIST;
  EnumType ENUM;
  DecimalType DECIMAL;
  DateType DATE;
  TimeType TIME;
  TimestampType TIMESTAMP;
  IntType INTEGER;
  NullType UNKNOWN;
  JsonType JSON;
  BsonType BSON;
  UUIDType UUID;

  _LogicalType__isset __isset;

  void __set_STRING(const StringType& val);

  void __set_MAP(const MapType& val);

  void __set_LIST(const ListType& val);

  void __set_ENUM(const EnumType& val);

  void __set_DECIMAL(const DecimalType& val);

  void __set_DATE(const DateType& val);

  void __set_TIME(const TimeType& val);

  void __set_TIMESTAMP(const TimestampType& val);

  void __set_INTEGER(const IntType& val);

  void __set_UNKNOWN(const NullType& val);

  void __set_JSON(const JsonType& val);

  void __set_BSON(const BsonType& val);

  void __set_UUID(const UUIDType& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LogicalType &a, LogicalType &b);

std::ostream& operator<<(std::ostream& out, const LogicalType& obj);

typedef struct _SchemaElement__isset {
  _SchemaElement__isset() : type(false), type_length(false), repetition_type(false), num_children(false), converted_type(false), scale(false), precision(false), field_id(false), logicalType(false) {}
  bool type :1;
  bool type_length :1;
  bool repetition_type :1;
  bool num_children :1;
  bool converted_type :1;
  bool scale :1;
  bool precision :1;
  bool field_id :1;
  bool logicalType :1;
} _SchemaElement__isset;

class SchemaElement {
 public:

  SchemaElement(const SchemaElement&);
  SchemaElement(SchemaElement&&);
  SchemaElement& operator=(const SchemaElement&);
  SchemaElement& operator=(SchemaElement&&);
  SchemaElement() : type((Type::type)0), type_length(0), repetition_type((FieldRepetitionType::type)0), name(), num_children(0), converted_type((ConvertedType::type)0), scale(0), precision(0), field_id(0) {
  }

  virtual ~SchemaElement() throw();
  Type::type type;
  int32_t type_length;
  FieldRepetitionType::type repetition_type;
  std::string name;
  int32_t num_children;
  ConvertedType::type converted_type;
  int32_t scale;
  int32_t precision;
  int32_t field_id;
  LogicalType logicalType;

  _SchemaElement__isset __isset;

  void __set_type(const Type::type val);

  void __set_type_length(const int32_t val);

  void __set_repetition_type(const FieldRepetitionType::type val);

  void __set_name(const std::string& val);

  void __set_num_children(const int32_t val);

  void __set_converted_type(const ConvertedType::type val);

  void __set_scale(const int32_t val);

  void __set_precision(const int32_t val);

  void __set_field_id(const int32_t val);

  void __set_logicalType(const LogicalType& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaElement &a, SchemaElement &b);

std::ostream& operator<<(std::ostream& out, const SchemaElement& obj);

typedef struct _DataPageHeader__isset {
  _DataPageHeader__isset() : statistics(false) {}
  bool statistics :1;
} _DataPageHeader__isset;

class DataPageHeader {
 public:

  DataPageHeader(const DataPageHeader&);
  DataPageHeader(DataPageHeader&&);
  DataPageHeader& operator=(const DataPageHeader&);
  DataPageHeader& operator=(DataPageHeader&&);
  DataPageHeader() : num_values(0), encoding((Encoding::type)0), definition_level_encoding((Encoding::type)0), repetition_level_encoding((Encoding::type)0) {
  }

  virtual ~DataPageHeader() throw();
  int32_t num_values;
  Encoding::type encoding;
  Encoding::type definition_level_encoding;
  Encoding::type repetition_level_encoding;
  Statistics statistics;

  _DataPageHeader__isset __isset;

  void __set_num_values(const int32_t val);

  void __set_encoding(const Encoding::type val);

  void __set_definition_level_encoding(const Encoding::type val);

  void __set_repetition_level_encoding(const Encoding::type val);

  void __set_statistics(const Statistics& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataPageHeader &a, DataPageHeader &b);

std::ostream& operator<<(std::ostream& out, const DataPageHeader& obj);


class IndexPageHeader {
 public:

  IndexPageHeader(const IndexPageHeader&);
  IndexPageHeader(IndexPageHeader&&);
  IndexPageHeader& operator=(const IndexPageHeader&);
  IndexPageHeader& operator=(IndexPageHeader&&);
  IndexPageHeader() {
  }

  virtual ~IndexPageHeader() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IndexPageHeader &a, IndexPageHeader &b);

std::ostream& operator<<(std::ostream& out, const IndexPageHeader& obj);

typedef struct _DictionaryPageHeader__isset {
  _DictionaryPageHeader__isset() : is_sorted(false) {}
  bool is_sorted :1;
} _DictionaryPageHeader__isset;

class DictionaryPageHeader {
 public:

  DictionaryPageHeader(const DictionaryPageHeader&);
  DictionaryPageHeader(DictionaryPageHeader&&);
  DictionaryPageHeader& operator=(const DictionaryPageHeader&);
  DictionaryPageHeader& operator=(DictionaryPageHeader&&);
  DictionaryPageHeader() : num_values(0), encoding((Encoding::type)0), is_sorted(0) {
  }

  virtual ~DictionaryPageHeader() throw();
  int32_t num_values;
  Encoding::type encoding;
  bool is_sorted;

  _DictionaryPageHeader__isset __isset;

  void __set_num_values(const int32_t val);

  void __set_encoding(const Encoding::type val);

  void __set_is_sorted(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DictionaryPageHeader &a, DictionaryPageHeader &b);

std::ostream& operator<<(std::ostream& out, const DictionaryPageHeader& obj);

typedef struct _DataPageHeaderV2__isset {
  _DataPageHeaderV2__isset() : is_compressed(true), statistics(false) {}
  bool is_compressed :1;
  bool statistics :1;
} _DataPageHeaderV2__isset;

class DataPageHeaderV2 {
 public:

  DataPageHeaderV2(const DataPageHeaderV2&);
  DataPageHeaderV2(DataPageHeaderV2&&);
  DataPageHeaderV2& operator=(const DataPageHeaderV2&);
  DataPageHeaderV2& operator=(DataPageHeaderV2&&);
  DataPageHeaderV2() : num_values(0), num_nulls(0), num_rows(0), encoding((Encoding::type)0), definition_levels_byte_length(0), repetition_levels_byte_length(0), is_compressed(true) {
  }

  virtual ~DataPageHeaderV2() throw();
  int32_t num_values;
  int32_t num_nulls;
  int32_t num_rows;
  Encoding::type encoding;
  int32_t definition_levels_byte_length;
  int32_t repetition_levels_byte_length;
  bool is_compressed;
  Statistics statistics;

  _DataPageHeaderV2__isset __isset;

  void __set_num_values(const int32_t val);

  void __set_num_nulls(const int32_t val);

  void __set_num_rows(const int32_t val);

  void __set_encoding(const Encoding::type val);

  void __set_definition_levels_byte_length(const int32_t val);

  void __set_repetition_levels_byte_length(const int32_t val);

  void __set_is_compressed(const bool val);

  void __set_statistics(const Statistics& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DataPageHeaderV2 &a, DataPageHeaderV2 &b);

std::ostream& operator<<(std::ostream& out, const DataPageHeaderV2& obj);


class SplitBlockAlgorithm {
 public:

  SplitBlockAlgorithm(const SplitBlockAlgorithm&);
  SplitBlockAlgorithm(SplitBlockAlgorithm&&);
  SplitBlockAlgorithm& operator=(const SplitBlockAlgorithm&);
  SplitBlockAlgorithm& operator=(SplitBlockAlgorithm&&);
  SplitBlockAlgorithm() {
  }

  virtual ~SplitBlockAlgorithm() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SplitBlockAlgorithm &a, SplitBlockAlgorithm &b);

std::ostream& operator<<(std::ostream& out, const SplitBlockAlgorithm& obj);

typedef struct _BloomFilterAlgorithm__isset {
  _BloomFilterAlgorithm__isset() : BLOCK(false) {}
  bool BLOCK :1;
} _BloomFilterAlgorithm__isset;

class BloomFilterAlgorithm {
 public:

  BloomFilterAlgorithm(const BloomFilterAlgorithm&);
  BloomFilterAlgorithm(BloomFilterAlgorithm&&);
  BloomFilterAlgorithm& operator=(const BloomFilterAlgorithm&);
  BloomFilterAlgorithm& operator=(BloomFilterAlgorithm&&);
  BloomFilterAlgorithm() {
  }

  virtual ~BloomFilterAlgorithm() throw();
  SplitBlockAlgorithm BLOCK;

  _BloomFilterAlgorithm__isset __isset;

  void __set_BLOCK(const SplitBlockAlgorithm& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BloomFilterAlgorithm &a, BloomFilterAlgorithm &b);

std::ostream& operator<<(std::ostream& out, const BloomFilterAlgorithm& obj);


class XxHash {
 public:

  XxHash(const XxHash&);
  XxHash(XxHash&&);
  XxHash& operator=(const XxHash&);
  XxHash& operator=(XxHash&&);
  XxHash() {
  }

  virtual ~XxHash() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(XxHash &a, XxHash &b);

std::ostream& operator<<(std::ostream& out, const XxHash& obj);

typedef struct _BloomFilterHash__isset {
  _BloomFilterHash__isset() : XXHASH(false) {}
  bool XXHASH :1;
} _BloomFilterHash__isset;

class BloomFilterHash {
 public:

  BloomFilterHash(const BloomFilterHash&);
  BloomFilterHash(BloomFilterHash&&);
  BloomFilterHash& operator=(const BloomFilterHash&);
  BloomFilterHash& operator=(BloomFilterHash&&);
  BloomFilterHash() {
  }

  virtual ~BloomFilterHash() throw();
  XxHash XXHASH;

  _BloomFilterHash__isset __isset;

  void __set_XXHASH(const XxHash& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BloomFilterHash &a, BloomFilterHash &b);

std::ostream& operator<<(std::ostream& out, const BloomFilterHash& obj);


class Uncompressed {
 public:

  Uncompressed(const Uncompressed&);
  Uncompressed(Uncompressed&&);
  Uncompressed& operator=(const Uncompressed&);
  Uncompressed& operator=(Uncompressed&&);
  Uncompressed() {
  }

  virtual ~Uncompressed() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Uncompressed &a, Uncompressed &b);

std::ostream& operator<<(std::ostream& out, const Uncompressed& obj);

typedef struct _BloomFilterCompression__isset {
  _BloomFilterCompression__isset() : UNCOMPRESSED(false) {}
  bool UNCOMPRESSED :1;
} _BloomFilterCompression__isset;

class BloomFilterCompression {
 public:

  BloomFilterCompression(const BloomFilterCompression&);
  BloomFilterCompression(BloomFilterCompression&&);
  BloomFilterCompression& operator=(const BloomFilterCompression&);
  BloomFilterCompression& operator=(BloomFilterCompression&&);
  BloomFilterCompression() {
  }

  virtual ~BloomFilterCompression() throw();
  Uncompressed UNCOMPRESSED;

  _BloomFilterCompression__isset __isset;

  void __set_UNCOMPRESSED(const Uncompressed& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BloomFilterCompression &a, BloomFilterCompression &b);

std::ostream& operator<<(std::ostream& out, const BloomFilterCompression& obj);


class BloomFilterHeader {
 public:

  BloomFilterHeader(const BloomFilterHeader&);
  BloomFilterHeader(BloomFilterHeader&&);
  BloomFilterHeader& operator=(const BloomFilterHeader&);
  BloomFilterHeader& operator=(BloomFilterHeader&&);
  BloomFilterHeader() : numBytes(0) {
  }

  virtual ~BloomFilterHeader() throw();
  int32_t numBytes;
  BloomFilterAlgorithm algorithm;
  BloomFilterHash hash;
  BloomFilterCompression compression;

  void __set_numBytes(const int32_t val);

  void __set_algorithm(const BloomFilterAlgorithm& val);

  void __set_hash(const BloomFilterHash& val);

  void __set_compression(const BloomFilterCompression& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BloomFilterHeader &a, BloomFilterHeader &b);

std::ostream& operator<<(std::ostream& out, const BloomFilterHeader& obj);

typedef struct _PageHeader__isset {
  _PageHeader__isset() : crc(false), data_page_header(false), index_page_header(false), dictionary_page_header(false), data_page_header_v2(false) {}
  bool crc :1;
  bool data_page_header :1;
  bool index_page_header :1;
  bool dictionary_page_header :1;
  bool data_page_header_v2 :1;
} _PageHeader__isset;

class PageHeader {
 public:

  PageHeader(const PageHeader&);
  PageHeader(PageHeader&&);
  PageHeader& operator=(const PageHeader&);
  PageHeader& operator=(PageHeader&&);
  PageHeader() : type((PageType::type)0), uncompressed_page_size(0), compressed_page_size(0), crc(0) {
  }

  virtual ~PageHeader() throw();
  PageType::type type;
  int32_t uncompressed_page_size;
  int32_t compressed_page_size;
  int32_t crc;
  DataPageHeader data_page_header;
  IndexPageHeader index_page_header;
  DictionaryPageHeader dictionary_page_header;
  DataPageHeaderV2 data_page_header_v2;

  _PageHeader__isset __isset;

  void __set_type(const PageType::type val);

  void __set_uncompressed_page_size(const int32_t val);

  void __set_compressed_page_size(const int32_t val);

  void __set_crc(const int32_t val);

  void __set_data_page_header(const DataPageHeader& val);

  void __set_index_page_header(const IndexPageHeader& val);

  void __set_dictionary_page_header(const DictionaryPageHeader& val);

  void __set_data_page_header_v2(const DataPageHeaderV2& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PageHeader &a, PageHeader &b);

std::ostream& operator<<(std::ostream& out, const PageHeader& obj);

typedef struct _KeyValue__isset {
  _KeyValue__isset() : value(false) {}
  bool value :1;
} _KeyValue__isset;

class KeyValue {
 public:

  KeyValue(const KeyValue&);
  KeyValue(KeyValue&&);
  KeyValue& operator=(const KeyValue&);
  KeyValue& operator=(KeyValue&&);
  KeyValue() : key(), value() {
  }

  virtual ~KeyValue() throw();
  std::string key;
  std::string value;

  _KeyValue__isset __isset;

  void __set_key(const std::string& val);

  void __set_value(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(KeyValue &a, KeyValue &b);

std::ostream& operator<<(std::ostream& out, const KeyValue& obj);


class SortingColumn {
 public:

  SortingColumn(const SortingColumn&);
  SortingColumn(SortingColumn&&);
  SortingColumn& operator=(const SortingColumn&);
  SortingColumn& operator=(SortingColumn&&);
  SortingColumn() : column_idx(0), descending(0), nulls_first(0) {
  }

  virtual ~SortingColumn() throw();
  int32_t column_idx;
  bool descending;
  bool nulls_first;

  void __set_column_idx(const int32_t val);

  void __set_descending(const bool val);

  void __set_nulls_first(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SortingColumn &a, SortingColumn &b);

std::ostream& operator<<(std::ostream& out, const SortingColumn& obj);


class PageEncodingStats {
 public:

  PageEncodingStats(const PageEncodingStats&);
  PageEncodingStats(PageEncodingStats&&);
  PageEncodingStats& operator=(const PageEncodingStats&);
  PageEncodingStats& operator=(PageEncodingStats&&);
  PageEncodingStats() : page_type((PageType::type)0), encoding((Encoding::type)0), count(0) {
  }

  virtual ~PageEncodingStats() throw();
  PageType::type page_type;
  Encoding::type encoding;
  int32_t count;

  void __set_page_type(const PageType::type val);

  void __set_encoding(const Encoding::type val);

  void __set_count(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PageEncodingStats &a, PageEncodingStats &b);

std::ostream& operator<<(std::ostream& out, const PageEncodingStats& obj);

typedef struct _ColumnMetaData__isset {
  _ColumnMetaData__isset() : key_value_metadata(false), index_page_offset(false), dictionary_page_offset(false), statistics(false), encoding_stats(false), bloom_filter_offset(false) {}
  bool key_value_metadata :1;
  bool index_page_offset :1;
  bool dictionary_page_offset :1;
  bool statistics :1;
  bool encoding_stats :1;
  bool bloom_filter_offset :1;
} _ColumnMetaData__isset;

class ColumnMetaData {
 public:

  ColumnMetaData(const ColumnMetaData&);
  ColumnMetaData(ColumnMetaData&&);
  ColumnMetaData& operator=(const ColumnMetaData&);
  ColumnMetaData& operator=(ColumnMetaData&&);
  ColumnMetaData() : type((Type::type)0), codec((CompressionCodec::type)0), num_values(0), total_uncompressed_size(0), total_compressed_size(0), data_page_offset(0), index_page_offset(0), dictionary_page_offset(0), bloom_filter_offset(0) {
  }

  virtual ~ColumnMetaData() throw();
  Type::type type;
  std::vector<Encoding::type>  encodings;
  std::vector<std::string>  path_in_schema;
  CompressionCodec::type codec;
  int64_t num_values;
  int64_t total_uncompressed_size;
  int64_t total_compressed_size;
  std::vector<KeyValue>  key_value_metadata;
  int64_t data_page_offset;
  int64_t index_page_offset;
  int64_t dictionary_page_offset;
  Statistics statistics;
  std::vector<PageEncodingStats>  encoding_stats;
  int64_t bloom_filter_offset;

  _ColumnMetaData__isset __isset;

  void __set_type(const Type::type val);

  void __set_encodings(const std::vector<Encoding::type> & val);

  void __set_path_in_schema(const std::vector<std::string> & val);

  void __set_codec(const CompressionCodec::type val);

  void __set_num_values(const int64_t val);

  void __set_total_uncompressed_size(const int64_t val);

  void __set_total_compressed_size(const int64_t val);

  void __set_key_value_metadata(const std::vector<KeyValue> & val);

  void __set_data_page_offset(const int64_t val);

  void __set_index_page_offset(const int64_t val);

  void __set_dictionary_page_offset(const int64_t val);

  void __set_statistics(const Statistics& val);

  void __set_encoding_stats(const std::vector<PageEncodingStats> & val);

  void __set_bloom_filter_offset(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnMetaData &a, ColumnMetaData &b);

std::ostream& operator<<(std::ostream& out, const ColumnMetaData& obj);


class EncryptionWithFooterKey {
 public:

  EncryptionWithFooterKey(const EncryptionWithFooterKey&);
  EncryptionWithFooterKey(EncryptionWithFooterKey&&);
  EncryptionWithFooterKey& operator=(const EncryptionWithFooterKey&);
  EncryptionWithFooterKey& operator=(EncryptionWithFooterKey&&);
  EncryptionWithFooterKey() {
  }

  virtual ~EncryptionWithFooterKey() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EncryptionWithFooterKey &a, EncryptionWithFooterKey &b);

std::ostream& operator<<(std::ostream& out, const EncryptionWithFooterKey& obj);

typedef struct _EncryptionWithColumnKey__isset {
  _EncryptionWithColumnKey__isset() : key_metadata(false) {}
  bool key_metadata :1;
} _EncryptionWithColumnKey__isset;

class EncryptionWithColumnKey {
 public:

  EncryptionWithColumnKey(const EncryptionWithColumnKey&);
  EncryptionWithColumnKey(EncryptionWithColumnKey&&);
  EncryptionWithColumnKey& operator=(const EncryptionWithColumnKey&);
  EncryptionWithColumnKey& operator=(EncryptionWithColumnKey&&);
  EncryptionWithColumnKey() : key_metadata() {
  }

  virtual ~EncryptionWithColumnKey() throw();
  std::vector<std::string>  path_in_schema;
  std::string key_metadata;

  _EncryptionWithColumnKey__isset __isset;

  void __set_path_in_schema(const std::vector<std::string> & val);

  void __set_key_metadata(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EncryptionWithColumnKey &a, EncryptionWithColumnKey &b);

std::ostream& operator<<(std::ostream& out, const EncryptionWithColumnKey& obj);

typedef struct _ColumnCryptoMetaData__isset {
  _ColumnCryptoMetaData__isset() : ENCRYPTION_WITH_FOOTER_KEY(false), ENCRYPTION_WITH_COLUMN_KEY(false) {}
  bool ENCRYPTION_WITH_FOOTER_KEY :1;
  bool ENCRYPTION_WITH_COLUMN_KEY :1;
} _ColumnCryptoMetaData__isset;

class ColumnCryptoMetaData {
 public:

  ColumnCryptoMetaData(const ColumnCryptoMetaData&);
  ColumnCryptoMetaData(ColumnCryptoMetaData&&);
  ColumnCryptoMetaData& operator=(const ColumnCryptoMetaData&);
  ColumnCryptoMetaData& operator=(ColumnCryptoMetaData&&);
  ColumnCryptoMetaData() {
  }

  virtual ~ColumnCryptoMetaData() throw();
  EncryptionWithFooterKey ENCRYPTION_WITH_FOOTER_KEY;
  EncryptionWithColumnKey ENCRYPTION_WITH_COLUMN_KEY;

  _ColumnCryptoMetaData__isset __isset;

  void __set_ENCRYPTION_WITH_FOOTER_KEY(const EncryptionWithFooterKey& val);

  void __set_ENCRYPTION_WITH_COLUMN_KEY(const EncryptionWithColumnKey& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnCryptoMetaData &a, ColumnCryptoMetaData &b);

std::ostream& operator<<(std::ostream& out, const ColumnCryptoMetaData& obj);

typedef struct _ColumnChunk__isset {
  _ColumnChunk__isset() : file_path(false), meta_data(false), offset_index_offset(false), offset_index_length(false), column_index_offset(false), column_index_length(false), crypto_metadata(false), encrypted_column_metadata(false) {}
  bool file_path :1;
  bool meta_data :1;
  bool offset_index_offset :1;
  bool offset_index_length :1;
  bool column_index_offset :1;
  bool column_index_length :1;
  bool crypto_metadata :1;
  bool encrypted_column_metadata :1;
} _ColumnChunk__isset;

class ColumnChunk {
 public:

  ColumnChunk(const ColumnChunk&);
  ColumnChunk(ColumnChunk&&);
  ColumnChunk& operator=(const ColumnChunk&);
  ColumnChunk& operator=(ColumnChunk&&);
  ColumnChunk() : file_path(), file_offset(0), offset_index_offset(0), offset_index_length(0), column_index_offset(0), column_index_length(0), encrypted_column_metadata() {
  }

  virtual ~ColumnChunk() throw();
  std::string file_path;
  int64_t file_offset;
  ColumnMetaData meta_data;
  int64_t offset_index_offset;
  int32_t offset_index_length;
  int64_t column_index_offset;
  int32_t column_index_length;
  ColumnCryptoMetaData crypto_metadata;
  std::string encrypted_column_metadata;

  _ColumnChunk__isset __isset;

  void __set_file_path(const std::string& val);

  void __set_file_offset(const int64_t val);

  void __set_meta_data(const ColumnMetaData& val);

  void __set_offset_index_offset(const int64_t val);

  void __set_offset_index_length(const int32_t val);

  void __set_column_index_offset(const int64_t val);

  void __set_column_index_length(const int32_t val);

  void __set_crypto_metadata(const ColumnCryptoMetaData& val);

  void __set_encrypted_column_metadata(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnChunk &a, ColumnChunk &b);

std::ostream& operator<<(std::ostream& out, const ColumnChunk& obj);

typedef struct _RowGroup__isset {
  _RowGroup__isset() : sorting_columns(false), file_offset(false), total_compressed_size(false), ordinal(false) {}
  bool sorting_columns :1;
  bool file_offset :1;
  bool total_compressed_size :1;
  bool ordinal :1;
} _RowGroup__isset;

class RowGroup {
 public:

  RowGroup(const RowGroup&);
  RowGroup(RowGroup&&);
  RowGroup& operator=(const RowGroup&);
  RowGroup& operator=(RowGroup&&);
  RowGroup() : total_byte_size(0), num_rows(0), file_offset(0), total_compressed_size(0), ordinal(0) {
  }

  virtual ~RowGroup() throw();
  std::vector<ColumnChunk>  columns;
  int64_t total_byte_size;
  int64_t num_rows;
  std::vector<SortingColumn>  sorting_columns;
  int64_t file_offset;
  int64_t total_compressed_size;
  int16_t ordinal;

  _RowGroup__isset __isset;

  void __set_columns(const std::vector<ColumnChunk> & val);

  void __set_total_byte_size(const int64_t val);

  void __set_num_rows(const int64_t val);

  void __set_sorting_columns(const std::vector<SortingColumn> & val);

  void __set_file_offset(const int64_t val);

  void __set_total_compressed_size(const int64_t val);

  void __set_ordinal(const int16_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RowGroup &a, RowGroup &b);

std::ostream& operator<<(std::ostream& out, const RowGroup& obj);


class TypeDefinedOrder {
 public:

  TypeDefinedOrder(const TypeDefinedOrder&);
  TypeDefinedOrder(TypeDefinedOrder&&);
  TypeDefinedOrder& operator=(const TypeDefinedOrder&);
  TypeDefinedOrder& operator=(TypeDefinedOrder&&);
  TypeDefinedOrder() {
  }

  virtual ~TypeDefinedOrder() throw();

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TypeDefinedOrder &a, TypeDefinedOrder &b);

std::ostream& operator<<(std::ostream& out, const TypeDefinedOrder& obj);

typedef struct _ColumnOrder__isset {
  _ColumnOrder__isset() : TYPE_ORDER(false) {}
  bool TYPE_ORDER :1;
} _ColumnOrder__isset;

class ColumnOrder {
 public:

  ColumnOrder(const ColumnOrder&);
  ColumnOrder(ColumnOrder&&);
  ColumnOrder& operator=(const ColumnOrder&);
  ColumnOrder& operator=(ColumnOrder&&);
  ColumnOrder() {
  }

  virtual ~ColumnOrder() throw();
  TypeDefinedOrder TYPE_ORDER;

  _ColumnOrder__isset __isset;

  void __set_TYPE_ORDER(const TypeDefinedOrder& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnOrder &a, ColumnOrder &b);

std::ostream& operator<<(std::ostream& out, const ColumnOrder& obj);


class PageLocation {
 public:

  PageLocation(const PageLocation&);
  PageLocation(PageLocation&&);
  PageLocation& operator=(const PageLocation&);
  PageLocation& operator=(PageLocation&&);
  PageLocation() : offset(0), compressed_page_size(0), first_row_index(0) {
  }

  virtual ~PageLocation() throw();
  int64_t offset;
  int32_t compressed_page_size;
  int64_t first_row_index;

  void __set_offset(const int64_t val);

  void __set_compressed_page_size(const int32_t val);

  void __set_first_row_index(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PageLocation &a, PageLocation &b);

std::ostream& operator<<(std::ostream& out, const PageLocation& obj);


class OffsetIndex {
 public:

  OffsetIndex(const OffsetIndex&);
  OffsetIndex(OffsetIndex&&);
  OffsetIndex& operator=(const OffsetIndex&);
  OffsetIndex& operator=(OffsetIndex&&);
  OffsetIndex() {
  }

  virtual ~OffsetIndex() throw();
  std::vector<PageLocation>  page_locations;

  void __set_page_locations(const std::vector<PageLocation> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OffsetIndex &a, OffsetIndex &b);

std::ostream& operator<<(std::ostream& out, const OffsetIndex& obj);

typedef struct _ColumnIndex__isset {
  _ColumnIndex__isset() : null_counts(false) {}
  bool null_counts :1;
} _ColumnIndex__isset;

class ColumnIndex {
 public:

  ColumnIndex(const ColumnIndex&);
  ColumnIndex(ColumnIndex&&);
  ColumnIndex& operator=(const ColumnIndex&);
  ColumnIndex& operator=(ColumnIndex&&);
  ColumnIndex() : boundary_order((BoundaryOrder::type)0) {
  }

  virtual ~ColumnIndex() throw();
  std::vector<bool>  null_pages;
  std::vector<std::string>  min_values;
  std::vector<std::string>  max_values;
  BoundaryOrder::type boundary_order;
  std::vector<int64_t>  null_counts;

  _ColumnIndex__isset __isset;

  void __set_null_pages(const std::vector<bool> & val);

  void __set_min_values(const std::vector<std::string> & val);

  void __set_max_values(const std::vector<std::string> & val);

  void __set_boundary_order(const BoundaryOrder::type val);

  void __set_null_counts(const std::vector<int64_t> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ColumnIndex &a, ColumnIndex &b);

std::ostream& operator<<(std::ostream& out, const ColumnIndex& obj);

typedef struct _AesGcmV1__isset {
  _AesGcmV1__isset() : aad_prefix(false), aad_file_unique(false), supply_aad_prefix(false) {}
  bool aad_prefix :1;
  bool aad_file_unique :1;
  bool supply_aad_prefix :1;
} _AesGcmV1__isset;

class AesGcmV1 {
 public:

  AesGcmV1(const AesGcmV1&);
  AesGcmV1(AesGcmV1&&);
  AesGcmV1& operator=(const AesGcmV1&);
  AesGcmV1& operator=(AesGcmV1&&);
  AesGcmV1() : aad_prefix(), aad_file_unique(), supply_aad_prefix(0) {
  }

  virtual ~AesGcmV1() throw();
  std::string aad_prefix;
  std::string aad_file_unique;
  bool supply_aad_prefix;

  _AesGcmV1__isset __isset;

  void __set_aad_prefix(const std::string& val);

  void __set_aad_file_unique(const std::string& val);

  void __set_supply_aad_prefix(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AesGcmV1 &a, AesGcmV1 &b);

std::ostream& operator<<(std::ostream& out, const AesGcmV1& obj);

typedef struct _AesGcmCtrV1__isset {
  _AesGcmCtrV1__isset() : aad_prefix(false), aad_file_unique(false), supply_aad_prefix(false) {}
  bool aad_prefix :1;
  bool aad_file_unique :1;
  bool supply_aad_prefix :1;
} _AesGcmCtrV1__isset;

class AesGcmCtrV1 {
 public:

  AesGcmCtrV1(const AesGcmCtrV1&);
  AesGcmCtrV1(AesGcmCtrV1&&);
  AesGcmCtrV1& operator=(const AesGcmCtrV1&);
  AesGcmCtrV1& operator=(AesGcmCtrV1&&);
  AesGcmCtrV1() : aad_prefix(), aad_file_unique(), supply_aad_prefix(0) {
  }

  virtual ~AesGcmCtrV1() throw();
  std::string aad_prefix;
  std::string aad_file_unique;
  bool supply_aad_prefix;

  _AesGcmCtrV1__isset __isset;

  void __set_aad_prefix(const std::string& val);

  void __set_aad_file_unique(const std::string& val);

  void __set_supply_aad_prefix(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AesGcmCtrV1 &a, AesGcmCtrV1 &b);

std::ostream& operator<<(std::ostream& out, const AesGcmCtrV1& obj);

typedef struct _EncryptionAlgorithm__isset {
  _EncryptionAlgorithm__isset() : AES_GCM_V1(false), AES_GCM_CTR_V1(false) {}
  bool AES_GCM_V1 :1;
  bool AES_GCM_CTR_V1 :1;
} _EncryptionAlgorithm__isset;

class EncryptionAlgorithm {
 public:

  EncryptionAlgorithm(const EncryptionAlgorithm&);
  EncryptionAlgorithm(EncryptionAlgorithm&&);
  EncryptionAlgorithm& operator=(const EncryptionAlgorithm&);
  EncryptionAlgorithm& operator=(EncryptionAlgorithm&&);
  EncryptionAlgorithm() {
  }

  virtual ~EncryptionAlgorithm() throw();
  AesGcmV1 AES_GCM_V1;
  AesGcmCtrV1 AES_GCM_CTR_V1;

  _EncryptionAlgorithm__isset __isset;

  void __set_AES_GCM_V1(const AesGcmV1& val);

  void __set_AES_GCM_CTR_V1(const AesGcmCtrV1& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EncryptionAlgorithm &a, EncryptionAlgorithm &b);

std::ostream& operator<<(std::ostream& out, const EncryptionAlgorithm& obj);

typedef struct _FileMetaData__isset {
  _FileMetaData__isset() : key_value_metadata(false), created_by(false), column_orders(false), encryption_algorithm(false), footer_signing_key_metadata(false) {}
  bool key_value_metadata :1;
  bool created_by :1;
  bool column_orders :1;
  bool encryption_algorithm :1;
  bool footer_signing_key_metadata :1;
} _FileMetaData__isset;

class FileMetaData {
 public:

  FileMetaData(const FileMetaData&);
  FileMetaData(FileMetaData&&);
  FileMetaData& operator=(const FileMetaData&);
  FileMetaData& operator=(FileMetaData&&);
  FileMetaData() : version(0), num_rows(0), created_by(), footer_signing_key_metadata() {
  }

  virtual ~FileMetaData() throw();
  int32_t version;
  std::vector<SchemaElement>  schema;
  int64_t num_rows;
  std::vector<RowGroup>  row_groups;
  std::vector<KeyValue>  key_value_metadata;
  std::string created_by;
  std::vector<ColumnOrder>  column_orders;
  EncryptionAlgorithm encryption_algorithm;
  std::string footer_signing_key_metadata;

  _FileMetaData__isset __isset;

  void __set_version(const int32_t val);

  void __set_schema(const std::vector<SchemaElement> & val);

  void __set_num_rows(const int64_t val);

  void __set_row_groups(const std::vector<RowGroup> & val);

  void __set_key_value_metadata(const std::vector<KeyValue> & val);

  void __set_created_by(const std::string& val);

  void __set_column_orders(const std::vector<ColumnOrder> & val);

  void __set_encryption_algorithm(const EncryptionAlgorithm& val);

  void __set_footer_signing_key_metadata(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FileMetaData &a, FileMetaData &b);

std::ostream& operator<<(std::ostream& out, const FileMetaData& obj);

typedef struct _FileCryptoMetaData__isset {
  _FileCryptoMetaData__isset() : key_metadata(false) {}
  bool key_metadata :1;
} _FileCryptoMetaData__isset;

class FileCryptoMetaData {
 public:

  FileCryptoMetaData(const FileCryptoMetaData&);
  FileCryptoMetaData(FileCryptoMetaData&&);
  FileCryptoMetaData& operator=(const FileCryptoMetaData&);
  FileCryptoMetaData& operator=(FileCryptoMetaData&&);
  FileCryptoMetaData() : key_metadata() {
  }

  virtual ~FileCryptoMetaData() throw();
  EncryptionAlgorithm encryption_algorithm;
  std::string key_metadata;

  _FileCryptoMetaData__isset __isset;

  void __set_encryption_algorithm(const EncryptionAlgorithm& val);

  void __set_key_metadata(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FileCryptoMetaData &a, FileCryptoMetaData &b);

std::ostream& operator<<(std::ostream& out, const FileCryptoMetaData& obj);

} // namespace

#include "parquet_types.tcc"

#endif
