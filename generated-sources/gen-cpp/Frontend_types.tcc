/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Frontend_TYPES_TCC
#define Frontend_TYPES_TCC

#include "Types_types.tcc"
#include "RuntimeProfile_types.tcc"
#include "Descriptors_types.tcc"
#include "Data_types.tcc"
#include "Results_types.tcc"
#include "TCLIService_types.tcc"
#include "Status_types.tcc"
#include "CatalogObjects_types.tcc"
#include "CatalogService_types.tcc"
#include "LineageGraph_types.tcc"
#include "Query_types.tcc"
#include "Frontend_types.h"

namespace impala {

template <class Protocol_>
uint32_t THiveUdfExecutorCtorParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fn = false;
  bool isset_local_location = false;
  bool isset_input_byte_offsets = false;
  bool isset_input_nulls_ptr = false;
  bool isset_input_buffer_ptr = false;
  bool isset_output_null_ptr = false;
  bool isset_output_buffer_ptr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          isset_fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->local_location);
          isset_local_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->input_byte_offsets.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->input_byte_offsets.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->input_byte_offsets[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_input_byte_offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->input_nulls_ptr);
          isset_input_nulls_ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->input_buffer_ptr);
          isset_input_buffer_ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->output_null_ptr);
          isset_output_null_ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->output_buffer_ptr);
          isset_output_buffer_ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fn)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_local_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_input_byte_offsets)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_input_nulls_ptr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_input_buffer_ptr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_null_ptr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_buffer_ptr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THiveUdfExecutorCtorParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THiveUdfExecutorCtorParams");

  xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->fn.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("local_location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->local_location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_byte_offsets", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->input_byte_offsets.size()));
    std::vector<int32_t> ::const_iterator _iter5;
    for (_iter5 = this->input_byte_offsets.begin(); _iter5 != this->input_byte_offsets.end(); ++_iter5)
    {
      xfer += oprot->writeI32((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_nulls_ptr", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->input_nulls_ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_buffer_ptr", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->input_buffer_ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_null_ptr", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->output_null_ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_buffer_ptr", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->output_buffer_ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetTablesParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->session.read(iprot);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetTablesParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTablesParams");

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pattern) {
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->session.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetTablesResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->tables.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += iprot->readString(this->tables[_i18]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetTablesResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTablesResult");

  xfer += oprot->writeFieldBegin("tables", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tables.size()));
    std::vector<std::string> ::const_iterator _iter19;
    for (_iter19 = this->tables.begin(); _iter19 != this->tables.end(); ++_iter19)
    {
      xfer += oprot->writeString((*_iter19));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableMetricsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableMetricsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTableMetricsParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableMetricsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metrics = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metrics);
          isset_metrics = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metrics)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableMetricsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTableMetricsResponse");

  xfer += oprot->writeFieldBegin("metrics", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->metrics);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogMetricsResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_dbs = false;
  bool isset_num_tables = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_dbs);
          isset_num_dbs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_tables);
          isset_num_tables = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_eviction_count);
          this->__isset.cache_eviction_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_hit_count);
          this->__isset.cache_hit_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_load_count);
          this->__isset.cache_load_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_load_exception_count);
          this->__isset.cache_load_exception_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_load_success_count);
          this->__isset.cache_load_success_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_miss_count);
          this->__isset.cache_miss_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_request_count);
          this->__isset.cache_request_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cache_total_load_time);
          this->__isset.cache_total_load_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cache_avg_load_time);
          this->__isset.cache_avg_load_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cache_hit_rate);
          this->__isset.cache_hit_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cache_load_exception_rate);
          this->__isset.cache_load_exception_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cache_miss_rate);
          this->__isset.cache_miss_rate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_dbs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_tables)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetCatalogMetricsResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetCatalogMetricsResult");

  xfer += oprot->writeFieldBegin("num_dbs", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->num_dbs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_tables", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_tables);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cache_eviction_count) {
    xfer += oprot->writeFieldBegin("cache_eviction_count", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->cache_eviction_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_hit_count) {
    xfer += oprot->writeFieldBegin("cache_hit_count", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->cache_hit_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_load_count) {
    xfer += oprot->writeFieldBegin("cache_load_count", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->cache_load_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_load_exception_count) {
    xfer += oprot->writeFieldBegin("cache_load_exception_count", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->cache_load_exception_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_load_success_count) {
    xfer += oprot->writeFieldBegin("cache_load_success_count", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->cache_load_success_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_miss_count) {
    xfer += oprot->writeFieldBegin("cache_miss_count", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->cache_miss_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_request_count) {
    xfer += oprot->writeFieldBegin("cache_request_count", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->cache_request_count);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_total_load_time) {
    xfer += oprot->writeFieldBegin("cache_total_load_time", ::apache::thrift::protocol::T_I64, 10);
    xfer += oprot->writeI64(this->cache_total_load_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_avg_load_time) {
    xfer += oprot->writeFieldBegin("cache_avg_load_time", ::apache::thrift::protocol::T_DOUBLE, 11);
    xfer += oprot->writeDouble(this->cache_avg_load_time);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_hit_rate) {
    xfer += oprot->writeFieldBegin("cache_hit_rate", ::apache::thrift::protocol::T_DOUBLE, 12);
    xfer += oprot->writeDouble(this->cache_hit_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_load_exception_rate) {
    xfer += oprot->writeFieldBegin("cache_load_exception_rate", ::apache::thrift::protocol::T_DOUBLE, 13);
    xfer += oprot->writeDouble(this->cache_load_exception_rate);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_miss_rate) {
    xfer += oprot->writeFieldBegin("cache_miss_rate", ::apache::thrift::protocol::T_DOUBLE, 14);
    xfer += oprot->writeDouble(this->cache_miss_rate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetDbsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->session.read(iprot);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetDbsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDbsParams");

  if (this->__isset.pattern) {
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->session.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetDbsResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dbs.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->dbs.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += this->dbs[_i44].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dbs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetDbsResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDbsResult");

  xfer += oprot->writeFieldBegin("dbs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dbs.size()));
    std::vector< ::impala::TDatabase> ::const_iterator _iter45;
    for (_iter45 = this->dbs.begin(); _iter45 != this->dbs.end(); ++_iter45)
    {
      xfer += (*_iter45).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetDataSrcsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetDataSrcsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDataSrcsParams");

  if (this->__isset.pattern) {
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetDataSrcsResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data_src_names = false;
  bool isset_locations = false;
  bool isset_class_names = false;
  bool isset_api_versions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data_src_names.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->data_src_names.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += iprot->readString(this->data_src_names[_i58]);
            }
            xfer += iprot->readListEnd();
          }
          isset_data_src_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->locations.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->locations.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += iprot->readString(this->locations[_i63]);
            }
            xfer += iprot->readListEnd();
          }
          isset_locations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->class_names.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->class_names.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += iprot->readString(this->class_names[_i68]);
            }
            xfer += iprot->readListEnd();
          }
          isset_class_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->api_versions.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->api_versions.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += iprot->readString(this->api_versions[_i73]);
            }
            xfer += iprot->readListEnd();
          }
          isset_api_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data_src_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_locations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_class_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_api_versions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetDataSrcsResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetDataSrcsResult");

  xfer += oprot->writeFieldBegin("data_src_names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->data_src_names.size()));
    std::vector<std::string> ::const_iterator _iter74;
    for (_iter74 = this->data_src_names.begin(); _iter74 != this->data_src_names.end(); ++_iter74)
    {
      xfer += oprot->writeString((*_iter74));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->locations.size()));
    std::vector<std::string> ::const_iterator _iter75;
    for (_iter75 = this->locations.begin(); _iter75 != this->locations.end(); ++_iter75)
    {
      xfer += oprot->writeString((*_iter75));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("class_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->class_names.size()));
    std::vector<std::string> ::const_iterator _iter76;
    for (_iter76 = this->class_names.begin(); _iter76 != this->class_names.end(); ++_iter76)
    {
      xfer += oprot->writeString((*_iter76));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("api_versions", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->api_versions.size()));
    std::vector<std::string> ::const_iterator _iter77;
    for (_iter77 = this->api_versions.begin(); _iter77 != this->api_versions.end(); ++_iter77)
    {
      xfer += oprot->writeString((*_iter77));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeDbParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;
  bool isset_output_style = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast82;
          xfer += iprot->readI32(ecast82);
          this->output_style = (TDescribeOutputStyle::type)ecast82;
          isset_output_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_output_style)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeDbParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescribeDbParams");

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("output_style", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->output_style);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeTableParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_output_style = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast87;
          xfer += iprot->readI32(ecast87);
          this->output_style = (TDescribeOutputStyle::type)ecast87;
          isset_output_style = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_struct.read(iprot);
          this->__isset.result_struct = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->session.read(iprot);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_output_style)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeTableParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescribeTableParams");

  xfer += oprot->writeFieldBegin("output_style", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->output_style);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->table_name.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_struct) {
    xfer += oprot->writeFieldBegin("result_struct", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->result_struct.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->session.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_results = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->results.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->results[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_results)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescribeResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector< ::impala::TResultRow> ::const_iterator _iter97;
    for (_iter97 = this->results.begin(); _iter97 != this->results.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowDataSrcsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show_pattern);
          this->__isset.show_pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TShowDataSrcsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowDataSrcsParams");

  if (this->__isset.show_pattern) {
    xfer += oprot->writeFieldBegin("show_pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->show_pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowDbsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show_pattern);
          this->__isset.show_pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TShowDbsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowDbsParams");

  if (this->__isset.show_pattern) {
    xfer += oprot->writeFieldBegin("show_pattern", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->show_pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowStatsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->op = (TShowStatsOp::type)ecast110;
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->show_column_minmax_stats);
          this->__isset.show_column_minmax_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TShowStatsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowStatsParams");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.show_column_minmax_stats) {
    xfer += oprot->writeFieldBegin("show_column_minmax_stats", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->show_column_minmax_stats);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDescribeHistoryParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TDescribeHistoryParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDescribeHistoryParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowFunctionsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast119;
          xfer += iprot->readI32(ecast119);
          this->category = ( ::impala::TFunctionCategory::type)ecast119;
          this->__isset.category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show_pattern);
          this->__isset.show_pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TShowFunctionsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowFunctionsParams");

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->category);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_pattern) {
    xfer += oprot->writeFieldBegin("show_pattern", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->show_pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowTablesParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->show_pattern);
          this->__isset.show_pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TShowTablesParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowTablesParams");

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_pattern) {
    xfer += oprot->writeFieldBegin("show_pattern", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->show_pattern);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowFilesParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_set.clear();
            uint32_t _size128;
            ::apache::thrift::protocol::TType _etype131;
            xfer += iprot->readListBegin(_etype131, _size128);
            this->partition_set.resize(_size128);
            uint32_t _i132;
            for (_i132 = 0; _i132 < _size128; ++_i132)
            {
              {
                this->partition_set[_i132].clear();
                uint32_t _size133;
                ::apache::thrift::protocol::TType _etype136;
                xfer += iprot->readListBegin(_etype136, _size133);
                this->partition_set[_i132].resize(_size133);
                uint32_t _i137;
                for (_i137 = 0; _i137 < _size133; ++_i137)
                {
                  xfer += this->partition_set[_i132][_i137].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_set = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TShowFilesParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowFilesParams");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_set) {
    xfer += oprot->writeFieldBegin("partition_set", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->partition_set.size()));
      std::vector<std::vector< ::impala::TPartitionKeyValue> > ::const_iterator _iter138;
      for (_iter138 = this->partition_set.begin(); _iter138 != this->partition_set.end(); ++_iter138)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter138).size()));
          std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter139;
          for (_iter139 = (*_iter138).begin(); _iter139 != (*_iter138).end(); ++_iter139)
          {
            xfer += (*_iter139).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowRolesParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_show_current_roles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requesting_user);
          this->__isset.requesting_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_show_current_roles);
          isset_is_show_current_roles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->grant_group);
          this->__isset.grant_group = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_show_current_roles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TShowRolesParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowRolesParams");

  if (this->__isset.requesting_user) {
    xfer += oprot->writeFieldBegin("requesting_user", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->requesting_user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("is_show_current_roles", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_show_current_roles);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.grant_group) {
    xfer += oprot->writeFieldBegin("grant_group", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->grant_group);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowRolesResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_role_names = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->role_names.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _etype151;
            xfer += iprot->readListBegin(_etype151, _size148);
            this->role_names.resize(_size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              xfer += iprot->readString(this->role_names[_i152]);
            }
            xfer += iprot->readListEnd();
          }
          isset_role_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_role_names)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TShowRolesResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowRolesResult");

  xfer += oprot->writeFieldBegin("role_names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->role_names.size()));
    std::vector<std::string> ::const_iterator _iter153;
    for (_iter153 = this->role_names.begin(); _iter153 != this->role_names.end(); ++_iter153)
    {
      xfer += oprot->writeString((*_iter153));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableHistoryResultItem::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_creation_time = false;
  bool isset_snapshot_id = false;
  bool isset_is_current_ancestor = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->creation_time);
          isset_creation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->snapshot_id);
          isset_snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->parent_id);
          this->__isset.parent_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_current_ancestor);
          isset_is_current_ancestor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_creation_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_snapshot_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_current_ancestor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableHistoryResultItem::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTableHistoryResultItem");

  xfer += oprot->writeFieldBegin("creation_time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->creation_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->snapshot_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.parent_id) {
    xfer += oprot->writeFieldBegin("parent_id", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->parent_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("is_current_ancestor", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_current_ancestor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableHistoryResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->result.clear();
            uint32_t _size162;
            ::apache::thrift::protocol::TType _etype165;
            xfer += iprot->readListBegin(_etype165, _size162);
            this->result.resize(_size162);
            uint32_t _i166;
            for (_i166 = 0; _i166 < _size162; ++_i166)
            {
              xfer += this->result[_i166].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetTableHistoryResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetTableHistoryResult");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->result.size()));
    std::vector<TGetTableHistoryResultItem> ::const_iterator _iter167;
    for (_iter167 = this->result.begin(); _iter167 != this->result.end(); ++_iter167)
    {
      xfer += (*_iter167).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShowGrantPrincipalParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_principal_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->requesting_user);
          this->__isset.requesting_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast172;
          xfer += iprot->readI32(ecast172);
          this->principal_type = ( ::impala::TPrincipalType::type)ecast172;
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privilege.read(iprot);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TShowGrantPrincipalParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShowGrantPrincipalParams");

  if (this->__isset.requesting_user) {
    xfer += oprot->writeFieldBegin("requesting_user", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->requesting_user);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principal_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->privilege.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_category = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast177;
          xfer += iprot->readI32(ecast177);
          this->category = ( ::impala::TFunctionCategory::type)ecast177;
          isset_category = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pattern);
          this->__isset.pattern = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->session.read(iprot);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_category)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetFunctionsParams");

  xfer += oprot->writeFieldBegin("category", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->category);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->db);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pattern) {
    xfer += oprot->writeFieldBegin("pattern", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->pattern);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->session.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fn_signatures.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readListBegin(_etype185, _size182);
            this->fn_signatures.resize(_size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              xfer += iprot->readString(this->fn_signatures[_i186]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fn_signatures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fn_ret_types.clear();
            uint32_t _size187;
            ::apache::thrift::protocol::TType _etype190;
            xfer += iprot->readListBegin(_etype190, _size187);
            this->fn_ret_types.resize(_size187);
            uint32_t _i191;
            for (_i191 = 0; _i191 < _size187; ++_i191)
            {
              xfer += iprot->readString(this->fn_ret_types[_i191]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fn_ret_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fn_binary_types.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _etype195;
            xfer += iprot->readListBegin(_etype195, _size192);
            this->fn_binary_types.resize(_size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              xfer += iprot->readString(this->fn_binary_types[_i196]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fn_binary_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fn_persistence.clear();
            uint32_t _size197;
            ::apache::thrift::protocol::TType _etype200;
            xfer += iprot->readListBegin(_etype200, _size197);
            this->fn_persistence.resize(_size197);
            uint32_t _i201;
            for (_i201 = 0; _i201 < _size197; ++_i201)
            {
              xfer += iprot->readString(this->fn_persistence[_i201]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fn_persistence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetFunctionsResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetFunctionsResult");

  xfer += oprot->writeFieldBegin("fn_signatures", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fn_signatures.size()));
    std::vector<std::string> ::const_iterator _iter202;
    for (_iter202 = this->fn_signatures.begin(); _iter202 != this->fn_signatures.end(); ++_iter202)
    {
      xfer += oprot->writeString((*_iter202));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fn_ret_types", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fn_ret_types.size()));
    std::vector<std::string> ::const_iterator _iter203;
    for (_iter203 = this->fn_ret_types.begin(); _iter203 != this->fn_ret_types.end(); ++_iter203)
    {
      xfer += oprot->writeString((*_iter203));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fn_binary_types", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fn_binary_types.size()));
    std::vector<std::string> ::const_iterator _iter204;
    for (_iter204 = this->fn_binary_types.begin(); _iter204 != this->fn_binary_types.end(); ++_iter204)
    {
      xfer += oprot->writeString((*_iter204));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fn_persistence", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->fn_persistence.size()));
    std::vector<std::string> ::const_iterator _iter205;
    for (_iter205 = this->fn_persistence.begin(); _iter205 != this->fn_persistence.end(); ++_iter205)
    {
      xfer += oprot->writeString((*_iter205));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUseDbParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db);
          isset_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUseDbParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUseDbParams");

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExplainResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_results = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->results.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _etype217;
            xfer += iprot->readListBegin(_etype217, _size214);
            this->results.resize(_size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              xfer += this->results[_i218].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_results = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_results)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TExplainResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExplainResult");

  xfer += oprot->writeFieldBegin("results", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->results.size()));
    std::vector< ::impala::TResultRow> ::const_iterator _iter219;
    for (_iter219 = this->results.begin(); _iter219 != this->results.end(); ++_iter219)
    {
      xfer += (*_iter219).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TLoadDataReq::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_source_path = false;
  bool isset_overwrite = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_name.read(iprot);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source_path);
          isset_source_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overwrite);
          isset_overwrite = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size224;
            ::apache::thrift::protocol::TType _etype227;
            xfer += iprot->readListBegin(_etype227, _size224);
            this->partition_spec.resize(_size224);
            uint32_t _i228;
            for (_i228 = 0; _i228 < _size224; ++_i228)
            {
              xfer += this->partition_spec[_i228].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_source_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_overwrite)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TLoadDataReq::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLoadDataReq");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->table_name.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("source_path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->source_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overwrite", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->overwrite);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_spec) {
    xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
      std::vector< ::impala::TPartitionKeyValue> ::const_iterator _iter229;
      for (_iter229 = this->partition_spec.begin(); _iter229 != this->partition_spec.end(); ++_iter229)
      {
        xfer += (*_iter229).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TLoadDataResp::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_load_summary = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_summary.read(iprot);
          isset_load_summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_load_summary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TLoadDataResp::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TLoadDataResp");

  xfer += oprot->writeFieldBegin("load_summary", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->load_summary.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogOpRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_op_type = false;
  bool isset_sync_ddl = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast238;
          xfer += iprot->readI32(ecast238);
          this->op_type = (TCatalogOpType::type)ecast238;
          isset_op_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->sync_ddl);
          isset_sync_ddl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->use_db_params.read(iprot);
          this->__isset.use_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->describe_db_params.read(iprot);
          this->__isset.describe_db_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->describe_table_params.read(iprot);
          this->__isset.describe_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_dbs_params.read(iprot);
          this->__isset.show_dbs_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_tables_params.read(iprot);
          this->__isset.show_tables_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_fns_params.read(iprot);
          this->__isset.show_fns_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_data_srcs_params.read(iprot);
          this->__isset.show_data_srcs_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_roles_params.read(iprot);
          this->__isset.show_roles_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_grant_principal_params.read(iprot);
          this->__isset.show_grant_principal_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ddl_params.read(iprot);
          this->__isset.ddl_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reset_metadata_params.read(iprot);
          this->__isset.reset_metadata_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_stats_params.read(iprot);
          this->__isset.show_stats_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_create_table_params.read(iprot);
          this->__isset.show_create_table_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_files_params.read(iprot);
          this->__isset.show_files_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lineage_graph.read(iprot);
          this->__isset.lineage_graph = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->show_create_function_params.read(iprot);
          this->__isset.show_create_function_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->describe_history_params.read(iprot);
          this->__isset.describe_history_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_op_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sync_ddl)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogOpRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogOpRequest");

  xfer += oprot->writeFieldBegin("op_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->op_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sync_ddl", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->sync_ddl);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.use_db_params) {
    xfer += oprot->writeFieldBegin("use_db_params", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->use_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.describe_db_params) {
    xfer += oprot->writeFieldBegin("describe_db_params", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->describe_db_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.describe_table_params) {
    xfer += oprot->writeFieldBegin("describe_table_params", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->describe_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_dbs_params) {
    xfer += oprot->writeFieldBegin("show_dbs_params", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->show_dbs_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_tables_params) {
    xfer += oprot->writeFieldBegin("show_tables_params", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->show_tables_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_fns_params) {
    xfer += oprot->writeFieldBegin("show_fns_params", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->show_fns_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_data_srcs_params) {
    xfer += oprot->writeFieldBegin("show_data_srcs_params", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->show_data_srcs_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_roles_params) {
    xfer += oprot->writeFieldBegin("show_roles_params", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->show_roles_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_grant_principal_params) {
    xfer += oprot->writeFieldBegin("show_grant_principal_params", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->show_grant_principal_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ddl_params) {
    xfer += oprot->writeFieldBegin("ddl_params", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->ddl_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reset_metadata_params) {
    xfer += oprot->writeFieldBegin("reset_metadata_params", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->reset_metadata_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_stats_params) {
    xfer += oprot->writeFieldBegin("show_stats_params", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->show_stats_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_create_table_params) {
    xfer += oprot->writeFieldBegin("show_create_table_params", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->show_create_table_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_files_params) {
    xfer += oprot->writeFieldBegin("show_files_params", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->show_files_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lineage_graph) {
    xfer += oprot->writeFieldBegin("lineage_graph", ::apache::thrift::protocol::T_STRUCT, 17);
    xfer += this->lineage_graph.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.show_create_function_params) {
    xfer += oprot->writeFieldBegin("show_create_function_params", ::apache::thrift::protocol::T_STRUCT, 18);
    xfer += this->show_create_function_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.describe_history_params) {
    xfer += oprot->writeFieldBegin("describe_history_params", ::apache::thrift::protocol::T_STRUCT, 19);
    xfer += this->describe_history_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TSetQueryOptionRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_set_all);
          this->__isset.is_set_all = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TSetQueryOptionRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSetQueryOptionRequest");

  if (this->__isset.key) {
    xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_set_all) {
    xfer += oprot->writeFieldBegin("is_set_all", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->is_set_all);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TShutdownParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->backend.read(iprot);
          this->__isset.backend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deadline_s);
          this->__isset.deadline_s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TShutdownParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TShutdownParams");

  if (this->__isset.backend) {
    xfer += oprot->writeFieldBegin("backend", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->backend.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.deadline_s) {
    xfer += oprot->writeFieldBegin("deadline_s", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->deadline_s);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAdminRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast251;
          xfer += iprot->readI32(ecast251);
          this->type = (TAdminRequestType::type)ecast251;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->shutdown_params.read(iprot);
          this->__isset.shutdown_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAdminRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAdminRequest");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.shutdown_params) {
    xfer += oprot->writeFieldBegin("shutdown_params", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->shutdown_params.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TMetadataOpRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_opcode = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast256;
          xfer += iprot->readI32(ecast256);
          this->opcode = (TMetadataOpcode::type)ecast256;
          isset_opcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_info_req.read(iprot);
          this->__isset.get_info_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_type_info_req.read(iprot);
          this->__isset.get_type_info_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_catalogs_req.read(iprot);
          this->__isset.get_catalogs_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_schemas_req.read(iprot);
          this->__isset.get_schemas_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_tables_req.read(iprot);
          this->__isset.get_tables_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_table_types_req.read(iprot);
          this->__isset.get_table_types_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_columns_req.read(iprot);
          this->__isset.get_columns_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_functions_req.read(iprot);
          this->__isset.get_functions_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->session.read(iprot);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_primary_keys_req.read(iprot);
          this->__isset.get_primary_keys_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->get_cross_reference_req.read(iprot);
          this->__isset.get_cross_reference_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_opcode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TMetadataOpRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TMetadataOpRequest");

  xfer += oprot->writeFieldBegin("opcode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->opcode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.get_info_req) {
    xfer += oprot->writeFieldBegin("get_info_req", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->get_info_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_type_info_req) {
    xfer += oprot->writeFieldBegin("get_type_info_req", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->get_type_info_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_catalogs_req) {
    xfer += oprot->writeFieldBegin("get_catalogs_req", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->get_catalogs_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_schemas_req) {
    xfer += oprot->writeFieldBegin("get_schemas_req", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->get_schemas_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_tables_req) {
    xfer += oprot->writeFieldBegin("get_tables_req", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->get_tables_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_table_types_req) {
    xfer += oprot->writeFieldBegin("get_table_types_req", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->get_table_types_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_columns_req) {
    xfer += oprot->writeFieldBegin("get_columns_req", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->get_columns_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_functions_req) {
    xfer += oprot->writeFieldBegin("get_functions_req", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->get_functions_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.session) {
    xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->session.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_primary_keys_req) {
    xfer += oprot->writeFieldBegin("get_primary_keys_req", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->get_primary_keys_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.get_cross_reference_req) {
    xfer += oprot->writeFieldBegin("get_cross_reference_req", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->get_cross_reference_req.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAccessEvent::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_object_type = false;
  bool isset_privilege = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast261;
          xfer += iprot->readI32(ecast261);
          this->object_type = ( ::impala::TCatalogObjectType::type)ecast261;
          isset_object_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->privilege);
          isset_privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_object_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_privilege)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAccessEvent::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAccessEvent");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("object_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->object_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->privilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExecRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stmt_type = false;
  bool isset_query_options = false;
  bool isset_analysis_warnings = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast266;
          xfer += iprot->readI32(ecast266);
          this->stmt_type = ( ::impala::TStmtType::type)ecast266;
          isset_stmt_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_options.read(iprot);
          isset_query_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_exec_request.read(iprot);
          this->__isset.query_exec_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_op_request.read(iprot);
          this->__isset.catalog_op_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result_set_metadata.read(iprot);
          this->__isset.result_set_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->explain_result.read(iprot);
          this->__isset.explain_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_data_request.read(iprot);
          this->__isset.load_data_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->access_events.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->access_events.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += this->access_events[_i271].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.access_events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->analysis_warnings.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            this->analysis_warnings.resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += iprot->readString(this->analysis_warnings[_i276]);
            }
            xfer += iprot->readListEnd();
          }
          isset_analysis_warnings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_query_option_request.read(iprot);
          this->__isset.set_query_option_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->timeline.read(iprot);
          this->__isset.timeline = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->user_has_profile_access);
          this->__isset.user_has_profile_access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->admin_request.read(iprot);
          this->__isset.admin_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->profile.read(iprot);
          this->__isset.profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->testcase_data_path);
          this->__isset.testcase_data_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->remote_submit_time);
          this->__isset.remote_submit_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stmt_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_query_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_analysis_warnings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TExecRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecRequest");

  xfer += oprot->writeFieldBegin("stmt_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->stmt_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->query_options.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.query_exec_request) {
    xfer += oprot->writeFieldBegin("query_exec_request", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->query_exec_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalog_op_request) {
    xfer += oprot->writeFieldBegin("catalog_op_request", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->catalog_op_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.result_set_metadata) {
    xfer += oprot->writeFieldBegin("result_set_metadata", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->result_set_metadata.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.explain_result) {
    xfer += oprot->writeFieldBegin("explain_result", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->explain_result.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.load_data_request) {
    xfer += oprot->writeFieldBegin("load_data_request", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->load_data_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_events) {
    xfer += oprot->writeFieldBegin("access_events", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->access_events.size()));
      std::vector<TAccessEvent> ::const_iterator _iter277;
      for (_iter277 = this->access_events.begin(); _iter277 != this->access_events.end(); ++_iter277)
      {
        xfer += (*_iter277).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("analysis_warnings", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->analysis_warnings.size()));
    std::vector<std::string> ::const_iterator _iter278;
    for (_iter278 = this->analysis_warnings.begin(); _iter278 != this->analysis_warnings.end(); ++_iter278)
    {
      xfer += oprot->writeString((*_iter278));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.set_query_option_request) {
    xfer += oprot->writeFieldBegin("set_query_option_request", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->set_query_option_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.timeline) {
    xfer += oprot->writeFieldBegin("timeline", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->timeline.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user_has_profile_access) {
    xfer += oprot->writeFieldBegin("user_has_profile_access", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->user_has_profile_access);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.admin_request) {
    xfer += oprot->writeFieldBegin("admin_request", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->admin_request.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.profile) {
    xfer += oprot->writeFieldBegin("profile", ::apache::thrift::protocol::T_STRUCT, 14);
    xfer += this->profile.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.testcase_data_path) {
    xfer += oprot->writeFieldBegin("testcase_data_path", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->testcase_data_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remote_submit_time) {
    xfer += oprot->writeFieldBegin("remote_submit_time", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->remote_submit_time);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCacheJarParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hdfs_location = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          isset_hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hdfs_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCacheJarParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCacheJarParams");

  xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hdfs_location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCacheJarResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->local_path);
          this->__isset.local_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCacheJarResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCacheJarResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.local_path) {
    xfer += oprot->writeFieldBegin("local_path", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->local_path);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TSymbolLookupParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_location = false;
  bool isset_symbol = false;
  bool isset_fn_binary_type = false;
  bool isset_arg_types = false;
  bool isset_has_var_args = false;
  bool isset_symbol_type = false;
  bool isset_needs_refresh = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->location);
          isset_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbol);
          isset_symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast291;
          xfer += iprot->readI32(ecast291);
          this->fn_binary_type = ( ::impala::TFunctionBinaryType::type)ecast291;
          isset_fn_binary_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arg_types.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _etype295;
            xfer += iprot->readListBegin(_etype295, _size292);
            this->arg_types.resize(_size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              xfer += this->arg_types[_i296].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_arg_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_var_args);
          isset_has_var_args = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ret_arg_type.read(iprot);
          this->__isset.ret_arg_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast297;
          xfer += iprot->readI32(ecast297);
          this->symbol_type = (TSymbolType::type)ecast297;
          isset_symbol_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->needs_refresh);
          isset_needs_refresh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_symbol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fn_binary_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_arg_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_var_args)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_symbol_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_needs_refresh)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TSymbolLookupParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSymbolLookupParams");

  xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->symbol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fn_binary_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fn_binary_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg_types", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arg_types.size()));
    std::vector< ::impala::TColumnType> ::const_iterator _iter298;
    for (_iter298 = this->arg_types.begin(); _iter298 != this->arg_types.end(); ++_iter298)
    {
      xfer += (*_iter298).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_var_args", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->has_var_args);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ret_arg_type) {
    xfer += oprot->writeFieldBegin("ret_arg_type", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->ret_arg_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("symbol_type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->symbol_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("needs_refresh", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->needs_refresh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TSymbolLookupResult::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_result_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast303;
          xfer += iprot->readI32(ecast303);
          this->result_code = (TSymbolLookupResultCode::type)ecast303;
          isset_result_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbol);
          this->__isset.symbol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_modified_time);
          this->__isset.last_modified_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_result_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TSymbolLookupResult::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSymbolLookupResult");

  xfer += oprot->writeFieldBegin("result_code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->result_code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.symbol) {
    xfer += oprot->writeFieldBegin("symbol", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->symbol);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.error_msg) {
    xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->error_msg);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.last_modified_time) {
    xfer += oprot->writeFieldBegin("last_modified_time", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->last_modified_time);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogCacheRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_is_delta = false;
  bool isset_native_iterator_ptr = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_delta);
          isset_is_delta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_service_id.read(iprot);
          this->__isset.catalog_service_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updated_objects_deprecated.clear();
            uint32_t _size308;
            ::apache::thrift::protocol::TType _etype311;
            xfer += iprot->readListBegin(_etype311, _size308);
            this->updated_objects_deprecated.resize(_size308);
            uint32_t _i312;
            for (_i312 = 0; _i312 < _size308; ++_i312)
            {
              xfer += this->updated_objects_deprecated[_i312].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updated_objects_deprecated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->removed_objects_deprecated.clear();
            uint32_t _size313;
            ::apache::thrift::protocol::TType _etype316;
            xfer += iprot->readListBegin(_etype316, _size313);
            this->removed_objects_deprecated.resize(_size313);
            uint32_t _i317;
            for (_i317 = 0; _i317 < _size313; ++_i317)
            {
              xfer += this->removed_objects_deprecated[_i317].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.removed_objects_deprecated = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->native_iterator_ptr);
          isset_native_iterator_ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_is_delta)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_native_iterator_ptr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogCacheRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateCatalogCacheRequest");

  xfer += oprot->writeFieldBegin("is_delta", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->is_delta);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalog_service_id) {
    xfer += oprot->writeFieldBegin("catalog_service_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->catalog_service_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updated_objects_deprecated) {
    xfer += oprot->writeFieldBegin("updated_objects_deprecated", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updated_objects_deprecated.size()));
      std::vector< ::impala::TCatalogObject> ::const_iterator _iter318;
      for (_iter318 = this->updated_objects_deprecated.begin(); _iter318 != this->updated_objects_deprecated.end(); ++_iter318)
      {
        xfer += (*_iter318).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.removed_objects_deprecated) {
    xfer += oprot->writeFieldBegin("removed_objects_deprecated", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->removed_objects_deprecated.size()));
      std::vector< ::impala::TCatalogObject> ::const_iterator _iter319;
      for (_iter319 = this->removed_objects_deprecated.begin(); _iter319 != this->removed_objects_deprecated.end(); ++_iter319)
      {
        xfer += (*_iter319).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("native_iterator_ptr", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->native_iterator_ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogCacheResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_service_id = false;
  bool isset_catalog_object_version_lower_bound = false;
  bool isset_new_catalog_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_service_id.read(iprot);
          isset_catalog_service_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->catalog_object_version_lower_bound);
          isset_catalog_object_version_lower_bound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->new_catalog_version);
          isset_new_catalog_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_service_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalog_object_version_lower_bound)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_new_catalog_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateCatalogCacheResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateCatalogCacheResponse");

  xfer += oprot->writeFieldBegin("catalog_service_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog_service_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalog_object_version_lower_bound", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->catalog_object_version_lower_bound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("new_catalog_version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->new_catalog_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TExecutorGroupSet::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curr_num_executors);
          this->__isset.curr_num_executors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expected_num_executors);
          this->__isset.expected_num_executors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exec_group_name_prefix);
          this->__isset.exec_group_name_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TExecutorGroupSet::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TExecutorGroupSet");

  xfer += oprot->writeFieldBegin("curr_num_executors", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->curr_num_executors);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expected_num_executors", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->expected_num_executors);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exec_group_name_prefix", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->exec_group_name_prefix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateExecutorMembershipRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hostnames = false;
  bool isset_ip_addresses = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->hostnames.clear();
            uint32_t _size332;
            ::apache::thrift::protocol::TType _etype335;
            xfer += iprot->readSetBegin(_etype335, _size332);
            uint32_t _i336;
            for (_i336 = 0; _i336 < _size332; ++_i336)
            {
              std::string _elem337;
              xfer += iprot->readString(_elem337);
              this->hostnames.insert(_elem337);
            }
            xfer += iprot->readSetEnd();
          }
          isset_hostnames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->ip_addresses.clear();
            uint32_t _size338;
            ::apache::thrift::protocol::TType _etype341;
            xfer += iprot->readSetBegin(_etype341, _size338);
            uint32_t _i342;
            for (_i342 = 0; _i342 < _size338; ++_i342)
            {
              std::string _elem343;
              xfer += iprot->readString(_elem343);
              this->ip_addresses.insert(_elem343);
            }
            xfer += iprot->readSetEnd();
          }
          isset_ip_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->exec_group_sets.clear();
            uint32_t _size344;
            ::apache::thrift::protocol::TType _etype347;
            xfer += iprot->readListBegin(_etype347, _size344);
            this->exec_group_sets.resize(_size344);
            uint32_t _i348;
            for (_i348 = 0; _i348 < _size344; ++_i348)
            {
              xfer += this->exec_group_sets[_i348].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.exec_group_sets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hostnames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ip_addresses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateExecutorMembershipRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateExecutorMembershipRequest");

  xfer += oprot->writeFieldBegin("hostnames", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hostnames.size()));
    std::set<std::string> ::const_iterator _iter349;
    for (_iter349 = this->hostnames.begin(); _iter349 != this->hostnames.end(); ++_iter349)
    {
      xfer += oprot->writeString((*_iter349));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip_addresses", ::apache::thrift::protocol::T_SET, 2);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ip_addresses.size()));
    std::set<std::string> ::const_iterator _iter350;
    for (_iter350 = this->ip_addresses.begin(); _iter350 != this->ip_addresses.end(); ++_iter350)
    {
      xfer += oprot->writeString((*_iter350));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exec_group_sets", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->exec_group_sets.size()));
    std::vector<TExecutorGroupSet> ::const_iterator _iter351;
    for (_iter351 = this->exec_group_sets.begin(); _iter351 != this->exec_group_sets.end(); ++_iter351)
    {
      xfer += (*_iter351).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TJvmMemoryPool::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_committed = false;
  bool isset_init = false;
  bool isset_max = false;
  bool isset_used = false;
  bool isset_peak_committed = false;
  bool isset_peak_init = false;
  bool isset_peak_max = false;
  bool isset_peak_used = false;
  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->committed);
          isset_committed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->init);
          isset_init = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max);
          isset_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->used);
          isset_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->peak_committed);
          isset_peak_committed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->peak_init);
          isset_peak_init = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->peak_max);
          isset_peak_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->peak_used);
          isset_peak_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_committed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_init)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_used)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peak_committed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peak_init)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peak_max)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peak_used)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TJvmMemoryPool::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJvmMemoryPool");

  xfer += oprot->writeFieldBegin("committed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->committed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("init", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->init);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("used", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->used);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peak_committed", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->peak_committed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peak_init", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->peak_init);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peak_max", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->peak_max);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peak_used", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->peak_used);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetJvmMemoryMetricsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_memory_pools = false;
  bool isset_gc_num_warn_threshold_exceeded = false;
  bool isset_gc_num_info_threshold_exceeded = false;
  bool isset_gc_total_extra_sleep_time_millis = false;
  bool isset_gc_count = false;
  bool isset_gc_time_millis = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->memory_pools.clear();
            uint32_t _size360;
            ::apache::thrift::protocol::TType _etype363;
            xfer += iprot->readListBegin(_etype363, _size360);
            this->memory_pools.resize(_size360);
            uint32_t _i364;
            for (_i364 = 0; _i364 < _size360; ++_i364)
            {
              xfer += this->memory_pools[_i364].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_memory_pools = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gc_num_warn_threshold_exceeded);
          isset_gc_num_warn_threshold_exceeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gc_num_info_threshold_exceeded);
          isset_gc_num_info_threshold_exceeded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gc_total_extra_sleep_time_millis);
          isset_gc_total_extra_sleep_time_millis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gc_count);
          isset_gc_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gc_time_millis);
          isset_gc_time_millis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_memory_pools)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gc_num_warn_threshold_exceeded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gc_num_info_threshold_exceeded)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gc_total_extra_sleep_time_millis)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gc_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_gc_time_millis)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetJvmMemoryMetricsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetJvmMemoryMetricsResponse");

  xfer += oprot->writeFieldBegin("memory_pools", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->memory_pools.size()));
    std::vector<TJvmMemoryPool> ::const_iterator _iter365;
    for (_iter365 = this->memory_pools.begin(); _iter365 != this->memory_pools.end(); ++_iter365)
    {
      xfer += (*_iter365).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gc_num_warn_threshold_exceeded", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->gc_num_warn_threshold_exceeded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gc_num_info_threshold_exceeded", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->gc_num_info_threshold_exceeded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gc_total_extra_sleep_time_millis", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->gc_total_extra_sleep_time_millis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gc_count", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->gc_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gc_time_millis", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->gc_time_millis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TJvmThreadInfo::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_summary = false;
  bool isset_cpu_time_in_ns = false;
  bool isset_user_time_in_ns = false;
  bool isset_blocked_count = false;
  bool isset_blocked_time_in_ms = false;
  bool isset_is_in_native = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->summary);
          isset_summary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpu_time_in_ns);
          isset_cpu_time_in_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->user_time_in_ns);
          isset_user_time_in_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blocked_count);
          isset_blocked_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->blocked_time_in_ms);
          isset_blocked_time_in_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_in_native);
          isset_is_in_native = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_summary)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cpu_time_in_ns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_user_time_in_ns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blocked_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blocked_time_in_ms)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_in_native)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TJvmThreadInfo::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TJvmThreadInfo");

  xfer += oprot->writeFieldBegin("summary", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->summary);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_time_in_ns", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cpu_time_in_ns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user_time_in_ns", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->user_time_in_ns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocked_count", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->blocked_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blocked_time_in_ms", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->blocked_time_in_ms);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_in_native", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_in_native);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetJvmThreadsInfoRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_get_complete_info = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->get_complete_info);
          isset_get_complete_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_get_complete_info)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetJvmThreadsInfoRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetJvmThreadsInfoRequest");

  xfer += oprot->writeFieldBegin("get_complete_info", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->get_complete_info);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetJvmThreadsInfoResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_total_thread_count = false;
  bool isset_daemon_thread_count = false;
  bool isset_peak_thread_count = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_thread_count);
          isset_total_thread_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->daemon_thread_count);
          isset_daemon_thread_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->peak_thread_count);
          isset_peak_thread_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->threads.clear();
            uint32_t _size378;
            ::apache::thrift::protocol::TType _etype381;
            xfer += iprot->readListBegin(_etype381, _size378);
            this->threads.resize(_size378);
            uint32_t _i382;
            for (_i382 = 0; _i382 < _size378; ++_i382)
            {
              xfer += this->threads[_i382].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.threads = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_total_thread_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_daemon_thread_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_peak_thread_count)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetJvmThreadsInfoResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetJvmThreadsInfoResponse");

  xfer += oprot->writeFieldBegin("total_thread_count", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total_thread_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("daemon_thread_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->daemon_thread_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("peak_thread_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->peak_thread_count);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.threads) {
    xfer += oprot->writeFieldBegin("threads", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->threads.size()));
      std::vector<TJvmThreadInfo> ::const_iterator _iter383;
      for (_iter383 = this->threads.begin(); _iter383 != this->threads.end(); ++_iter383)
      {
        xfer += (*_iter383).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetJMXJsonResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_jmx_json = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jmx_json);
          isset_jmx_json = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_jmx_json)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetJMXJsonResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetJMXJsonResponse");

  xfer += oprot->writeFieldBegin("jmx_json", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->jmx_json);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopConfigRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopConfigRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetHadoopConfigRequest");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopConfigResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopConfigResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetHadoopConfigResponse");

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetAllHadoopConfigsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configs.clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _ktype401;
            ::apache::thrift::protocol::TType _vtype402;
            xfer += iprot->readMapBegin(_ktype401, _vtype402, _size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              std::string _key405;
              xfer += iprot->readString(_key405);
              std::string& _val406 = this->configs[_key405];
              xfer += iprot->readString(_val406);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TGetAllHadoopConfigsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetAllHadoopConfigsResponse");

  if (this->__isset.configs) {
    xfer += oprot->writeFieldBegin("configs", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configs.size()));
      std::map<std::string, std::string> ::const_iterator _iter407;
      for (_iter407 = this->configs.begin(); _iter407 != this->configs.end(); ++_iter407)
      {
        xfer += oprot->writeString(_iter407->first);
        xfer += oprot->writeString(_iter407->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopGroupsRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_user = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          isset_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_user)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopGroupsRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetHadoopGroupsRequest");

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopGroupsResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_groups = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size416;
            ::apache::thrift::protocol::TType _etype419;
            xfer += iprot->readListBegin(_etype419, _size416);
            this->groups.resize(_size416);
            uint32_t _i420;
            for (_i420 = 0; _i420 < _size416; ++_i420)
            {
              xfer += iprot->readString(this->groups[_i420]);
            }
            xfer += iprot->readListEnd();
          }
          isset_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_groups)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TGetHadoopGroupsResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TGetHadoopGroupsResponse");

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groups.size()));
    std::vector<std::string> ::const_iterator _iter421;
    for (_iter421 = this->groups.begin(); _iter421 != this->groups.end(); ++_iter421)
    {
      xfer += oprot->writeString((*_iter421));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TBuildTestDescriptorTableParams::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_slot_types = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->slot_types.clear();
            uint32_t _size426;
            ::apache::thrift::protocol::TType _etype429;
            xfer += iprot->readListBegin(_etype429, _size426);
            this->slot_types.resize(_size426);
            uint32_t _i430;
            for (_i430 = 0; _i430 < _size426; ++_i430)
            {
              {
                this->slot_types[_i430].clear();
                uint32_t _size431;
                ::apache::thrift::protocol::TType _etype434;
                xfer += iprot->readListBegin(_etype434, _size431);
                this->slot_types[_i430].resize(_size431);
                uint32_t _i435;
                for (_i435 = 0; _i435 < _size431; ++_i435)
                {
                  xfer += this->slot_types[_i430][_i435].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_slot_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_slot_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TBuildTestDescriptorTableParams::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TBuildTestDescriptorTableParams");

  xfer += oprot->writeFieldBegin("slot_types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->slot_types.size()));
    std::vector<std::vector< ::impala::TColumnType> > ::const_iterator _iter436;
    for (_iter436 = this->slot_types.begin(); _iter436 != this->slot_types.end(); ++_iter436)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter436).size()));
        std::vector< ::impala::TColumnType> ::const_iterator _iter437;
        for (_iter437 = (*_iter436).begin(); _iter437 != (*_iter436).end(); ++_iter437)
        {
          xfer += (*_iter437).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTestCaseData::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_query_stmt = false;
  bool isset_testcase_data_path = false;
  bool isset_impala_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query_stmt);
          isset_query_stmt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tables_and_views.clear();
            uint32_t _size442;
            ::apache::thrift::protocol::TType _etype445;
            xfer += iprot->readListBegin(_etype445, _size442);
            this->tables_and_views.resize(_size442);
            uint32_t _i446;
            for (_i446 = 0; _i446 < _size442; ++_i446)
            {
              xfer += this->tables_and_views[_i446].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tables_and_views = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dbs.clear();
            uint32_t _size447;
            ::apache::thrift::protocol::TType _etype450;
            xfer += iprot->readListBegin(_etype450, _size447);
            this->dbs.resize(_size447);
            uint32_t _i451;
            for (_i451 = 0; _i451 < _size447; ++_i451)
            {
              xfer += this->dbs[_i451].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dbs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->testcase_data_path);
          isset_testcase_data_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->impala_version);
          isset_impala_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_query_stmt)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_testcase_data_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_impala_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTestCaseData::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTestCaseData");

  xfer += oprot->writeFieldBegin("query_stmt", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->query_stmt);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tables_and_views) {
    xfer += oprot->writeFieldBegin("tables_and_views", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tables_and_views.size()));
      std::vector< ::impala::TTable> ::const_iterator _iter452;
      for (_iter452 = this->tables_and_views.begin(); _iter452 != this->tables_and_views.end(); ++_iter452)
      {
        xfer += (*_iter452).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dbs) {
    xfer += oprot->writeFieldBegin("dbs", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dbs.size()));
      std::vector< ::impala::TDatabase> ::const_iterator _iter453;
      for (_iter453 = this->dbs.begin(); _iter453 != this->dbs.end(); ++_iter453)
      {
        xfer += (*_iter453).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("testcase_data_path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->testcase_data_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("impala_version", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->impala_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TQueryCompleteContext::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lineage_string = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lineage_string);
          isset_lineage_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lineage_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TQueryCompleteContext::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TQueryCompleteContext");

  xfer += oprot->writeFieldBegin("lineage_string", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->lineage_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TWrappedHttpRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_method = false;
  bool isset_server_name = false;
  bool isset_server_port = false;
  bool isset_path = false;
  bool isset_params = false;
  bool isset_headers = false;
  bool isset_cookies = false;
  bool isset_remote_ip = false;
  bool isset_secure = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          isset_method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          isset_server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->server_port);
          isset_server_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->params.clear();
            uint32_t _size462;
            ::apache::thrift::protocol::TType _ktype463;
            ::apache::thrift::protocol::TType _vtype464;
            xfer += iprot->readMapBegin(_ktype463, _vtype464, _size462);
            uint32_t _i466;
            for (_i466 = 0; _i466 < _size462; ++_i466)
            {
              std::string _key467;
              xfer += iprot->readString(_key467);
              std::string& _val468 = this->params[_key467];
              xfer += iprot->readString(_val468);
            }
            xfer += iprot->readMapEnd();
          }
          isset_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headers.clear();
            uint32_t _size469;
            ::apache::thrift::protocol::TType _ktype470;
            ::apache::thrift::protocol::TType _vtype471;
            xfer += iprot->readMapBegin(_ktype470, _vtype471, _size469);
            uint32_t _i473;
            for (_i473 = 0; _i473 < _size469; ++_i473)
            {
              std::string _key474;
              xfer += iprot->readString(_key474);
              std::string& _val475 = this->headers[_key474];
              xfer += iprot->readString(_val475);
            }
            xfer += iprot->readMapEnd();
          }
          isset_headers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cookies.clear();
            uint32_t _size476;
            ::apache::thrift::protocol::TType _ktype477;
            ::apache::thrift::protocol::TType _vtype478;
            xfer += iprot->readMapBegin(_ktype477, _vtype478, _size476);
            uint32_t _i480;
            for (_i480 = 0; _i480 < _size476; ++_i480)
            {
              std::string _key481;
              xfer += iprot->readString(_key481);
              std::string& _val482 = this->cookies[_key481];
              xfer += iprot->readString(_val482);
            }
            xfer += iprot->readMapEnd();
          }
          isset_cookies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remote_ip);
          isset_remote_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->secure);
          isset_secure = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_method)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_server_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_server_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_params)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_headers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cookies)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_remote_ip)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_secure)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TWrappedHttpRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TWrappedHttpRequest");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->server_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server_port", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->server_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->params.size()));
    std::map<std::string, std::string> ::const_iterator _iter483;
    for (_iter483 = this->params.begin(); _iter483 != this->params.end(); ++_iter483)
    {
      xfer += oprot->writeString(_iter483->first);
      xfer += oprot->writeString(_iter483->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headers", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headers.size()));
    std::map<std::string, std::string> ::const_iterator _iter484;
    for (_iter484 = this->headers.begin(); _iter484 != this->headers.end(); ++_iter484)
    {
      xfer += oprot->writeString(_iter484->first);
      xfer += oprot->writeString(_iter484->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookies", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cookies.size()));
    std::map<std::string, std::string> ::const_iterator _iter485;
    for (_iter485 = this->cookies.begin(); _iter485 != this->cookies.end(); ++_iter485)
    {
      xfer += oprot->writeString(_iter485->first);
      xfer += oprot->writeString(_iter485->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.content) {
    xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->content);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("remote_ip", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->remote_ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secure", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->secure);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TWrappedHttpResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status_code = false;
  bool isset_status_text = false;
  bool isset_headers = false;
  bool isset_cookies = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status_code);
          isset_status_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status_text);
          isset_status_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->headers.clear();
            uint32_t _size490;
            ::apache::thrift::protocol::TType _ktype491;
            ::apache::thrift::protocol::TType _vtype492;
            xfer += iprot->readMapBegin(_ktype491, _vtype492, _size490);
            uint32_t _i494;
            for (_i494 = 0; _i494 < _size490; ++_i494)
            {
              std::string _key495;
              xfer += iprot->readString(_key495);
              std::string& _val496 = this->headers[_key495];
              xfer += iprot->readString(_val496);
            }
            xfer += iprot->readMapEnd();
          }
          isset_headers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cookies.clear();
            uint32_t _size497;
            ::apache::thrift::protocol::TType _ktype498;
            ::apache::thrift::protocol::TType _vtype499;
            xfer += iprot->readMapBegin(_ktype498, _vtype499, _size497);
            uint32_t _i501;
            for (_i501 = 0; _i501 < _size497; ++_i501)
            {
              std::string _key502;
              xfer += iprot->readString(_key502);
              std::string& _val503 = this->cookies[_key502];
              xfer += iprot->readString(_val503);
            }
            xfer += iprot->readMapEnd();
          }
          isset_cookies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content_type);
          this->__isset.content_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_status_text)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_headers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cookies)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TWrappedHttpResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TWrappedHttpResponse");

  xfer += oprot->writeFieldBegin("status_code", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->status_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status_text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->status_text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("headers", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->headers.size()));
    std::map<std::string, std::string> ::const_iterator _iter504;
    for (_iter504 = this->headers.begin(); _iter504 != this->headers.end(); ++_iter504)
    {
      xfer += oprot->writeString(_iter504->first);
      xfer += oprot->writeString(_iter504->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cookies", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cookies.size()));
    std::map<std::string, std::string> ::const_iterator _iter505;
    for (_iter505 = this->cookies.begin(); _iter505 != this->cookies.end(); ++_iter505)
    {
      xfer += oprot->writeString(_iter505->first);
      xfer += oprot->writeString(_iter505->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.content) {
    xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->content);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.content_type) {
    xfer += oprot->writeFieldBegin("content_type", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->content_type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
