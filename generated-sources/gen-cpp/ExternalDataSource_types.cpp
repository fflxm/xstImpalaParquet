/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ExternalDataSource_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala { namespace extdatasource {

int _kTComparisonOpValues[] = {
  TComparisonOp::LT,
  TComparisonOp::LE,
  TComparisonOp::EQ,
  TComparisonOp::NE,
  TComparisonOp::GE,
  TComparisonOp::GT,
  TComparisonOp::DISTINCT_FROM,
  TComparisonOp::NOT_DISTINCT
};
const char* _kTComparisonOpNames[] = {
  "LT",
  "LE",
  "EQ",
  "NE",
  "GE",
  "GT",
  "DISTINCT_FROM",
  "NOT_DISTINCT"
};
const std::map<int, const char*> _TComparisonOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTComparisonOpValues, _kTComparisonOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TComparisonOp::type& val) {
  std::map<int, const char*>::const_iterator it = _TComparisonOp_VALUES_TO_NAMES.find(val);
  if (it != _TComparisonOp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TColumnDesc::~TColumnDesc() throw() {
}


void TColumnDesc::__set_name(const std::string& val) {
  this->name = val;
__isset.name = true;
}

void TColumnDesc::__set_type(const  ::impala::TColumnType& val) {
  this->type = val;
__isset.type = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnDesc& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TColumnDesc &a, TColumnDesc &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

TColumnDesc::TColumnDesc(const TColumnDesc& other0) {
  name = other0.name;
  type = other0.type;
  __isset = other0.__isset;
}
TColumnDesc::TColumnDesc( TColumnDesc&& other1) {
  name = std::move(other1.name);
  type = std::move(other1.type);
  __isset = std::move(other1.__isset);
}
TColumnDesc& TColumnDesc::operator=(const TColumnDesc& other2) {
  name = other2.name;
  type = other2.type;
  __isset = other2.__isset;
  return *this;
}
TColumnDesc& TColumnDesc::operator=(TColumnDesc&& other3) {
  name = std::move(other3.name);
  type = std::move(other3.type);
  __isset = std::move(other3.__isset);
  return *this;
}
void TColumnDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnDesc(";
  out << "name="; (__isset.name ? (out << to_string(name)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ")";
}


TTableSchema::~TTableSchema() throw() {
}


void TTableSchema::__set_cols(const std::vector<TColumnDesc> & val) {
  this->cols = val;
__isset.cols = true;
}
std::ostream& operator<<(std::ostream& out, const TTableSchema& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTableSchema &a, TTableSchema &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.__isset, b.__isset);
}

TTableSchema::TTableSchema(const TTableSchema& other10) {
  cols = other10.cols;
  __isset = other10.__isset;
}
TTableSchema::TTableSchema( TTableSchema&& other11) {
  cols = std::move(other11.cols);
  __isset = std::move(other11.__isset);
}
TTableSchema& TTableSchema::operator=(const TTableSchema& other12) {
  cols = other12.cols;
  __isset = other12.__isset;
  return *this;
}
TTableSchema& TTableSchema::operator=(TTableSchema&& other13) {
  cols = std::move(other13.cols);
  __isset = std::move(other13.__isset);
  return *this;
}
void TTableSchema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableSchema(";
  out << "cols="; (__isset.cols ? (out << to_string(cols)) : (out << "<null>"));
  out << ")";
}


TRowBatch::~TRowBatch() throw() {
}


void TRowBatch::__set_cols(const std::vector< ::impala::TColumnData> & val) {
  this->cols = val;
__isset.cols = true;
}

void TRowBatch::__set_num_rows(const int64_t val) {
  this->num_rows = val;
__isset.num_rows = true;
}
std::ostream& operator<<(std::ostream& out, const TRowBatch& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TRowBatch &a, TRowBatch &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.num_rows, b.num_rows);
  swap(a.__isset, b.__isset);
}

TRowBatch::TRowBatch(const TRowBatch& other20) {
  cols = other20.cols;
  num_rows = other20.num_rows;
  __isset = other20.__isset;
}
TRowBatch::TRowBatch( TRowBatch&& other21) {
  cols = std::move(other21.cols);
  num_rows = std::move(other21.num_rows);
  __isset = std::move(other21.__isset);
}
TRowBatch& TRowBatch::operator=(const TRowBatch& other22) {
  cols = other22.cols;
  num_rows = other22.num_rows;
  __isset = other22.__isset;
  return *this;
}
TRowBatch& TRowBatch::operator=(TRowBatch&& other23) {
  cols = std::move(other23.cols);
  num_rows = std::move(other23.num_rows);
  __isset = std::move(other23.__isset);
  return *this;
}
void TRowBatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRowBatch(";
  out << "cols="; (__isset.cols ? (out << to_string(cols)) : (out << "<null>"));
  out << ", " << "num_rows="; (__isset.num_rows ? (out << to_string(num_rows)) : (out << "<null>"));
  out << ")";
}


TBinaryPredicate::~TBinaryPredicate() throw() {
}


void TBinaryPredicate::__set_col(const TColumnDesc& val) {
  this->col = val;
__isset.col = true;
}

void TBinaryPredicate::__set_op(const TComparisonOp::type val) {
  this->op = val;
__isset.op = true;
}

void TBinaryPredicate::__set_value(const  ::impala::TColumnValue& val) {
  this->value = val;
__isset.value = true;
}
std::ostream& operator<<(std::ostream& out, const TBinaryPredicate& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TBinaryPredicate &a, TBinaryPredicate &b) {
  using ::std::swap;
  swap(a.col, b.col);
  swap(a.op, b.op);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

TBinaryPredicate::TBinaryPredicate(const TBinaryPredicate& other25) {
  col = other25.col;
  op = other25.op;
  value = other25.value;
  __isset = other25.__isset;
}
TBinaryPredicate::TBinaryPredicate( TBinaryPredicate&& other26) {
  col = std::move(other26.col);
  op = std::move(other26.op);
  value = std::move(other26.value);
  __isset = std::move(other26.__isset);
}
TBinaryPredicate& TBinaryPredicate::operator=(const TBinaryPredicate& other27) {
  col = other27.col;
  op = other27.op;
  value = other27.value;
  __isset = other27.__isset;
  return *this;
}
TBinaryPredicate& TBinaryPredicate::operator=(TBinaryPredicate&& other28) {
  col = std::move(other28.col);
  op = std::move(other28.op);
  value = std::move(other28.value);
  __isset = std::move(other28.__isset);
  return *this;
}
void TBinaryPredicate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TBinaryPredicate(";
  out << "col="; (__isset.col ? (out << to_string(col)) : (out << "<null>"));
  out << ", " << "op="; (__isset.op ? (out << to_string(op)) : (out << "<null>"));
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ")";
}


TPrepareParams::~TPrepareParams() throw() {
}


void TPrepareParams::__set_table_name(const std::string& val) {
  this->table_name = val;
__isset.table_name = true;
}

void TPrepareParams::__set_init_string(const std::string& val) {
  this->init_string = val;
__isset.init_string = true;
}

void TPrepareParams::__set_predicates(const std::vector<std::vector<TBinaryPredicate> > & val) {
  this->predicates = val;
__isset.predicates = true;
}
std::ostream& operator<<(std::ostream& out, const TPrepareParams& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPrepareParams &a, TPrepareParams &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.init_string, b.init_string);
  swap(a.predicates, b.predicates);
  swap(a.__isset, b.__isset);
}

TPrepareParams::TPrepareParams(const TPrepareParams& other41) {
  table_name = other41.table_name;
  init_string = other41.init_string;
  predicates = other41.predicates;
  __isset = other41.__isset;
}
TPrepareParams::TPrepareParams( TPrepareParams&& other42) {
  table_name = std::move(other42.table_name);
  init_string = std::move(other42.init_string);
  predicates = std::move(other42.predicates);
  __isset = std::move(other42.__isset);
}
TPrepareParams& TPrepareParams::operator=(const TPrepareParams& other43) {
  table_name = other43.table_name;
  init_string = other43.init_string;
  predicates = other43.predicates;
  __isset = other43.__isset;
  return *this;
}
TPrepareParams& TPrepareParams::operator=(TPrepareParams&& other44) {
  table_name = std::move(other44.table_name);
  init_string = std::move(other44.init_string);
  predicates = std::move(other44.predicates);
  __isset = std::move(other44.__isset);
  return *this;
}
void TPrepareParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPrepareParams(";
  out << "table_name="; (__isset.table_name ? (out << to_string(table_name)) : (out << "<null>"));
  out << ", " << "init_string="; (__isset.init_string ? (out << to_string(init_string)) : (out << "<null>"));
  out << ", " << "predicates="; (__isset.predicates ? (out << to_string(predicates)) : (out << "<null>"));
  out << ")";
}


TPrepareResult::~TPrepareResult() throw() {
}


void TPrepareResult::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
}

void TPrepareResult::__set_num_rows_estimate(const int64_t val) {
  this->num_rows_estimate = val;
__isset.num_rows_estimate = true;
}

void TPrepareResult::__set_accepted_conjuncts(const std::vector<int32_t> & val) {
  this->accepted_conjuncts = val;
__isset.accepted_conjuncts = true;
}
std::ostream& operator<<(std::ostream& out, const TPrepareResult& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPrepareResult &a, TPrepareResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.num_rows_estimate, b.num_rows_estimate);
  swap(a.accepted_conjuncts, b.accepted_conjuncts);
  swap(a.__isset, b.__isset);
}

TPrepareResult::TPrepareResult(const TPrepareResult& other51) {
  status = other51.status;
  num_rows_estimate = other51.num_rows_estimate;
  accepted_conjuncts = other51.accepted_conjuncts;
  __isset = other51.__isset;
}
TPrepareResult::TPrepareResult( TPrepareResult&& other52) {
  status = std::move(other52.status);
  num_rows_estimate = std::move(other52.num_rows_estimate);
  accepted_conjuncts = std::move(other52.accepted_conjuncts);
  __isset = std::move(other52.__isset);
}
TPrepareResult& TPrepareResult::operator=(const TPrepareResult& other53) {
  status = other53.status;
  num_rows_estimate = other53.num_rows_estimate;
  accepted_conjuncts = other53.accepted_conjuncts;
  __isset = other53.__isset;
  return *this;
}
TPrepareResult& TPrepareResult::operator=(TPrepareResult&& other54) {
  status = std::move(other54.status);
  num_rows_estimate = std::move(other54.num_rows_estimate);
  accepted_conjuncts = std::move(other54.accepted_conjuncts);
  __isset = std::move(other54.__isset);
  return *this;
}
void TPrepareResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPrepareResult(";
  out << "status=" << to_string(status);
  out << ", " << "num_rows_estimate="; (__isset.num_rows_estimate ? (out << to_string(num_rows_estimate)) : (out << "<null>"));
  out << ", " << "accepted_conjuncts="; (__isset.accepted_conjuncts ? (out << to_string(accepted_conjuncts)) : (out << "<null>"));
  out << ")";
}


TOpenParams::~TOpenParams() throw() {
}


void TOpenParams::__set_query_id(const  ::impala::TUniqueId& val) {
  this->query_id = val;
__isset.query_id = true;
}

void TOpenParams::__set_table_name(const std::string& val) {
  this->table_name = val;
__isset.table_name = true;
}

void TOpenParams::__set_init_string(const std::string& val) {
  this->init_string = val;
__isset.init_string = true;
}

void TOpenParams::__set_authenticated_user_name(const std::string& val) {
  this->authenticated_user_name = val;
__isset.authenticated_user_name = true;
}

void TOpenParams::__set_row_schema(const TTableSchema& val) {
  this->row_schema = val;
__isset.row_schema = true;
}

void TOpenParams::__set_batch_size(const int32_t val) {
  this->batch_size = val;
__isset.batch_size = true;
}

void TOpenParams::__set_predicates(const std::vector<std::vector<TBinaryPredicate> > & val) {
  this->predicates = val;
__isset.predicates = true;
}

void TOpenParams::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}
std::ostream& operator<<(std::ostream& out, const TOpenParams& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TOpenParams &a, TOpenParams &b) {
  using ::std::swap;
  swap(a.query_id, b.query_id);
  swap(a.table_name, b.table_name);
  swap(a.init_string, b.init_string);
  swap(a.authenticated_user_name, b.authenticated_user_name);
  swap(a.row_schema, b.row_schema);
  swap(a.batch_size, b.batch_size);
  swap(a.predicates, b.predicates);
  swap(a.limit, b.limit);
  swap(a.__isset, b.__isset);
}

TOpenParams::TOpenParams(const TOpenParams& other67) {
  query_id = other67.query_id;
  table_name = other67.table_name;
  init_string = other67.init_string;
  authenticated_user_name = other67.authenticated_user_name;
  row_schema = other67.row_schema;
  batch_size = other67.batch_size;
  predicates = other67.predicates;
  limit = other67.limit;
  __isset = other67.__isset;
}
TOpenParams::TOpenParams( TOpenParams&& other68) {
  query_id = std::move(other68.query_id);
  table_name = std::move(other68.table_name);
  init_string = std::move(other68.init_string);
  authenticated_user_name = std::move(other68.authenticated_user_name);
  row_schema = std::move(other68.row_schema);
  batch_size = std::move(other68.batch_size);
  predicates = std::move(other68.predicates);
  limit = std::move(other68.limit);
  __isset = std::move(other68.__isset);
}
TOpenParams& TOpenParams::operator=(const TOpenParams& other69) {
  query_id = other69.query_id;
  table_name = other69.table_name;
  init_string = other69.init_string;
  authenticated_user_name = other69.authenticated_user_name;
  row_schema = other69.row_schema;
  batch_size = other69.batch_size;
  predicates = other69.predicates;
  limit = other69.limit;
  __isset = other69.__isset;
  return *this;
}
TOpenParams& TOpenParams::operator=(TOpenParams&& other70) {
  query_id = std::move(other70.query_id);
  table_name = std::move(other70.table_name);
  init_string = std::move(other70.init_string);
  authenticated_user_name = std::move(other70.authenticated_user_name);
  row_schema = std::move(other70.row_schema);
  batch_size = std::move(other70.batch_size);
  predicates = std::move(other70.predicates);
  limit = std::move(other70.limit);
  __isset = std::move(other70.__isset);
  return *this;
}
void TOpenParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOpenParams(";
  out << "query_id="; (__isset.query_id ? (out << to_string(query_id)) : (out << "<null>"));
  out << ", " << "table_name="; (__isset.table_name ? (out << to_string(table_name)) : (out << "<null>"));
  out << ", " << "init_string="; (__isset.init_string ? (out << to_string(init_string)) : (out << "<null>"));
  out << ", " << "authenticated_user_name="; (__isset.authenticated_user_name ? (out << to_string(authenticated_user_name)) : (out << "<null>"));
  out << ", " << "row_schema="; (__isset.row_schema ? (out << to_string(row_schema)) : (out << "<null>"));
  out << ", " << "batch_size="; (__isset.batch_size ? (out << to_string(batch_size)) : (out << "<null>"));
  out << ", " << "predicates="; (__isset.predicates ? (out << to_string(predicates)) : (out << "<null>"));
  out << ", " << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ")";
}


TOpenResult::~TOpenResult() throw() {
}


void TOpenResult::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
}

void TOpenResult::__set_scan_handle(const std::string& val) {
  this->scan_handle = val;
__isset.scan_handle = true;
}
std::ostream& operator<<(std::ostream& out, const TOpenResult& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TOpenResult &a, TOpenResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.scan_handle, b.scan_handle);
  swap(a.__isset, b.__isset);
}

TOpenResult::TOpenResult(const TOpenResult& other71) {
  status = other71.status;
  scan_handle = other71.scan_handle;
  __isset = other71.__isset;
}
TOpenResult::TOpenResult( TOpenResult&& other72) {
  status = std::move(other72.status);
  scan_handle = std::move(other72.scan_handle);
  __isset = std::move(other72.__isset);
}
TOpenResult& TOpenResult::operator=(const TOpenResult& other73) {
  status = other73.status;
  scan_handle = other73.scan_handle;
  __isset = other73.__isset;
  return *this;
}
TOpenResult& TOpenResult::operator=(TOpenResult&& other74) {
  status = std::move(other74.status);
  scan_handle = std::move(other74.scan_handle);
  __isset = std::move(other74.__isset);
  return *this;
}
void TOpenResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TOpenResult(";
  out << "status=" << to_string(status);
  out << ", " << "scan_handle="; (__isset.scan_handle ? (out << to_string(scan_handle)) : (out << "<null>"));
  out << ")";
}


TGetNextParams::~TGetNextParams() throw() {
}


void TGetNextParams::__set_scan_handle(const std::string& val) {
  this->scan_handle = val;
__isset.scan_handle = true;
}
std::ostream& operator<<(std::ostream& out, const TGetNextParams& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TGetNextParams &a, TGetNextParams &b) {
  using ::std::swap;
  swap(a.scan_handle, b.scan_handle);
  swap(a.__isset, b.__isset);
}

TGetNextParams::TGetNextParams(const TGetNextParams& other75) {
  scan_handle = other75.scan_handle;
  __isset = other75.__isset;
}
TGetNextParams::TGetNextParams( TGetNextParams&& other76) {
  scan_handle = std::move(other76.scan_handle);
  __isset = std::move(other76.__isset);
}
TGetNextParams& TGetNextParams::operator=(const TGetNextParams& other77) {
  scan_handle = other77.scan_handle;
  __isset = other77.__isset;
  return *this;
}
TGetNextParams& TGetNextParams::operator=(TGetNextParams&& other78) {
  scan_handle = std::move(other78.scan_handle);
  __isset = std::move(other78.__isset);
  return *this;
}
void TGetNextParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetNextParams(";
  out << "scan_handle="; (__isset.scan_handle ? (out << to_string(scan_handle)) : (out << "<null>"));
  out << ")";
}


TGetNextResult::~TGetNextResult() throw() {
}


void TGetNextResult::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
}

void TGetNextResult::__set_eos(const bool val) {
  this->eos = val;
__isset.eos = true;
}

void TGetNextResult::__set_rows(const TRowBatch& val) {
  this->rows = val;
__isset.rows = true;
}
std::ostream& operator<<(std::ostream& out, const TGetNextResult& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TGetNextResult &a, TGetNextResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.eos, b.eos);
  swap(a.rows, b.rows);
  swap(a.__isset, b.__isset);
}

TGetNextResult::TGetNextResult(const TGetNextResult& other79) {
  status = other79.status;
  eos = other79.eos;
  rows = other79.rows;
  __isset = other79.__isset;
}
TGetNextResult::TGetNextResult( TGetNextResult&& other80) {
  status = std::move(other80.status);
  eos = std::move(other80.eos);
  rows = std::move(other80.rows);
  __isset = std::move(other80.__isset);
}
TGetNextResult& TGetNextResult::operator=(const TGetNextResult& other81) {
  status = other81.status;
  eos = other81.eos;
  rows = other81.rows;
  __isset = other81.__isset;
  return *this;
}
TGetNextResult& TGetNextResult::operator=(TGetNextResult&& other82) {
  status = std::move(other82.status);
  eos = std::move(other82.eos);
  rows = std::move(other82.rows);
  __isset = std::move(other82.__isset);
  return *this;
}
void TGetNextResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TGetNextResult(";
  out << "status=" << to_string(status);
  out << ", " << "eos="; (__isset.eos ? (out << to_string(eos)) : (out << "<null>"));
  out << ", " << "rows="; (__isset.rows ? (out << to_string(rows)) : (out << "<null>"));
  out << ")";
}


TCloseParams::~TCloseParams() throw() {
}


void TCloseParams::__set_scan_handle(const std::string& val) {
  this->scan_handle = val;
__isset.scan_handle = true;
}
std::ostream& operator<<(std::ostream& out, const TCloseParams& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCloseParams &a, TCloseParams &b) {
  using ::std::swap;
  swap(a.scan_handle, b.scan_handle);
  swap(a.__isset, b.__isset);
}

TCloseParams::TCloseParams(const TCloseParams& other83) {
  scan_handle = other83.scan_handle;
  __isset = other83.__isset;
}
TCloseParams::TCloseParams( TCloseParams&& other84) {
  scan_handle = std::move(other84.scan_handle);
  __isset = std::move(other84.__isset);
}
TCloseParams& TCloseParams::operator=(const TCloseParams& other85) {
  scan_handle = other85.scan_handle;
  __isset = other85.__isset;
  return *this;
}
TCloseParams& TCloseParams::operator=(TCloseParams&& other86) {
  scan_handle = std::move(other86.scan_handle);
  __isset = std::move(other86.__isset);
  return *this;
}
void TCloseParams::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloseParams(";
  out << "scan_handle="; (__isset.scan_handle ? (out << to_string(scan_handle)) : (out << "<null>"));
  out << ")";
}


TCloseResult::~TCloseResult() throw() {
}


void TCloseResult::__set_status(const  ::impala::TStatus& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const TCloseResult& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCloseResult &a, TCloseResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
}

TCloseResult::TCloseResult(const TCloseResult& other87) {
  status = other87.status;
}
TCloseResult::TCloseResult( TCloseResult&& other88) {
  status = std::move(other88.status);
}
TCloseResult& TCloseResult::operator=(const TCloseResult& other89) {
  status = other89.status;
  return *this;
}
TCloseResult& TCloseResult::operator=(TCloseResult&& other90) {
  status = std::move(other90.status);
  return *this;
}
void TCloseResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCloseResult(";
  out << "status=" << to_string(status);
  out << ")";
}

}} // namespace
