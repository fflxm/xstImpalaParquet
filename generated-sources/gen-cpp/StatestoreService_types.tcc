/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef StatestoreService_TYPES_TCC
#define StatestoreService_TYPES_TCC

#include "Status_types.tcc"
#include "Types_types.tcc"
#include "StatestoreService_types.h"

namespace impala {

template <class Protocol_>
uint32_t THeavyMemoryQuery::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_memory_consumed = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->memory_consumed);
          isset_memory_consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryId.read(iprot);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_memory_consumed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THeavyMemoryQuery::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THeavyMemoryQuery");

  xfer += oprot->writeFieldBegin("memory_consumed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->memory_consumed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->queryId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPoolStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_admitted_running = false;
  bool isset_num_queued = false;
  bool isset_backend_mem_reserved = false;
  bool isset_heavy_memory_queries = false;
  bool isset_min_memory_consumed = false;
  bool isset_max_memory_consumed = false;
  bool isset_total_memory_consumed = false;
  bool isset_num_running = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_admitted_running);
          isset_num_admitted_running = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_queued);
          isset_num_queued = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->backend_mem_reserved);
          isset_backend_mem_reserved = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->heavy_memory_queries.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->heavy_memory_queries.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->heavy_memory_queries[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_heavy_memory_queries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_memory_consumed);
          isset_min_memory_consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_memory_consumed);
          isset_max_memory_consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_memory_consumed);
          isset_total_memory_consumed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_running);
          isset_num_running = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_admitted_running)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_queued)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_backend_mem_reserved)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_heavy_memory_queries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_min_memory_consumed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_memory_consumed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_total_memory_consumed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_running)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPoolStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPoolStats");

  xfer += oprot->writeFieldBegin("num_admitted_running", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->num_admitted_running);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_queued", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->num_queued);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("backend_mem_reserved", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->backend_mem_reserved);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("heavy_memory_queries", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->heavy_memory_queries.size()));
    std::vector<THeavyMemoryQuery> ::const_iterator _iter9;
    for (_iter9 = this->heavy_memory_queries.begin(); _iter9 != this->heavy_memory_queries.end(); ++_iter9)
    {
      xfer += (*_iter9).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("min_memory_consumed", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->min_memory_consumed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_memory_consumed", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->max_memory_consumed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_memory_consumed", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->total_memory_consumed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_running", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->num_running);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THostStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_mem_reserved = false;
  bool isset_mem_admitted = false;
  bool isset_num_admitted = false;
  bool isset_slots_in_use = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_reserved);
          isset_mem_reserved = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_admitted);
          isset_mem_admitted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_admitted);
          isset_num_admitted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->slots_in_use);
          isset_slots_in_use = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_mem_reserved)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mem_admitted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_admitted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_slots_in_use)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THostStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THostStats");

  xfer += oprot->writeFieldBegin("mem_reserved", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->mem_reserved);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_admitted", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->mem_admitted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_admitted", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_admitted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slots_in_use", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->slots_in_use);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPerHostStatsUpdateElement::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host_addr = false;
  bool isset_stats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_addr);
          isset_host_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          isset_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host_addr)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_stats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPerHostStatsUpdateElement::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPerHostStatsUpdateElement");

  xfer += oprot->writeFieldBegin("host_addr", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->stats.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPerHostStatsUpdate::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_per_host_stats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->per_host_stats.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->per_host_stats.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->per_host_stats[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_per_host_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_per_host_stats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPerHostStatsUpdate::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPerHostStatsUpdate");

  xfer += oprot->writeFieldBegin("per_host_stats", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->per_host_stats.size()));
    std::vector<TPerHostStatsUpdateElement> ::const_iterator _iter27;
    for (_iter27 = this->per_host_stats.begin(); _iter27 != this->per_host_stats.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTopicItem::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_value = false;
  bool isset_deleted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->deleted);
          isset_deleted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deleted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTopicItem::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTopicItem");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleted", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->deleted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTopicDelta::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topic_name = false;
  bool isset_topic_entries = false;
  bool isset_is_delta = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic_name);
          isset_topic_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_entries.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->topic_entries.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->topic_entries[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_delta);
          isset_is_delta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->from_version);
          this->__isset.from_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->to_version);
          this->__isset.to_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_subscriber_topic_version);
          this->__isset.min_subscriber_topic_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->clear_topic_entries);
          this->__isset.clear_topic_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topic_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_delta)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTopicDelta::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTopicDelta");

  xfer += oprot->writeFieldBegin("topic_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topic_entries", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_entries.size()));
    std::vector<TTopicItem> ::const_iterator _iter41;
    for (_iter41 = this->topic_entries.begin(); _iter41 != this->topic_entries.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_delta", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_delta);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.from_version) {
    xfer += oprot->writeFieldBegin("from_version", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->from_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.to_version) {
    xfer += oprot->writeFieldBegin("to_version", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->to_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_subscriber_topic_version) {
    xfer += oprot->writeFieldBegin("min_subscriber_topic_version", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->min_subscriber_topic_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clear_topic_entries) {
    xfer += oprot->writeFieldBegin("clear_topic_entries", ::apache::thrift::protocol::T_BOOL, 7);
    xfer += oprot->writeBool(this->clear_topic_entries);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTopicRegistration::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_topic_name = false;
  bool isset_is_transient = false;
  bool isset_populate_min_subscriber_topic_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->topic_name);
          isset_topic_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_transient);
          isset_is_transient = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->populate_min_subscriber_topic_version);
          isset_populate_min_subscriber_topic_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->filter_prefix);
          this->__isset.filter_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_topic_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_transient)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_populate_min_subscriber_topic_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTopicRegistration::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTopicRegistration");

  xfer += oprot->writeFieldBegin("topic_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->topic_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_transient", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->is_transient);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("populate_min_subscriber_topic_version", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->populate_min_subscriber_topic_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filter_prefix) {
    xfer += oprot->writeFieldBegin("filter_prefix", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->filter_prefix);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TRegisterSubscriberRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_subscriber_id = false;
  bool isset_subscriber_location = false;
  bool isset_topic_registrations = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->protocol_version = (StatestoreServiceVersion::type)ecast50;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->subscriber_id);
          isset_subscriber_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->subscriber_location.read(iprot);
          isset_subscriber_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_registrations.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->topic_registrations.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += this->topic_registrations[_i55].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_registrations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_subscriber_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_subscriber_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_registrations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TRegisterSubscriberRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRegisterSubscriberRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("subscriber_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->subscriber_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("subscriber_location", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->subscriber_location.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topic_registrations", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_registrations.size()));
    std::vector<TTopicRegistration> ::const_iterator _iter56;
    for (_iter56 = this->topic_registrations.begin(); _iter56 != this->topic_registrations.end(); ++_iter56)
    {
      xfer += (*_iter56).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TRegisterSubscriberResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->registration_id.read(iprot);
          this->__isset.registration_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TRegisterSubscriberResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRegisterSubscriberResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.registration_id) {
    xfer += oprot->writeFieldBegin("registration_id", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->registration_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateStateRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_protocol_version = false;
  bool isset_topic_deltas = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->protocol_version = (StatestoreServiceVersion::type)ecast65;
          isset_protocol_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->topic_deltas.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              std::string _key71;
              xfer += iprot->readString(_key71);
              TTopicDelta& _val72 = this->topic_deltas[_key71];
              xfer += _val72.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_topic_deltas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->registration_id.read(iprot);
          this->__isset.registration_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_protocol_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_deltas)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateStateRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateStateRequest");

  xfer += oprot->writeFieldBegin("protocol_version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->protocol_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topic_deltas", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_deltas.size()));
    std::map<std::string, TTopicDelta> ::const_iterator _iter73;
    for (_iter73 = this->topic_deltas.begin(); _iter73 != this->topic_deltas.end(); ++_iter73)
    {
      xfer += oprot->writeString(_iter73->first);
      xfer += _iter73->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.registration_id) {
    xfer += oprot->writeFieldBegin("registration_id", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->registration_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateStateResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_topic_updates = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->topic_updates.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->topic_updates.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->topic_updates[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_topic_updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->skipped);
          this->__isset.skipped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_topic_updates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TUpdateStateResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TUpdateStateResponse");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topic_updates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->topic_updates.size()));
    std::vector<TTopicDelta> ::const_iterator _iter83;
    for (_iter83 = this->topic_updates.begin(); _iter83 != this->topic_updates.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.skipped) {
    xfer += oprot->writeFieldBegin("skipped", ::apache::thrift::protocol::T_BOOL, 3);
    xfer += oprot->writeBool(this->skipped);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THeartbeatRequest::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->registration_id.read(iprot);
          this->__isset.registration_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t THeartbeatRequest::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THeartbeatRequest");

  if (this->__isset.registration_id) {
    xfer += oprot->writeFieldBegin("registration_id", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->registration_id.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THeartbeatResponse::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t THeartbeatResponse::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THeartbeatResponse");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
