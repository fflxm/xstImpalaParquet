/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlanNodes_TYPES_H
#define PlanNodes_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "CatalogObjects_types.h"
#include "Data_types.h"
#include "ExecStats_types.h"
#include "Exprs_types.h"
#include "Types_types.h"
#include "ExternalDataSource_types.h"
#include "ResourceProfile_types.h"


namespace impala {

struct TPlanNodeType {
  enum type {
    HDFS_SCAN_NODE = 0,
    HBASE_SCAN_NODE = 1,
    HASH_JOIN_NODE = 2,
    AGGREGATION_NODE = 3,
    SORT_NODE = 4,
    EMPTY_SET_NODE = 5,
    EXCHANGE_NODE = 6,
    UNION_NODE = 7,
    SELECT_NODE = 8,
    NESTED_LOOP_JOIN_NODE = 9,
    DATA_SOURCE_NODE = 10,
    ANALYTIC_EVAL_NODE = 11,
    SINGULAR_ROW_SRC_NODE = 12,
    UNNEST_NODE = 13,
    SUBPLAN_NODE = 14,
    KUDU_SCAN_NODE = 15,
    CARDINALITY_CHECK_NODE = 16,
    MULTI_AGGREGATION_NODE = 17
  };
};

extern const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TPlanNodeType::type& val);

struct TExecNodePhase {
  enum type {
    PREPARE = 0,
    PREPARE_SCANNER = 1,
    OPEN = 2,
    GETNEXT = 3,
    GETNEXT_SCANNER = 4,
    CLOSE = 5,
    SCANNER_ERROR = 6,
    INVALID = 7
  };
};

extern const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TExecNodePhase::type& val);

struct TDebugAction {
  enum type {
    WAIT = 0,
    FAIL = 1,
    INJECT_ERROR_LOG = 2,
    MEM_LIMIT_EXCEEDED = 3,
    SET_DENY_RESERVATION_PROBABILITY = 4,
    DELAY = 5
  };
};

extern const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TDebugAction::type& val);

struct TReplicaPreference {
  enum type {
    CACHE_LOCAL = 0,
    CACHE_RACK = 1,
    DISK_LOCAL = 2,
    DISK_RACK = 3,
    REMOTE = 4
  };
};

extern const std::map<int, const char*> _TReplicaPreference_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TReplicaPreference::type& val);

struct TRuntimeFilterType {
  enum type {
    BLOOM = 0,
    MIN_MAX = 1,
    IN_LIST = 2
  };
};

extern const std::map<int, const char*> _TRuntimeFilterType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterType::type& val);

struct TMinmaxFilteringLevel {
  enum type {
    ROW_GROUP = 1,
    PAGE = 2,
    ROW = 3
  };
};

extern const std::map<int, const char*> _TMinmaxFilteringLevel_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TMinmaxFilteringLevel::type& val);

struct TJoinOp {
  enum type {
    INNER_JOIN = 0,
    LEFT_OUTER_JOIN = 1,
    LEFT_SEMI_JOIN = 2,
    LEFT_ANTI_JOIN = 3,
    NULL_AWARE_LEFT_ANTI_JOIN = 4,
    RIGHT_OUTER_JOIN = 5,
    RIGHT_SEMI_JOIN = 6,
    RIGHT_ANTI_JOIN = 7,
    FULL_OUTER_JOIN = 8,
    CROSS_JOIN = 9
  };
};

extern const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TJoinOp::type& val);

struct TSortType {
  enum type {
    TOTAL = 0,
    TOPN = 1,
    PARTIAL = 2,
    PARTITIONED_TOPN = 3
  };
};

extern const std::map<int, const char*> _TSortType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TSortType::type& val);

struct TAnalyticWindowType {
  enum type {
    RANGE = 0,
    ROWS = 1
  };
};

extern const std::map<int, const char*> _TAnalyticWindowType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAnalyticWindowType::type& val);

struct TAnalyticWindowBoundaryType {
  enum type {
    CURRENT_ROW = 0,
    PRECEDING = 1,
    FOLLOWING = 2
  };
};

extern const std::map<int, const char*> _TAnalyticWindowBoundaryType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TAnalyticWindowBoundaryType::type& val);

class TRuntimeFilterTargetDesc;

class TRuntimeFilterDesc;

class THdfsFileSplit;

class THBaseKeyRange;

class TFileSplitGeneratorSpec;

class TScanRange;

class TOverlapPredicateDesc;

class THdfsScanNode;

class TDataSourceScanNode;

class THBaseFilter;

class THBaseScanNode;

class TKuduScanNode;

class TEqJoinCondition;

class THashJoinNode;

class TNestedLoopJoinNode;

class TJoinNode;

class TAggregator;

class TAggregationNode;

class TSortInfo;

class TSortNode;

class TAnalyticWindowBoundary;

class TAnalyticWindow;

class TAnalyticNode;

class TUnionNode;

class TExchangeNode;

class TUnnestNode;

class TCardinalityCheckNode;

class TPipelineMembership;

class TPlanNode;

class TPlan;

typedef struct _TRuntimeFilterTargetDesc__isset {
  _TRuntimeFilterTargetDesc__isset() : node_id(false), kudu_col_name(false), kudu_col_type(false), low_value(false), high_value(false), is_min_max_value_present(false), is_column_in_data_file(false) {}
  bool node_id :1;
  bool kudu_col_name :1;
  bool kudu_col_type :1;
  bool low_value :1;
  bool high_value :1;
  bool is_min_max_value_present :1;
  bool is_column_in_data_file :1;
} _TRuntimeFilterTargetDesc__isset;

class TRuntimeFilterTargetDesc {
 public:

  TRuntimeFilterTargetDesc(const TRuntimeFilterTargetDesc&);
  TRuntimeFilterTargetDesc(TRuntimeFilterTargetDesc&&);
  TRuntimeFilterTargetDesc& operator=(const TRuntimeFilterTargetDesc&);
  TRuntimeFilterTargetDesc& operator=(TRuntimeFilterTargetDesc&&);
  TRuntimeFilterTargetDesc() : node_id(0), is_bound_by_partition_columns(0), is_local_target(0), kudu_col_name(), is_min_max_value_present(0), is_column_in_data_file(0) {
  }

  virtual ~TRuntimeFilterTargetDesc() throw();
   ::impala::TPlanNodeId node_id;
   ::impala::TExpr target_expr;
  bool is_bound_by_partition_columns;
  std::vector< ::impala::TSlotId>  target_expr_slotids;
  bool is_local_target;
  std::string kudu_col_name;
   ::impala::TColumnType kudu_col_type;
   ::impala::TColumnValue low_value;
   ::impala::TColumnValue high_value;
  bool is_min_max_value_present;
  bool is_column_in_data_file;

  _TRuntimeFilterTargetDesc__isset __isset;

  void __set_node_id(const  ::impala::TPlanNodeId val);

  void __set_target_expr(const  ::impala::TExpr& val);

  void __set_is_bound_by_partition_columns(const bool val);

  void __set_target_expr_slotids(const std::vector< ::impala::TSlotId> & val);

  void __set_is_local_target(const bool val);

  void __set_kudu_col_name(const std::string& val);

  void __set_kudu_col_type(const  ::impala::TColumnType& val);

  void __set_low_value(const  ::impala::TColumnValue& val);

  void __set_high_value(const  ::impala::TColumnValue& val);

  void __set_is_min_max_value_present(const bool val);

  void __set_is_column_in_data_file(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRuntimeFilterTargetDesc &a, TRuntimeFilterTargetDesc &b);

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterTargetDesc& obj);

typedef struct _TRuntimeFilterDesc__isset {
  _TRuntimeFilterDesc__isset() : ndv_estimate(false), filter_size_bytes(false), src_node_id(false) {}
  bool ndv_estimate :1;
  bool filter_size_bytes :1;
  bool src_node_id :1;
} _TRuntimeFilterDesc__isset;

class TRuntimeFilterDesc {
 public:

  TRuntimeFilterDesc(const TRuntimeFilterDesc&);
  TRuntimeFilterDesc(TRuntimeFilterDesc&&);
  TRuntimeFilterDesc& operator=(const TRuntimeFilterDesc&);
  TRuntimeFilterDesc& operator=(TRuntimeFilterDesc&&);
  TRuntimeFilterDesc() : filter_id(0), is_broadcast_join(0), has_local_targets(0), has_remote_targets(0), applied_on_partition_columns(0), ndv_estimate(0), type((TRuntimeFilterType::type)0), compareOp(( ::impala::extdatasource::TComparisonOp::type)0), filter_size_bytes(0), src_node_id(0) {
  }

  virtual ~TRuntimeFilterDesc() throw();
  int32_t filter_id;
   ::impala::TExpr src_expr;
  std::vector<TRuntimeFilterTargetDesc>  targets;
  std::map< ::impala::TPlanNodeId, int32_t>  planid_to_target_ndx;
  bool is_broadcast_join;
  bool has_local_targets;
  bool has_remote_targets;
  bool applied_on_partition_columns;
  int64_t ndv_estimate;
  TRuntimeFilterType::type type;
   ::impala::extdatasource::TComparisonOp::type compareOp;
  int64_t filter_size_bytes;
   ::impala::TPlanNodeId src_node_id;

  _TRuntimeFilterDesc__isset __isset;

  void __set_filter_id(const int32_t val);

  void __set_src_expr(const  ::impala::TExpr& val);

  void __set_targets(const std::vector<TRuntimeFilterTargetDesc> & val);

  void __set_planid_to_target_ndx(const std::map< ::impala::TPlanNodeId, int32_t> & val);

  void __set_is_broadcast_join(const bool val);

  void __set_has_local_targets(const bool val);

  void __set_has_remote_targets(const bool val);

  void __set_applied_on_partition_columns(const bool val);

  void __set_ndv_estimate(const int64_t val);

  void __set_type(const TRuntimeFilterType::type val);

  void __set_compareOp(const  ::impala::extdatasource::TComparisonOp::type val);

  void __set_filter_size_bytes(const int64_t val);

  void __set_src_node_id(const  ::impala::TPlanNodeId val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TRuntimeFilterDesc &a, TRuntimeFilterDesc &b);

std::ostream& operator<<(std::ostream& out, const TRuntimeFilterDesc& obj);


class THdfsFileSplit {
 public:

  THdfsFileSplit(const THdfsFileSplit&);
  THdfsFileSplit(THdfsFileSplit&&);
  THdfsFileSplit& operator=(const THdfsFileSplit&);
  THdfsFileSplit& operator=(THdfsFileSplit&&);
  THdfsFileSplit() : relative_path(), offset(0), length(0), partition_id(0), file_length(0), file_compression(( ::impala::THdfsCompression::type)0), mtime(0), partition_path_hash(0) {
  }

  virtual ~THdfsFileSplit() throw();
  std::string relative_path;
  int64_t offset;
  int64_t length;
  int64_t partition_id;
  int64_t file_length;
   ::impala::THdfsCompression::type file_compression;
  int64_t mtime;
  int32_t partition_path_hash;

  void __set_relative_path(const std::string& val);

  void __set_offset(const int64_t val);

  void __set_length(const int64_t val);

  void __set_partition_id(const int64_t val);

  void __set_file_length(const int64_t val);

  void __set_file_compression(const  ::impala::THdfsCompression::type val);

  void __set_mtime(const int64_t val);

  void __set_partition_path_hash(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsFileSplit &a, THdfsFileSplit &b);

std::ostream& operator<<(std::ostream& out, const THdfsFileSplit& obj);

typedef struct _THBaseKeyRange__isset {
  _THBaseKeyRange__isset() : startKey(false), stopKey(false) {}
  bool startKey :1;
  bool stopKey :1;
} _THBaseKeyRange__isset;

class THBaseKeyRange {
 public:

  THBaseKeyRange(const THBaseKeyRange&);
  THBaseKeyRange(THBaseKeyRange&&);
  THBaseKeyRange& operator=(const THBaseKeyRange&);
  THBaseKeyRange& operator=(THBaseKeyRange&&);
  THBaseKeyRange() : startKey(), stopKey() {
  }

  virtual ~THBaseKeyRange() throw();
  std::string startKey;
  std::string stopKey;

  _THBaseKeyRange__isset __isset;

  void __set_startKey(const std::string& val);

  void __set_stopKey(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THBaseKeyRange &a, THBaseKeyRange &b);

std::ostream& operator<<(std::ostream& out, const THBaseKeyRange& obj);


class TFileSplitGeneratorSpec {
 public:

  TFileSplitGeneratorSpec(const TFileSplitGeneratorSpec&);
  TFileSplitGeneratorSpec(TFileSplitGeneratorSpec&&);
  TFileSplitGeneratorSpec& operator=(const TFileSplitGeneratorSpec&);
  TFileSplitGeneratorSpec& operator=(TFileSplitGeneratorSpec&&);
  TFileSplitGeneratorSpec() : max_block_size(0), is_splittable(0), partition_id(0), partition_path_hash(0) {
  }

  virtual ~TFileSplitGeneratorSpec() throw();
   ::impala::THdfsFileDesc file_desc;
  int64_t max_block_size;
  bool is_splittable;
  int64_t partition_id;
  int32_t partition_path_hash;

  void __set_file_desc(const  ::impala::THdfsFileDesc& val);

  void __set_max_block_size(const int64_t val);

  void __set_is_splittable(const bool val);

  void __set_partition_id(const int64_t val);

  void __set_partition_path_hash(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TFileSplitGeneratorSpec &a, TFileSplitGeneratorSpec &b);

std::ostream& operator<<(std::ostream& out, const TFileSplitGeneratorSpec& obj);

typedef struct _TScanRange__isset {
  _TScanRange__isset() : hdfs_file_split(false), hbase_key_range(false), kudu_scan_token(false), file_metadata(false) {}
  bool hdfs_file_split :1;
  bool hbase_key_range :1;
  bool kudu_scan_token :1;
  bool file_metadata :1;
} _TScanRange__isset;

class TScanRange {
 public:

  TScanRange(const TScanRange&);
  TScanRange(TScanRange&&);
  TScanRange& operator=(const TScanRange&);
  TScanRange& operator=(TScanRange&&);
  TScanRange() : kudu_scan_token(), file_metadata() {
  }

  virtual ~TScanRange() throw();
  THdfsFileSplit hdfs_file_split;
  THBaseKeyRange hbase_key_range;
  std::string kudu_scan_token;
  std::string file_metadata;

  _TScanRange__isset __isset;

  void __set_hdfs_file_split(const THdfsFileSplit& val);

  void __set_hbase_key_range(const THBaseKeyRange& val);

  void __set_kudu_scan_token(const std::string& val);

  void __set_file_metadata(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TScanRange &a, TScanRange &b);

std::ostream& operator<<(std::ostream& out, const TScanRange& obj);


class TOverlapPredicateDesc {
 public:

  TOverlapPredicateDesc(const TOverlapPredicateDesc&);
  TOverlapPredicateDesc(TOverlapPredicateDesc&&);
  TOverlapPredicateDesc& operator=(const TOverlapPredicateDesc&);
  TOverlapPredicateDesc& operator=(TOverlapPredicateDesc&&);
  TOverlapPredicateDesc() : filter_id(0), slot_index(0) {
  }

  virtual ~TOverlapPredicateDesc() throw();
  int32_t filter_id;
  int32_t slot_index;

  void __set_filter_id(const int32_t val);

  void __set_slot_index(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TOverlapPredicateDesc &a, TOverlapPredicateDesc &b);

std::ostream& operator<<(std::ostream& out, const TOverlapPredicateDesc& obj);

typedef struct _THdfsScanNode__isset {
  _THdfsScanNode__isset() : collection_conjuncts(false), replica_preference(false), random_replica(false), skip_header_line_count(false), use_mt_scan_node(false), stats_conjuncts(false), stats_tuple_id(false), dictionary_filter_conjuncts(false), parquet_count_star_slot_offset(false), is_partition_key_scan(false), overlap_predicate_descs(false) {}
  bool collection_conjuncts :1;
  bool replica_preference :1;
  bool random_replica :1;
  bool skip_header_line_count :1;
  bool use_mt_scan_node :1;
  bool stats_conjuncts :1;
  bool stats_tuple_id :1;
  bool dictionary_filter_conjuncts :1;
  bool parquet_count_star_slot_offset :1;
  bool is_partition_key_scan :1;
  bool overlap_predicate_descs :1;
} _THdfsScanNode__isset;

class THdfsScanNode {
 public:

  THdfsScanNode(const THdfsScanNode&);
  THdfsScanNode(THdfsScanNode&&);
  THdfsScanNode& operator=(const THdfsScanNode&);
  THdfsScanNode& operator=(THdfsScanNode&&);
  THdfsScanNode() : tuple_id(0), replica_preference((TReplicaPreference::type)0), random_replica(0), skip_header_line_count(0), use_mt_scan_node(0), stats_tuple_id(0), parquet_count_star_slot_offset(0), is_partition_key_scan(0) {
  }

  virtual ~THdfsScanNode() throw();
   ::impala::TTupleId tuple_id;
  std::map< ::impala::TTupleId, std::vector< ::impala::TExpr> >  collection_conjuncts;
  TReplicaPreference::type replica_preference;
  bool random_replica;
  int32_t skip_header_line_count;
  bool use_mt_scan_node;
  std::vector< ::impala::TExpr>  stats_conjuncts;
   ::impala::TTupleId stats_tuple_id;
  std::map< ::impala::TSlotId, std::vector<int32_t> >  dictionary_filter_conjuncts;
  int32_t parquet_count_star_slot_offset;
  bool is_partition_key_scan;
  std::set< ::impala::THdfsFileFormat::type>  file_formats;
  std::vector<TOverlapPredicateDesc>  overlap_predicate_descs;

  _THdfsScanNode__isset __isset;

  void __set_tuple_id(const  ::impala::TTupleId val);

  void __set_collection_conjuncts(const std::map< ::impala::TTupleId, std::vector< ::impala::TExpr> > & val);

  void __set_replica_preference(const TReplicaPreference::type val);

  void __set_random_replica(const bool val);

  void __set_skip_header_line_count(const int32_t val);

  void __set_use_mt_scan_node(const bool val);

  void __set_stats_conjuncts(const std::vector< ::impala::TExpr> & val);

  void __set_stats_tuple_id(const  ::impala::TTupleId val);

  void __set_dictionary_filter_conjuncts(const std::map< ::impala::TSlotId, std::vector<int32_t> > & val);

  void __set_parquet_count_star_slot_offset(const int32_t val);

  void __set_is_partition_key_scan(const bool val);

  void __set_file_formats(const std::set< ::impala::THdfsFileFormat::type> & val);

  void __set_overlap_predicate_descs(const std::vector<TOverlapPredicateDesc> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THdfsScanNode &a, THdfsScanNode &b);

std::ostream& operator<<(std::ostream& out, const THdfsScanNode& obj);


class TDataSourceScanNode {
 public:

  TDataSourceScanNode(const TDataSourceScanNode&);
  TDataSourceScanNode(TDataSourceScanNode&&);
  TDataSourceScanNode& operator=(const TDataSourceScanNode&);
  TDataSourceScanNode& operator=(TDataSourceScanNode&&);
  TDataSourceScanNode() : tuple_id(0), init_string() {
  }

  virtual ~TDataSourceScanNode() throw();
   ::impala::TTupleId tuple_id;
   ::impala::TDataSource data_source;
  std::string init_string;
  std::vector<std::vector< ::impala::extdatasource::TBinaryPredicate> >  accepted_predicates;

  void __set_tuple_id(const  ::impala::TTupleId val);

  void __set_data_source(const  ::impala::TDataSource& val);

  void __set_init_string(const std::string& val);

  void __set_accepted_predicates(const std::vector<std::vector< ::impala::extdatasource::TBinaryPredicate> > & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TDataSourceScanNode &a, TDataSourceScanNode &b);

std::ostream& operator<<(std::ostream& out, const TDataSourceScanNode& obj);

typedef struct _THBaseFilter__isset {
  _THBaseFilter__isset() : qualifier(false) {}
  bool qualifier :1;
} _THBaseFilter__isset;

class THBaseFilter {
 public:

  THBaseFilter(const THBaseFilter&);
  THBaseFilter(THBaseFilter&&);
  THBaseFilter& operator=(const THBaseFilter&);
  THBaseFilter& operator=(THBaseFilter&&);
  THBaseFilter() : family(), qualifier(), op_ordinal(0), filter_constant() {
  }

  virtual ~THBaseFilter() throw();
  std::string family;
  std::string qualifier;
  int32_t op_ordinal;
  std::string filter_constant;

  _THBaseFilter__isset __isset;

  void __set_family(const std::string& val);

  void __set_qualifier(const std::string& val);

  void __set_op_ordinal(const int32_t val);

  void __set_filter_constant(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THBaseFilter &a, THBaseFilter &b);

std::ostream& operator<<(std::ostream& out, const THBaseFilter& obj);

typedef struct _THBaseScanNode__isset {
  _THBaseScanNode__isset() : filters(false), suggested_max_caching(false) {}
  bool filters :1;
  bool suggested_max_caching :1;
} _THBaseScanNode__isset;

class THBaseScanNode {
 public:

  THBaseScanNode(const THBaseScanNode&);
  THBaseScanNode(THBaseScanNode&&);
  THBaseScanNode& operator=(const THBaseScanNode&);
  THBaseScanNode& operator=(THBaseScanNode&&);
  THBaseScanNode() : tuple_id(0), table_name(), suggested_max_caching(0) {
  }

  virtual ~THBaseScanNode() throw();
   ::impala::TTupleId tuple_id;
  std::string table_name;
  std::vector<THBaseFilter>  filters;
  int32_t suggested_max_caching;

  _THBaseScanNode__isset __isset;

  void __set_tuple_id(const  ::impala::TTupleId val);

  void __set_table_name(const std::string& val);

  void __set_filters(const std::vector<THBaseFilter> & val);

  void __set_suggested_max_caching(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THBaseScanNode &a, THBaseScanNode &b);

std::ostream& operator<<(std::ostream& out, const THBaseScanNode& obj);

typedef struct _TKuduScanNode__isset {
  _TKuduScanNode__isset() : use_mt_scan_node(false), count_star_slot_offset(false) {}
  bool use_mt_scan_node :1;
  bool count_star_slot_offset :1;
} _TKuduScanNode__isset;

class TKuduScanNode {
 public:

  TKuduScanNode(const TKuduScanNode&);
  TKuduScanNode(TKuduScanNode&&);
  TKuduScanNode& operator=(const TKuduScanNode&);
  TKuduScanNode& operator=(TKuduScanNode&&);
  TKuduScanNode() : tuple_id(0), use_mt_scan_node(0), count_star_slot_offset(0) {
  }

  virtual ~TKuduScanNode() throw();
   ::impala::TTupleId tuple_id;
  bool use_mt_scan_node;
  int32_t count_star_slot_offset;

  _TKuduScanNode__isset __isset;

  void __set_tuple_id(const  ::impala::TTupleId val);

  void __set_use_mt_scan_node(const bool val);

  void __set_count_star_slot_offset(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TKuduScanNode &a, TKuduScanNode &b);

std::ostream& operator<<(std::ostream& out, const TKuduScanNode& obj);


class TEqJoinCondition {
 public:

  TEqJoinCondition(const TEqJoinCondition&);
  TEqJoinCondition(TEqJoinCondition&&);
  TEqJoinCondition& operator=(const TEqJoinCondition&);
  TEqJoinCondition& operator=(TEqJoinCondition&&);
  TEqJoinCondition() : is_not_distinct_from(0) {
  }

  virtual ~TEqJoinCondition() throw();
   ::impala::TExpr left;
   ::impala::TExpr right;
  bool is_not_distinct_from;

  void __set_left(const  ::impala::TExpr& val);

  void __set_right(const  ::impala::TExpr& val);

  void __set_is_not_distinct_from(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TEqJoinCondition &a, TEqJoinCondition &b);

std::ostream& operator<<(std::ostream& out, const TEqJoinCondition& obj);

typedef struct _THashJoinNode__isset {
  _THashJoinNode__isset() : other_join_conjuncts(false), hash_seed(false) {}
  bool other_join_conjuncts :1;
  bool hash_seed :1;
} _THashJoinNode__isset;

class THashJoinNode {
 public:

  THashJoinNode(const THashJoinNode&);
  THashJoinNode(THashJoinNode&&);
  THashJoinNode& operator=(const THashJoinNode&);
  THashJoinNode& operator=(THashJoinNode&&);
  THashJoinNode() : hash_seed(0) {
  }

  virtual ~THashJoinNode() throw();
  std::vector<TEqJoinCondition>  eq_join_conjuncts;
  std::vector< ::impala::TExpr>  other_join_conjuncts;
  int32_t hash_seed;

  _THashJoinNode__isset __isset;

  void __set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val);

  void __set_other_join_conjuncts(const std::vector< ::impala::TExpr> & val);

  void __set_hash_seed(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THashJoinNode &a, THashJoinNode &b);

std::ostream& operator<<(std::ostream& out, const THashJoinNode& obj);

typedef struct _TNestedLoopJoinNode__isset {
  _TNestedLoopJoinNode__isset() : join_conjuncts(false) {}
  bool join_conjuncts :1;
} _TNestedLoopJoinNode__isset;

class TNestedLoopJoinNode {
 public:

  TNestedLoopJoinNode(const TNestedLoopJoinNode&);
  TNestedLoopJoinNode(TNestedLoopJoinNode&&);
  TNestedLoopJoinNode& operator=(const TNestedLoopJoinNode&);
  TNestedLoopJoinNode& operator=(TNestedLoopJoinNode&&);
  TNestedLoopJoinNode() {
  }

  virtual ~TNestedLoopJoinNode() throw();
  std::vector< ::impala::TExpr>  join_conjuncts;

  _TNestedLoopJoinNode__isset __isset;

  void __set_join_conjuncts(const std::vector< ::impala::TExpr> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TNestedLoopJoinNode &a, TNestedLoopJoinNode &b);

std::ostream& operator<<(std::ostream& out, const TNestedLoopJoinNode& obj);

typedef struct _TJoinNode__isset {
  _TJoinNode__isset() : build_tuples(false), nullable_build_tuples(false), hash_join_node(false), nested_loop_join_node(false) {}
  bool build_tuples :1;
  bool nullable_build_tuples :1;
  bool hash_join_node :1;
  bool nested_loop_join_node :1;
} _TJoinNode__isset;

class TJoinNode {
 public:

  TJoinNode(const TJoinNode&);
  TJoinNode(TJoinNode&&);
  TJoinNode& operator=(const TJoinNode&);
  TJoinNode& operator=(TJoinNode&&);
  TJoinNode() : join_op((TJoinOp::type)0) {
  }

  virtual ~TJoinNode() throw();
  TJoinOp::type join_op;
  std::vector< ::impala::TTupleId>  build_tuples;
  std::vector<bool>  nullable_build_tuples;
  THashJoinNode hash_join_node;
  TNestedLoopJoinNode nested_loop_join_node;

  _TJoinNode__isset __isset;

  void __set_join_op(const TJoinOp::type val);

  void __set_build_tuples(const std::vector< ::impala::TTupleId> & val);

  void __set_nullable_build_tuples(const std::vector<bool> & val);

  void __set_hash_join_node(const THashJoinNode& val);

  void __set_nested_loop_join_node(const TNestedLoopJoinNode& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TJoinNode &a, TJoinNode &b);

std::ostream& operator<<(std::ostream& out, const TJoinNode& obj);

typedef struct _TAggregator__isset {
  _TAggregator__isset() : grouping_exprs(false) {}
  bool grouping_exprs :1;
} _TAggregator__isset;

class TAggregator {
 public:

  TAggregator(const TAggregator&);
  TAggregator(TAggregator&&);
  TAggregator& operator=(const TAggregator&);
  TAggregator& operator=(TAggregator&&);
  TAggregator() : intermediate_tuple_id(0), output_tuple_id(0), need_finalize(0), use_streaming_preaggregation(0) {
  }

  virtual ~TAggregator() throw();
  std::vector< ::impala::TExpr>  grouping_exprs;
  std::vector< ::impala::TExpr>  aggregate_functions;
   ::impala::TTupleId intermediate_tuple_id;
   ::impala::TTupleId output_tuple_id;
  bool need_finalize;
  bool use_streaming_preaggregation;
   ::impala::TBackendResourceProfile resource_profile;

  _TAggregator__isset __isset;

  void __set_grouping_exprs(const std::vector< ::impala::TExpr> & val);

  void __set_aggregate_functions(const std::vector< ::impala::TExpr> & val);

  void __set_intermediate_tuple_id(const  ::impala::TTupleId val);

  void __set_output_tuple_id(const  ::impala::TTupleId val);

  void __set_need_finalize(const bool val);

  void __set_use_streaming_preaggregation(const bool val);

  void __set_resource_profile(const  ::impala::TBackendResourceProfile& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregator &a, TAggregator &b);

std::ostream& operator<<(std::ostream& out, const TAggregator& obj);


class TAggregationNode {
 public:

  TAggregationNode(const TAggregationNode&);
  TAggregationNode(TAggregationNode&&);
  TAggregationNode& operator=(const TAggregationNode&);
  TAggregationNode& operator=(TAggregationNode&&);
  TAggregationNode() : estimated_input_cardinality(0), replicate_input(0), fast_limit_check(0) {
  }

  virtual ~TAggregationNode() throw();
  std::vector<TAggregator>  aggregators;
  int64_t estimated_input_cardinality;
  bool replicate_input;
  bool fast_limit_check;

  void __set_aggregators(const std::vector<TAggregator> & val);

  void __set_estimated_input_cardinality(const int64_t val);

  void __set_replicate_input(const bool val);

  void __set_fast_limit_check(const bool val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAggregationNode &a, TAggregationNode &b);

std::ostream& operator<<(std::ostream& out, const TAggregationNode& obj);

typedef struct _TSortInfo__isset {
  _TSortInfo__isset() : sort_tuple_slot_exprs(false), num_lexical_keys_in_zorder(false) {}
  bool sort_tuple_slot_exprs :1;
  bool num_lexical_keys_in_zorder :1;
} _TSortInfo__isset;

class TSortInfo {
 public:

  TSortInfo(const TSortInfo&);
  TSortInfo(TSortInfo&&);
  TSortInfo& operator=(const TSortInfo&);
  TSortInfo& operator=(TSortInfo&&);
  TSortInfo() : sorting_order(( ::impala::TSortingOrder::type)0), num_lexical_keys_in_zorder(0) {
  }

  virtual ~TSortInfo() throw();
  std::vector< ::impala::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  std::vector<bool>  nulls_first;
  std::vector< ::impala::TExpr>  sort_tuple_slot_exprs;
   ::impala::TSortingOrder::type sorting_order;
  int32_t num_lexical_keys_in_zorder;

  _TSortInfo__isset __isset;

  void __set_ordering_exprs(const std::vector< ::impala::TExpr> & val);

  void __set_is_asc_order(const std::vector<bool> & val);

  void __set_nulls_first(const std::vector<bool> & val);

  void __set_sort_tuple_slot_exprs(const std::vector< ::impala::TExpr> & val);

  void __set_sorting_order(const  ::impala::TSortingOrder::type val);

  void __set_num_lexical_keys_in_zorder(const int32_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSortInfo &a, TSortInfo &b);

std::ostream& operator<<(std::ostream& out, const TSortInfo& obj);

typedef struct _TSortNode__isset {
  _TSortNode__isset() : offset(false), estimated_full_input_size(false), include_ties(false), limit_with_ties(false), per_partition_limit(false), partition_exprs(false), intra_partition_sort_info(false) {}
  bool offset :1;
  bool estimated_full_input_size :1;
  bool include_ties :1;
  bool limit_with_ties :1;
  bool per_partition_limit :1;
  bool partition_exprs :1;
  bool intra_partition_sort_info :1;
} _TSortNode__isset;

class TSortNode {
 public:

  TSortNode(const TSortNode&);
  TSortNode(TSortNode&&);
  TSortNode& operator=(const TSortNode&);
  TSortNode& operator=(TSortNode&&);
  TSortNode() : type((TSortType::type)0), offset(0), estimated_full_input_size(0), include_ties(0), limit_with_ties(0), per_partition_limit(0) {
  }

  virtual ~TSortNode() throw();
  TSortInfo sort_info;
  TSortType::type type;
  int64_t offset;
  int64_t estimated_full_input_size;
  bool include_ties;
  int64_t limit_with_ties;
  int64_t per_partition_limit;
  std::vector< ::impala::TExpr>  partition_exprs;
  TSortInfo intra_partition_sort_info;

  _TSortNode__isset __isset;

  void __set_sort_info(const TSortInfo& val);

  void __set_type(const TSortType::type val);

  void __set_offset(const int64_t val);

  void __set_estimated_full_input_size(const int64_t val);

  void __set_include_ties(const bool val);

  void __set_limit_with_ties(const int64_t val);

  void __set_per_partition_limit(const int64_t val);

  void __set_partition_exprs(const std::vector< ::impala::TExpr> & val);

  void __set_intra_partition_sort_info(const TSortInfo& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TSortNode &a, TSortNode &b);

std::ostream& operator<<(std::ostream& out, const TSortNode& obj);

typedef struct _TAnalyticWindowBoundary__isset {
  _TAnalyticWindowBoundary__isset() : range_offset_predicate(false), rows_offset_value(false) {}
  bool range_offset_predicate :1;
  bool rows_offset_value :1;
} _TAnalyticWindowBoundary__isset;

class TAnalyticWindowBoundary {
 public:

  TAnalyticWindowBoundary(const TAnalyticWindowBoundary&);
  TAnalyticWindowBoundary(TAnalyticWindowBoundary&&);
  TAnalyticWindowBoundary& operator=(const TAnalyticWindowBoundary&);
  TAnalyticWindowBoundary& operator=(TAnalyticWindowBoundary&&);
  TAnalyticWindowBoundary() : type((TAnalyticWindowBoundaryType::type)0), rows_offset_value(0) {
  }

  virtual ~TAnalyticWindowBoundary() throw();
  TAnalyticWindowBoundaryType::type type;
   ::impala::TExpr range_offset_predicate;
  int64_t rows_offset_value;

  _TAnalyticWindowBoundary__isset __isset;

  void __set_type(const TAnalyticWindowBoundaryType::type val);

  void __set_range_offset_predicate(const  ::impala::TExpr& val);

  void __set_rows_offset_value(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAnalyticWindowBoundary &a, TAnalyticWindowBoundary &b);

std::ostream& operator<<(std::ostream& out, const TAnalyticWindowBoundary& obj);

typedef struct _TAnalyticWindow__isset {
  _TAnalyticWindow__isset() : window_start(false), window_end(false) {}
  bool window_start :1;
  bool window_end :1;
} _TAnalyticWindow__isset;

class TAnalyticWindow {
 public:

  TAnalyticWindow(const TAnalyticWindow&);
  TAnalyticWindow(TAnalyticWindow&&);
  TAnalyticWindow& operator=(const TAnalyticWindow&);
  TAnalyticWindow& operator=(TAnalyticWindow&&);
  TAnalyticWindow() : type((TAnalyticWindowType::type)0) {
  }

  virtual ~TAnalyticWindow() throw();
  TAnalyticWindowType::type type;
  TAnalyticWindowBoundary window_start;
  TAnalyticWindowBoundary window_end;

  _TAnalyticWindow__isset __isset;

  void __set_type(const TAnalyticWindowType::type val);

  void __set_window_start(const TAnalyticWindowBoundary& val);

  void __set_window_end(const TAnalyticWindowBoundary& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAnalyticWindow &a, TAnalyticWindow &b);

std::ostream& operator<<(std::ostream& out, const TAnalyticWindow& obj);

typedef struct _TAnalyticNode__isset {
  _TAnalyticNode__isset() : window(false), buffered_tuple_id(false), partition_by_eq(false), order_by_eq(false) {}
  bool window :1;
  bool buffered_tuple_id :1;
  bool partition_by_eq :1;
  bool order_by_eq :1;
} _TAnalyticNode__isset;

class TAnalyticNode {
 public:

  TAnalyticNode(const TAnalyticNode&);
  TAnalyticNode(TAnalyticNode&&);
  TAnalyticNode& operator=(const TAnalyticNode&);
  TAnalyticNode& operator=(TAnalyticNode&&);
  TAnalyticNode() : intermediate_tuple_id(0), output_tuple_id(0), buffered_tuple_id(0) {
  }

  virtual ~TAnalyticNode() throw();
  std::vector< ::impala::TExpr>  partition_exprs;
  std::vector< ::impala::TExpr>  order_by_exprs;
  std::vector< ::impala::TExpr>  analytic_functions;
  TAnalyticWindow window;
   ::impala::TTupleId intermediate_tuple_id;
   ::impala::TTupleId output_tuple_id;
   ::impala::TTupleId buffered_tuple_id;
   ::impala::TExpr partition_by_eq;
   ::impala::TExpr order_by_eq;

  _TAnalyticNode__isset __isset;

  void __set_partition_exprs(const std::vector< ::impala::TExpr> & val);

  void __set_order_by_exprs(const std::vector< ::impala::TExpr> & val);

  void __set_analytic_functions(const std::vector< ::impala::TExpr> & val);

  void __set_window(const TAnalyticWindow& val);

  void __set_intermediate_tuple_id(const  ::impala::TTupleId val);

  void __set_output_tuple_id(const  ::impala::TTupleId val);

  void __set_buffered_tuple_id(const  ::impala::TTupleId val);

  void __set_partition_by_eq(const  ::impala::TExpr& val);

  void __set_order_by_eq(const  ::impala::TExpr& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TAnalyticNode &a, TAnalyticNode &b);

std::ostream& operator<<(std::ostream& out, const TAnalyticNode& obj);


class TUnionNode {
 public:

  TUnionNode(const TUnionNode&);
  TUnionNode(TUnionNode&&);
  TUnionNode& operator=(const TUnionNode&);
  TUnionNode& operator=(TUnionNode&&);
  TUnionNode() : tuple_id(0), first_materialized_child_idx(0) {
  }

  virtual ~TUnionNode() throw();
   ::impala::TTupleId tuple_id;
  std::vector<std::vector< ::impala::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::impala::TExpr> >  const_expr_lists;
  int64_t first_materialized_child_idx;

  void __set_tuple_id(const  ::impala::TTupleId val);

  void __set_result_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val);

  void __set_const_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val);

  void __set_first_materialized_child_idx(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUnionNode &a, TUnionNode &b);

std::ostream& operator<<(std::ostream& out, const TUnionNode& obj);

typedef struct _TExchangeNode__isset {
  _TExchangeNode__isset() : sort_info(false), offset(false) {}
  bool sort_info :1;
  bool offset :1;
} _TExchangeNode__isset;

class TExchangeNode {
 public:

  TExchangeNode(const TExchangeNode&);
  TExchangeNode(TExchangeNode&&);
  TExchangeNode& operator=(const TExchangeNode&);
  TExchangeNode& operator=(TExchangeNode&&);
  TExchangeNode() : offset(0) {
  }

  virtual ~TExchangeNode() throw();
  std::vector< ::impala::TTupleId>  input_row_tuples;
  TSortInfo sort_info;
  int64_t offset;

  _TExchangeNode__isset __isset;

  void __set_input_row_tuples(const std::vector< ::impala::TTupleId> & val);

  void __set_sort_info(const TSortInfo& val);

  void __set_offset(const int64_t val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TExchangeNode &a, TExchangeNode &b);

std::ostream& operator<<(std::ostream& out, const TExchangeNode& obj);


class TUnnestNode {
 public:

  TUnnestNode(const TUnnestNode&);
  TUnnestNode(TUnnestNode&&);
  TUnnestNode& operator=(const TUnnestNode&);
  TUnnestNode& operator=(TUnnestNode&&);
  TUnnestNode() {
  }

  virtual ~TUnnestNode() throw();
  std::vector< ::impala::TExpr>  collection_exprs;

  void __set_collection_exprs(const std::vector< ::impala::TExpr> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TUnnestNode &a, TUnnestNode &b);

std::ostream& operator<<(std::ostream& out, const TUnnestNode& obj);


class TCardinalityCheckNode {
 public:

  TCardinalityCheckNode(const TCardinalityCheckNode&);
  TCardinalityCheckNode(TCardinalityCheckNode&&);
  TCardinalityCheckNode& operator=(const TCardinalityCheckNode&);
  TCardinalityCheckNode& operator=(TCardinalityCheckNode&&);
  TCardinalityCheckNode() : display_statement() {
  }

  virtual ~TCardinalityCheckNode() throw();
  std::string display_statement;

  void __set_display_statement(const std::string& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TCardinalityCheckNode &a, TCardinalityCheckNode &b);

std::ostream& operator<<(std::ostream& out, const TCardinalityCheckNode& obj);


class TPipelineMembership {
 public:

  TPipelineMembership(const TPipelineMembership&);
  TPipelineMembership(TPipelineMembership&&);
  TPipelineMembership& operator=(const TPipelineMembership&);
  TPipelineMembership& operator=(TPipelineMembership&&);
  TPipelineMembership() : pipe_id(0), height(0), phase((TExecNodePhase::type)0) {
  }

  virtual ~TPipelineMembership() throw();
   ::impala::TPlanNodeId pipe_id;
  int32_t height;
  TExecNodePhase::type phase;

  void __set_pipe_id(const  ::impala::TPlanNodeId val);

  void __set_height(const int32_t val);

  void __set_phase(const TExecNodePhase::type val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPipelineMembership &a, TPipelineMembership &b);

std::ostream& operator<<(std::ostream& out, const TPipelineMembership& obj);

typedef struct _TPlanNode__isset {
  _TPlanNode__isset() : conjuncts(false), hdfs_scan_node(false), hbase_scan_node(false), kudu_scan_node(false), data_source_node(false), join_node(false), agg_node(false), sort_node(false), union_node(false), exchange_node(false), analytic_node(false), unnest_node(false), label(false), label_detail(false), estimated_stats(false), runtime_filters(false), cardinality_check_node(false) {}
  bool conjuncts :1;
  bool hdfs_scan_node :1;
  bool hbase_scan_node :1;
  bool kudu_scan_node :1;
  bool data_source_node :1;
  bool join_node :1;
  bool agg_node :1;
  bool sort_node :1;
  bool union_node :1;
  bool exchange_node :1;
  bool analytic_node :1;
  bool unnest_node :1;
  bool label :1;
  bool label_detail :1;
  bool estimated_stats :1;
  bool runtime_filters :1;
  bool cardinality_check_node :1;
} _TPlanNode__isset;

class TPlanNode {
 public:

  TPlanNode(const TPlanNode&);
  TPlanNode(TPlanNode&&);
  TPlanNode& operator=(const TPlanNode&);
  TPlanNode& operator=(TPlanNode&&);
  TPlanNode() : node_id(0), node_type((TPlanNodeType::type)0), num_children(0), limit(0), disable_codegen(0), label(), label_detail() {
  }

  virtual ~TPlanNode() throw();
   ::impala::TPlanNodeId node_id;
  TPlanNodeType::type node_type;
  int32_t num_children;
  int64_t limit;
  std::vector< ::impala::TTupleId>  row_tuples;
  std::vector<bool>  nullable_tuples;
  std::vector< ::impala::TExpr>  conjuncts;
  bool disable_codegen;
  std::vector<TPipelineMembership>  pipelines;
  THdfsScanNode hdfs_scan_node;
  THBaseScanNode hbase_scan_node;
  TKuduScanNode kudu_scan_node;
  TDataSourceScanNode data_source_node;
  TJoinNode join_node;
  TAggregationNode agg_node;
  TSortNode sort_node;
  TUnionNode union_node;
  TExchangeNode exchange_node;
  TAnalyticNode analytic_node;
  TUnnestNode unnest_node;
  std::string label;
  std::string label_detail;
   ::impala::TExecStats estimated_stats;
  std::vector<TRuntimeFilterDesc>  runtime_filters;
   ::impala::TBackendResourceProfile resource_profile;
  TCardinalityCheckNode cardinality_check_node;

  _TPlanNode__isset __isset;

  void __set_node_id(const  ::impala::TPlanNodeId val);

  void __set_node_type(const TPlanNodeType::type val);

  void __set_num_children(const int32_t val);

  void __set_limit(const int64_t val);

  void __set_row_tuples(const std::vector< ::impala::TTupleId> & val);

  void __set_nullable_tuples(const std::vector<bool> & val);

  void __set_conjuncts(const std::vector< ::impala::TExpr> & val);

  void __set_disable_codegen(const bool val);

  void __set_pipelines(const std::vector<TPipelineMembership> & val);

  void __set_hdfs_scan_node(const THdfsScanNode& val);

  void __set_hbase_scan_node(const THBaseScanNode& val);

  void __set_kudu_scan_node(const TKuduScanNode& val);

  void __set_data_source_node(const TDataSourceScanNode& val);

  void __set_join_node(const TJoinNode& val);

  void __set_agg_node(const TAggregationNode& val);

  void __set_sort_node(const TSortNode& val);

  void __set_union_node(const TUnionNode& val);

  void __set_exchange_node(const TExchangeNode& val);

  void __set_analytic_node(const TAnalyticNode& val);

  void __set_unnest_node(const TUnnestNode& val);

  void __set_label(const std::string& val);

  void __set_label_detail(const std::string& val);

  void __set_estimated_stats(const  ::impala::TExecStats& val);

  void __set_runtime_filters(const std::vector<TRuntimeFilterDesc> & val);

  void __set_resource_profile(const  ::impala::TBackendResourceProfile& val);

  void __set_cardinality_check_node(const TCardinalityCheckNode& val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlanNode &a, TPlanNode &b);

std::ostream& operator<<(std::ostream& out, const TPlanNode& obj);


class TPlan {
 public:

  TPlan(const TPlan&);
  TPlan(TPlan&&);
  TPlan& operator=(const TPlan&);
  TPlan& operator=(TPlan&&);
  TPlan() {
  }

  virtual ~TPlan() throw();
  std::vector<TPlanNode>  nodes;

  void __set_nodes(const std::vector<TPlanNode> & val);

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t write(Protocol_* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TPlan &a, TPlan &b);

std::ostream& operator<<(std::ostream& out, const TPlan& obj);

} // namespace

#include "PlanNodes_types.tcc"

#endif
