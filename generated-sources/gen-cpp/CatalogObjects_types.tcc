/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CatalogObjects_TYPES_TCC
#define CatalogObjects_TYPES_TCC

#include "Data_types.tcc"
#include "Exprs_types.tcc"
#include "Status_types.tcc"
#include "Types_types.tcc"
#include "hive_metastore_types.tcc"
#include "SqlConstraints_types.tcc"
#include "CatalogObjects_types.h"

namespace impala {

template <class Protocol_>
uint32_t TCompressionCodec::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_codec = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->codec = (THdfsCompression::type)ecast0;
          isset_codec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->compression_level);
          this->__isset.compression_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_codec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCompressionCodec::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCompressionCodec");

  xfer += oprot->writeFieldBegin("codec", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->codec);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.compression_level) {
    xfer += oprot->writeFieldBegin("compression_level", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->compression_level);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartitionKeyValue::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPartitionKeyValue::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartitionKeyValue");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableName::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_table_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTableName::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableName");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTableStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_rows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          isset_num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_file_bytes);
          this->__isset.total_file_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_rows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTableStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTableStats");

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.total_file_bytes) {
    xfer += oprot->writeFieldBegin("total_file_bytes", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->total_file_bytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TColumnStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_avg_size = false;
  bool isset_max_size = false;
  bool isset_num_distinct_values = false;
  bool isset_num_nulls = false;
  bool isset_num_trues = false;
  bool isset_num_falses = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avg_size);
          isset_avg_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->max_size);
          isset_max_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_distinct_values);
          isset_num_distinct_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_nulls);
          isset_num_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_trues);
          isset_num_trues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_falses);
          isset_num_falses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->low_value.read(iprot);
          this->__isset.low_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->high_value.read(iprot);
          this->__isset.high_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_avg_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_max_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_distinct_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_nulls)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_trues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_falses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TColumnStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumnStats");

  xfer += oprot->writeFieldBegin("avg_size", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->avg_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_size", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->max_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_distinct_values", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_distinct_values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_nulls", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_nulls);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_trues", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_trues);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_falses", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->num_falses);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.low_value) {
    xfer += oprot->writeFieldBegin("low_value", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->low_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.high_value) {
    xfer += oprot->writeFieldBegin("high_value", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->high_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIntermediateColumnStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_num_trues = false;
  bool isset_num_falses = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->intermediate_ndv);
          this->__isset.intermediate_ndv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_ndv_encoded);
          this->__isset.is_ndv_encoded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_nulls);
          this->__isset.num_nulls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_width);
          this->__isset.max_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avg_width);
          this->__isset.avg_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_trues);
          isset_num_trues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_falses);
          isset_num_falses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->low_value.read(iprot);
          this->__isset.low_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->high_value.read(iprot);
          this->__isset.high_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_num_trues)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_falses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIntermediateColumnStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIntermediateColumnStats");

  if (this->__isset.intermediate_ndv) {
    xfer += oprot->writeFieldBegin("intermediate_ndv", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->intermediate_ndv);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_ndv_encoded) {
    xfer += oprot->writeFieldBegin("is_ndv_encoded", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->is_ndv_encoded);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_nulls) {
    xfer += oprot->writeFieldBegin("num_nulls", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->num_nulls);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_width) {
    xfer += oprot->writeFieldBegin("max_width", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_width);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.avg_width) {
    xfer += oprot->writeFieldBegin("avg_width", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->avg_width);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_rows) {
    xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->num_rows);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("num_trues", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->num_trues);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_falses", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->num_falses);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.low_value) {
    xfer += oprot->writeFieldBegin("low_value", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->low_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.high_value) {
    xfer += oprot->writeFieldBegin("high_value", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->high_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPartitionStats::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_stats = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          isset_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->intermediate_col_stats.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _ktype26;
            ::apache::thrift::protocol::TType _vtype27;
            xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              std::string _key30;
              xfer += iprot->readString(_key30);
              TIntermediateColumnStats& _val31 = this->intermediate_col_stats[_key30];
              xfer += _val31.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.intermediate_col_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_stats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPartitionStats::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPartitionStats");

  xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->stats.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.intermediate_col_stats) {
    xfer += oprot->writeFieldBegin("intermediate_col_stats", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intermediate_col_stats.size()));
      std::map<std::string, TIntermediateColumnStats> ::const_iterator _iter32;
      for (_iter32 = this->intermediate_col_stats.begin(); _iter32 != this->intermediate_col_stats.end(); ++_iter32)
      {
        xfer += oprot->writeString(_iter32->first);
        xfer += _iter32->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TColumn::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columnName = false;
  bool isset_columnType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnName);
          isset_columnName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->columnType.read(iprot);
          isset_columnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->col_stats.read(iprot);
          this->__isset.col_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_hbase_column);
          this->__isset.is_hbase_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_family);
          this->__isset.column_family = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_qualifier);
          this->__isset.column_qualifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_binary);
          this->__isset.is_binary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_kudu_column);
          this->__isset.is_kudu_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_key);
          this->__isset.is_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_nullable);
          this->__isset.is_nullable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->encoding = (TColumnEncoding::type)ecast37;
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast38;
          xfer += iprot->readI32(ecast38);
          this->compression = (THdfsCompression::type)ecast38;
          this->__isset.compression = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->default_value.read(iprot);
          this->__isset.default_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->block_size);
          this->__isset.block_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->kudu_column_name);
          this->__isset.kudu_column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_iceberg_column);
          this->__isset.is_iceberg_column = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iceberg_field_id);
          this->__isset.iceberg_field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iceberg_field_map_key_id);
          this->__isset.iceberg_field_map_key_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iceberg_field_map_value_id);
          this->__isset.iceberg_field_map_value_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columnName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_columnType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TColumn::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TColumn");

  xfer += oprot->writeFieldBegin("columnName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->columnName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnType", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->columnType.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_stats) {
    xfer += oprot->writeFieldBegin("col_stats", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->col_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.position) {
    xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->position);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_hbase_column) {
    xfer += oprot->writeFieldBegin("is_hbase_column", ::apache::thrift::protocol::T_BOOL, 6);
    xfer += oprot->writeBool(this->is_hbase_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_family) {
    xfer += oprot->writeFieldBegin("column_family", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->column_family);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_qualifier) {
    xfer += oprot->writeFieldBegin("column_qualifier", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->column_qualifier);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_binary) {
    xfer += oprot->writeFieldBegin("is_binary", ::apache::thrift::protocol::T_BOOL, 9);
    xfer += oprot->writeBool(this->is_binary);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_kudu_column) {
    xfer += oprot->writeFieldBegin("is_kudu_column", ::apache::thrift::protocol::T_BOOL, 10);
    xfer += oprot->writeBool(this->is_kudu_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_key) {
    xfer += oprot->writeFieldBegin("is_key", ::apache::thrift::protocol::T_BOOL, 11);
    xfer += oprot->writeBool(this->is_key);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_nullable) {
    xfer += oprot->writeFieldBegin("is_nullable", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_nullable);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoding) {
    xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 13);
    xfer += oprot->writeI32((int32_t)this->encoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compression) {
    xfer += oprot->writeFieldBegin("compression", ::apache::thrift::protocol::T_I32, 14);
    xfer += oprot->writeI32((int32_t)this->compression);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.default_value) {
    xfer += oprot->writeFieldBegin("default_value", ::apache::thrift::protocol::T_STRUCT, 15);
    xfer += this->default_value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.block_size) {
    xfer += oprot->writeFieldBegin("block_size", ::apache::thrift::protocol::T_I32, 16);
    xfer += oprot->writeI32(this->block_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_column_name) {
    xfer += oprot->writeFieldBegin("kudu_column_name", ::apache::thrift::protocol::T_STRING, 17);
    xfer += oprot->writeString(this->kudu_column_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_iceberg_column) {
    xfer += oprot->writeFieldBegin("is_iceberg_column", ::apache::thrift::protocol::T_BOOL, 18);
    xfer += oprot->writeBool(this->is_iceberg_column);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iceberg_field_id) {
    xfer += oprot->writeFieldBegin("iceberg_field_id", ::apache::thrift::protocol::T_I32, 19);
    xfer += oprot->writeI32(this->iceberg_field_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iceberg_field_map_key_id) {
    xfer += oprot->writeFieldBegin("iceberg_field_map_key_id", ::apache::thrift::protocol::T_I32, 20);
    xfer += oprot->writeI32(this->iceberg_field_map_key_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iceberg_field_map_value_id) {
    xfer += oprot->writeFieldBegin("iceberg_field_map_value_id", ::apache::thrift::protocol::T_I32, 21);
    xfer += oprot->writeI32(this->iceberg_field_map_value_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsFileDesc::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_file_desc_data = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->file_desc_data);
          isset_file_desc_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->file_metadata);
          this->__isset.file_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_file_desc_data)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsFileDesc::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsFileDesc");

  xfer += oprot->writeFieldBegin("file_desc_data", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->file_desc_data);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_metadata) {
    xfer += oprot->writeFieldBegin("file_metadata", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeBinary(this->file_metadata);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsPartitionLocation::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_prefix_index = false;
  bool isset_suffix = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->prefix_index);
          isset_prefix_index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->suffix);
          isset_suffix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_prefix_index)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_suffix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsPartitionLocation::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsPartitionLocation");

  xfer += oprot->writeFieldBegin("prefix_index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->prefix_index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("suffix", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->suffix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsStorageDescriptor::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lineDelim = false;
  bool isset_fieldDelim = false;
  bool isset_collectionDelim = false;
  bool isset_mapKeyDelim = false;
  bool isset_escapeChar = false;
  bool isset_quoteChar = false;
  bool isset_fileFormat = false;
  bool isset_blockSize = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->lineDelim);
          isset_lineDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->fieldDelim);
          isset_fieldDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->collectionDelim);
          isset_collectionDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mapKeyDelim);
          isset_mapKeyDelim = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->escapeChar);
          isset_escapeChar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->quoteChar);
          isset_quoteChar = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          this->fileFormat = (THdfsFileFormat::type)ecast51;
          isset_fileFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blockSize);
          isset_blockSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lineDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fieldDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_collectionDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_mapKeyDelim)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_escapeChar)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_quoteChar)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fileFormat)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blockSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsStorageDescriptor::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsStorageDescriptor");

  xfer += oprot->writeFieldBegin("lineDelim", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->lineDelim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fieldDelim", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->fieldDelim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("collectionDelim", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->collectionDelim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapKeyDelim", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->mapKeyDelim);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("escapeChar", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->escapeChar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quoteChar", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->quoteChar);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileFormat", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->fileFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockSize", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->blockSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsPartition::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionKeyExprs.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->partitionKeyExprs.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->partitionKeyExprs[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitionKeyExprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->prev_id);
          this->__isset.prev_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->file_desc.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            xfer += iprot->readListBegin(_etype64, _size61);
            this->file_desc.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += this->file_desc[_i65].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.file_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->insert_file_desc.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->insert_file_desc.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->insert_file_desc[_i70].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.insert_file_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->delete_file_desc.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->delete_file_desc.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->delete_file_desc[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.delete_file_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          this->access_level = (TAccessLevel::type)ecast76;
          this->__isset.access_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stats.read(iprot);
          this->__isset.stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_marked_cached);
          this->__isset.is_marked_cached = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->hms_parameters.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _ktype78;
            ::apache::thrift::protocol::TType _vtype79;
            xfer += iprot->readMapBegin(_ktype78, _vtype79, _size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              std::string _key82;
              xfer += iprot->readString(_key82);
              std::string& _val83 = this->hms_parameters[_key82];
              xfer += iprot->readString(_val83);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.hms_parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_blocks);
          this->__isset.num_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_file_size_bytes);
          this->__isset.total_file_size_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->partition_stats);
          this->__isset.partition_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_incremental_stats);
          this->__isset.has_incremental_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->write_id);
          this->__isset.write_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          this->__isset.tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->partition_name);
          this->__isset.partition_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_storage_descriptor.read(iprot);
          this->__isset.hdfs_storage_descriptor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t THdfsPartition::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsPartition");

  xfer += oprot->writeFieldBegin("partitionKeyExprs", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitionKeyExprs.size()));
    std::vector< ::impala::TExpr> ::const_iterator _iter84;
    for (_iter84 = this->partitionKeyExprs.begin(); _iter84 != this->partitionKeyExprs.end(); ++_iter84)
    {
      xfer += (*_iter84).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.file_desc) {
    xfer += oprot->writeFieldBegin("file_desc", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->file_desc.size()));
      std::vector<THdfsFileDesc> ::const_iterator _iter85;
      for (_iter85 = this->file_desc.begin(); _iter85 != this->file_desc.end(); ++_iter85)
      {
        xfer += (*_iter85).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->location.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_level) {
    xfer += oprot->writeFieldBegin("access_level", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32((int32_t)this->access_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.stats) {
    xfer += oprot->writeFieldBegin("stats", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_marked_cached) {
    xfer += oprot->writeFieldBegin("is_marked_cached", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->is_marked_cached);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 14);
    xfer += oprot->writeI64(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hms_parameters) {
    xfer += oprot->writeFieldBegin("hms_parameters", ::apache::thrift::protocol::T_MAP, 15);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->hms_parameters.size()));
      std::map<std::string, std::string> ::const_iterator _iter86;
      for (_iter86 = this->hms_parameters.begin(); _iter86 != this->hms_parameters.end(); ++_iter86)
      {
        xfer += oprot->writeString(_iter86->first);
        xfer += oprot->writeString(_iter86->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.num_blocks) {
    xfer += oprot->writeFieldBegin("num_blocks", ::apache::thrift::protocol::T_I64, 16);
    xfer += oprot->writeI64(this->num_blocks);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_file_size_bytes) {
    xfer += oprot->writeFieldBegin("total_file_size_bytes", ::apache::thrift::protocol::T_I64, 17);
    xfer += oprot->writeI64(this->total_file_size_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_stats) {
    xfer += oprot->writeFieldBegin("partition_stats", ::apache::thrift::protocol::T_STRING, 18);
    xfer += oprot->writeBinary(this->partition_stats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_incremental_stats) {
    xfer += oprot->writeFieldBegin("has_incremental_stats", ::apache::thrift::protocol::T_BOOL, 19);
    xfer += oprot->writeBool(this->has_incremental_stats);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.write_id) {
    xfer += oprot->writeFieldBegin("write_id", ::apache::thrift::protocol::T_I64, 20);
    xfer += oprot->writeI64(this->write_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.insert_file_desc) {
    xfer += oprot->writeFieldBegin("insert_file_desc", ::apache::thrift::protocol::T_LIST, 21);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->insert_file_desc.size()));
      std::vector<THdfsFileDesc> ::const_iterator _iter87;
      for (_iter87 = this->insert_file_desc.begin(); _iter87 != this->insert_file_desc.end(); ++_iter87)
      {
        xfer += (*_iter87).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.delete_file_desc) {
    xfer += oprot->writeFieldBegin("delete_file_desc", ::apache::thrift::protocol::T_LIST, 22);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->delete_file_desc.size()));
      std::vector<THdfsFileDesc> ::const_iterator _iter88;
      for (_iter88 = this->delete_file_desc.begin(); _iter88 != this->delete_file_desc.end(); ++_iter88)
      {
        xfer += (*_iter88).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tbl_name) {
    xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 24);
    xfer += oprot->writeString(this->tbl_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_name) {
    xfer += oprot->writeFieldBegin("partition_name", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->partition_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.prev_id) {
    xfer += oprot->writeFieldBegin("prev_id", ::apache::thrift::protocol::T_I64, 26);
    xfer += oprot->writeI64(this->prev_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_storage_descriptor) {
    xfer += oprot->writeFieldBegin("hdfs_storage_descriptor", ::apache::thrift::protocol::T_STRUCT, 27);
    xfer += this->hdfs_storage_descriptor.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TValidWriteIdList::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->high_watermark);
          this->__isset.high_watermark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->min_open_write_id);
          this->__isset.min_open_write_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->invalid_write_ids.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->invalid_write_ids.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += iprot->readI64(this->invalid_write_ids[_i97]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.invalid_write_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->aborted_indexes.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->aborted_indexes.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += iprot->readI32(this->aborted_indexes[_i102]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.aborted_indexes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TValidWriteIdList::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TValidWriteIdList");

  if (this->__isset.high_watermark) {
    xfer += oprot->writeFieldBegin("high_watermark", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->high_watermark);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.min_open_write_id) {
    xfer += oprot->writeFieldBegin("min_open_write_id", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->min_open_write_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.invalid_write_ids) {
    xfer += oprot->writeFieldBegin("invalid_write_ids", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->invalid_write_ids.size()));
      std::vector<int64_t> ::const_iterator _iter103;
      for (_iter103 = this->invalid_write_ids.begin(); _iter103 != this->invalid_write_ids.end(); ++_iter103)
      {
        xfer += oprot->writeI64((*_iter103));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aborted_indexes) {
    xfer += oprot->writeFieldBegin("aborted_indexes", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->aborted_indexes.size()));
      std::vector<int32_t> ::const_iterator _iter104;
      for (_iter104 = this->aborted_indexes.begin(); _iter104 != this->aborted_indexes.end(); ++_iter104)
      {
        xfer += oprot->writeI32((*_iter104));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_hdfsBaseDir = false;
  bool isset_colNames = false;
  bool isset_nullPartitionKeyValue = false;
  bool isset_nullColumnValue = false;
  bool isset_partitions = false;
  bool isset_prototype_partition = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfsBaseDir);
          isset_hdfsBaseDir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colNames.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _etype112;
            xfer += iprot->readListBegin(_etype112, _size109);
            this->colNames.resize(_size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              xfer += iprot->readString(this->colNames[_i113]);
            }
            xfer += iprot->readListEnd();
          }
          isset_colNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nullPartitionKeyValue);
          isset_nullPartitionKeyValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nullColumnValue);
          isset_nullColumnValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avroSchema);
          this->__isset.avroSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->partitions.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _ktype115;
            ::apache::thrift::protocol::TType _vtype116;
            xfer += iprot->readMapBegin(_ktype115, _vtype116, _size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              int64_t _key119;
              xfer += iprot->readI64(_key119);
              THdfsPartition& _val120 = this->partitions[_key119];
              xfer += _val120.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_full_partitions);
          this->__isset.has_full_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_partition_names);
          this->__isset.has_partition_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->prototype_partition.read(iprot);
          isset_prototype_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_prefixes.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->partition_prefixes.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += iprot->readString(this->partition_prefixes[_i125]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_prefixes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->network_addresses.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->network_addresses.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += this->network_addresses[_i130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.network_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sql_constraints.read(iprot);
          this->__isset.sql_constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_full_acid);
          this->__isset.is_full_acid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->valid_write_ids.read(iprot);
          this->__isset.valid_write_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_hdfsBaseDir)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colNames)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullPartitionKeyValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nullColumnValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_prototype_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsTable");

  xfer += oprot->writeFieldBegin("hdfsBaseDir", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->hdfsBaseDir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("colNames", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->colNames.size()));
    std::vector<std::string> ::const_iterator _iter131;
    for (_iter131 = this->colNames.begin(); _iter131 != this->colNames.end(); ++_iter131)
    {
      xfer += oprot->writeString((*_iter131));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullPartitionKeyValue", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->nullPartitionKeyValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::map<int64_t, THdfsPartition> ::const_iterator _iter132;
    for (_iter132 = this->partitions.begin(); _iter132 != this->partitions.end(); ++_iter132)
    {
      xfer += oprot->writeI64(_iter132->first);
      xfer += _iter132->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nullColumnValue", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->nullColumnValue);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.avroSchema) {
    xfer += oprot->writeFieldBegin("avroSchema", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->avroSchema);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.network_addresses) {
    xfer += oprot->writeFieldBegin("network_addresses", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->network_addresses.size()));
      std::vector< ::impala::TNetworkAddress> ::const_iterator _iter133;
      for (_iter133 = this->network_addresses.begin(); _iter133 != this->network_addresses.end(); ++_iter133)
      {
        xfer += (*_iter133).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.partition_prefixes) {
    xfer += oprot->writeFieldBegin("partition_prefixes", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partition_prefixes.size()));
      std::vector<std::string> ::const_iterator _iter134;
      for (_iter134 = this->partition_prefixes.begin(); _iter134 != this->partition_prefixes.end(); ++_iter134)
      {
        xfer += oprot->writeString((*_iter134));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("prototype_partition", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->prototype_partition.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sql_constraints) {
    xfer += oprot->writeFieldBegin("sql_constraints", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->sql_constraints.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_full_acid) {
    xfer += oprot->writeFieldBegin("is_full_acid", ::apache::thrift::protocol::T_BOOL, 12);
    xfer += oprot->writeBool(this->is_full_acid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.valid_write_ids) {
    xfer += oprot->writeFieldBegin("valid_write_ids", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->valid_write_ids.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_full_partitions) {
    xfer += oprot->writeFieldBegin("has_full_partitions", ::apache::thrift::protocol::T_BOOL, 14);
    xfer += oprot->writeBool(this->has_full_partitions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.has_partition_names) {
    xfer += oprot->writeFieldBegin("has_partition_names", ::apache::thrift::protocol::T_BOOL, 15);
    xfer += oprot->writeBool(this->has_partition_names);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THBaseTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;
  bool isset_families = false;
  bool isset_qualifiers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->families.clear();
            uint32_t _size139;
            ::apache::thrift::protocol::TType _etype142;
            xfer += iprot->readListBegin(_etype142, _size139);
            this->families.resize(_size139);
            uint32_t _i143;
            for (_i143 = 0; _i143 < _size139; ++_i143)
            {
              xfer += iprot->readString(this->families[_i143]);
            }
            xfer += iprot->readListEnd();
          }
          isset_families = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->qualifiers.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->qualifiers.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readString(this->qualifiers[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          isset_qualifiers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->binary_encoded.clear();
            uint32_t _size149;
            ::apache::thrift::protocol::TType _etype152;
            xfer += iprot->readListBegin(_etype152, _size149);
            this->binary_encoded.resize(_size149);
            uint32_t _i153;
            for (_i153 = 0; _i153 < _size149; ++_i153)
            {
              xfer += iprot->readBool(this->binary_encoded[_i153]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.binary_encoded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_families)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_qualifiers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THBaseTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THBaseTable");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("families", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->families.size()));
    std::vector<std::string> ::const_iterator _iter154;
    for (_iter154 = this->families.begin(); _iter154 != this->families.end(); ++_iter154)
    {
      xfer += oprot->writeString((*_iter154));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qualifiers", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->qualifiers.size()));
    std::vector<std::string> ::const_iterator _iter155;
    for (_iter155 = this->qualifiers.begin(); _iter155 != this->qualifiers.end(); ++_iter155)
    {
      xfer += oprot->writeString((*_iter155));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.binary_encoded) {
    xfer += oprot->writeFieldBegin("binary_encoded", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->binary_encoded.size()));
      std::vector<bool> ::const_iterator _iter156;
      for (_iter156 = this->binary_encoded.begin(); _iter156 != this->binary_encoded.end(); ++_iter156)
      {
        xfer += oprot->writeBool((*_iter156));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDataSource::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_hdfs_location = false;
  bool isset_class_name = false;
  bool isset_api_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hdfs_location);
          isset_hdfs_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->class_name);
          isset_class_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->api_version);
          isset_api_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hdfs_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_class_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_api_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDataSource::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSource");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hdfs_location", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->hdfs_location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("class_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->class_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("api_version", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->api_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDataSourceTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_data_source = false;
  bool isset_init_string = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source.read(iprot);
          isset_data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->init_string);
          isset_init_string = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_data_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_init_string)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDataSourceTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDataSourceTable");

  xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->data_source.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("init_string", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->init_string);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TKuduPartitionByHashParam::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;
  bool isset_num_partitions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->columns.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readString(this->columns[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num_partitions);
          isset_num_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_num_partitions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TKuduPartitionByHashParam::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduPartitionByHashParam");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter174;
    for (_iter174 = this->columns.begin(); _iter174 != this->columns.end(); ++_iter174)
    {
      xfer += oprot->writeString((*_iter174));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_partitions", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num_partitions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TRangePartition::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lower_bound_values.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size179);
            this->lower_bound_values.resize(_size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              xfer += this->lower_bound_values[_i183].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lower_bound_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_lower_bound_inclusive);
          this->__isset.is_lower_bound_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->upper_bound_values.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _etype187;
            xfer += iprot->readListBegin(_etype187, _size184);
            this->upper_bound_values.resize(_size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              xfer += this->upper_bound_values[_i188].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.upper_bound_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_upper_bound_inclusive);
          this->__isset.is_upper_bound_inclusive = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TRangePartition::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TRangePartition");

  if (this->__isset.lower_bound_values) {
    xfer += oprot->writeFieldBegin("lower_bound_values", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lower_bound_values.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter189;
      for (_iter189 = this->lower_bound_values.begin(); _iter189 != this->lower_bound_values.end(); ++_iter189)
      {
        xfer += (*_iter189).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_lower_bound_inclusive) {
    xfer += oprot->writeFieldBegin("is_lower_bound_inclusive", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->is_lower_bound_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.upper_bound_values) {
    xfer += oprot->writeFieldBegin("upper_bound_values", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->upper_bound_values.size()));
      std::vector< ::impala::TExpr> ::const_iterator _iter190;
      for (_iter190 = this->upper_bound_values.begin(); _iter190 != this->upper_bound_values.end(); ++_iter190)
      {
        xfer += (*_iter190).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.is_upper_bound_inclusive) {
    xfer += oprot->writeFieldBegin("is_upper_bound_inclusive", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->is_upper_bound_inclusive);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TKuduPartitionByRangeParam::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_columns = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            this->columns.resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += iprot->readString(this->columns[_i199]);
            }
            xfer += iprot->readListEnd();
          }
          isset_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_partitions.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->range_partitions.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += this->range_partitions[_i204].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TKuduPartitionByRangeParam::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduPartitionByRangeParam");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter205;
    for (_iter205 = this->columns.begin(); _iter205 != this->columns.end(); ++_iter205)
    {
      xfer += oprot->writeString((*_iter205));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.range_partitions) {
    xfer += oprot->writeFieldBegin("range_partitions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->range_partitions.size()));
      std::vector<TRangePartition> ::const_iterator _iter206;
      for (_iter206 = this->range_partitions.begin(); _iter206 != this->range_partitions.end(); ++_iter206)
      {
        xfer += (*_iter206).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TKuduPartitionParam::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->by_hash_param.read(iprot);
          this->__isset.by_hash_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->by_range_param.read(iprot);
          this->__isset.by_range_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template <class Protocol_>
uint32_t TKuduPartitionParam::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduPartitionParam");

  if (this->__isset.by_hash_param) {
    xfer += oprot->writeFieldBegin("by_hash_param", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->by_hash_param.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.by_range_param) {
    xfer += oprot->writeFieldBegin("by_range_param", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->by_range_param.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TKuduTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_master_addresses = false;
  bool isset_key_columns = false;
  bool isset_partition_by = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->master_addresses.clear();
            uint32_t _size215;
            ::apache::thrift::protocol::TType _etype218;
            xfer += iprot->readListBegin(_etype218, _size215);
            this->master_addresses.resize(_size215);
            uint32_t _i219;
            for (_i219 = 0; _i219 < _size215; ++_i219)
            {
              xfer += iprot->readString(this->master_addresses[_i219]);
            }
            xfer += iprot->readListEnd();
          }
          isset_master_addresses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_columns.clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _etype223;
            xfer += iprot->readListBegin(_etype223, _size220);
            this->key_columns.resize(_size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              xfer += iprot->readString(this->key_columns[_i224]);
            }
            xfer += iprot->readListEnd();
          }
          isset_key_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_by.clear();
            uint32_t _size225;
            ::apache::thrift::protocol::TType _etype228;
            xfer += iprot->readListBegin(_etype228, _size225);
            this->partition_by.resize(_size225);
            uint32_t _i229;
            for (_i229 = 0; _i229 < _size225; ++_i229)
            {
              xfer += this->partition_by[_i229].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_by = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_master_addresses)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_columns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_by)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TKuduTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TKuduTable");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("master_addresses", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->master_addresses.size()));
    std::vector<std::string> ::const_iterator _iter230;
    for (_iter230 = this->master_addresses.begin(); _iter230 != this->master_addresses.end(); ++_iter230)
    {
      xfer += oprot->writeString((*_iter230));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->key_columns.size()));
    std::vector<std::string> ::const_iterator _iter231;
    for (_iter231 = this->key_columns.begin(); _iter231 != this->key_columns.end(); ++_iter231)
    {
      xfer += oprot->writeString((*_iter231));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_by", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_by.size()));
    std::vector<TKuduPartitionParam> ::const_iterator _iter232;
    for (_iter232 = this->partition_by.begin(); _iter232 != this->partition_by.end(); ++_iter232)
    {
      xfer += (*_iter232).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergPartitionTransform::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_transform_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast237;
          xfer += iprot->readI32(ecast237);
          this->transform_type = (TIcebergPartitionTransformType::type)ecast237;
          isset_transform_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->transform_param);
          this->__isset.transform_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_transform_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergPartitionTransform::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIcebergPartitionTransform");

  xfer += oprot->writeFieldBegin("transform_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->transform_type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.transform_param) {
    xfer += oprot->writeFieldBegin("transform_param", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->transform_param);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergPartitionField::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_source_id = false;
  bool isset_field_id = false;
  bool isset_orig_field_name = false;
  bool isset_field_name = false;
  bool isset_transform = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->source_id);
          isset_source_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          isset_field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->orig_field_name);
          isset_orig_field_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field_name);
          isset_field_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          isset_transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_source_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_field_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_orig_field_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_field_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_transform)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergPartitionField::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIcebergPartitionField");

  xfer += oprot->writeFieldBegin("source_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->source_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orig_field_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->orig_field_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("field_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->field_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergPartitionSpec::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_id);
          isset_partition_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_fields.clear();
            uint32_t _size246;
            ::apache::thrift::protocol::TType _etype249;
            xfer += iprot->readListBegin(_etype249, _size246);
            this->partition_fields.resize(_size246);
            uint32_t _i250;
            for (_i250 = 0; _i250 < _size246; ++_i250)
            {
              xfer += this->partition_fields[_i250].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergPartitionSpec::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIcebergPartitionSpec");

  xfer += oprot->writeFieldBegin("partition_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->partition_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.partition_fields) {
    xfer += oprot->writeFieldBegin("partition_fields", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_fields.size()));
      std::vector<TIcebergPartitionField> ::const_iterator _iter251;
      for (_iter251 = this->partition_fields.begin(); _iter251 != this->partition_fields.end(); ++_iter251)
      {
        xfer += (*_iter251).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_location = false;
  bool isset_partition_spec = false;
  bool isset_default_partition_spec_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_location);
          isset_table_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_spec.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _etype259;
            xfer += iprot->readListBegin(_etype259, _size256);
            this->partition_spec.resize(_size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              xfer += this->partition_spec[_i260].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_partition_spec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->default_partition_spec_id);
          isset_default_partition_spec_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->path_hash_to_file_descriptor.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _ktype262;
            ::apache::thrift::protocol::TType _vtype263;
            xfer += iprot->readMapBegin(_ktype262, _vtype263, _size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              std::string _key266;
              xfer += iprot->readString(_key266);
              THdfsFileDesc& _val267 = this->path_hash_to_file_descriptor[_key266];
              xfer += _val267.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.path_hash_to_file_descriptor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->snapshot_id);
          this->__isset.snapshot_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->parquet_compression_codec.read(iprot);
          this->__isset.parquet_compression_codec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->parquet_row_group_size);
          this->__isset.parquet_row_group_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->parquet_plain_page_size);
          this->__isset.parquet_plain_page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->parquet_dict_page_size);
          this->__isset.parquet_dict_page_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partition_spec)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_default_partition_spec_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TIcebergTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TIcebergTable");

  xfer += oprot->writeFieldBegin("table_location", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_location);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_spec", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partition_spec.size()));
    std::vector<TIcebergPartitionSpec> ::const_iterator _iter268;
    for (_iter268 = this->partition_spec.begin(); _iter268 != this->partition_spec.end(); ++_iter268)
    {
      xfer += (*_iter268).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("default_partition_spec_id", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->default_partition_spec_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.path_hash_to_file_descriptor) {
    xfer += oprot->writeFieldBegin("path_hash_to_file_descriptor", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->path_hash_to_file_descriptor.size()));
      std::map<std::string, THdfsFileDesc> ::const_iterator _iter269;
      for (_iter269 = this->path_hash_to_file_descriptor.begin(); _iter269 != this->path_hash_to_file_descriptor.end(); ++_iter269)
      {
        xfer += oprot->writeString(_iter269->first);
        xfer += _iter269->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.snapshot_id) {
    xfer += oprot->writeFieldBegin("snapshot_id", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->snapshot_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parquet_compression_codec) {
    xfer += oprot->writeFieldBegin("parquet_compression_codec", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->parquet_compression_codec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parquet_row_group_size) {
    xfer += oprot->writeFieldBegin("parquet_row_group_size", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->parquet_row_group_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parquet_plain_page_size) {
    xfer += oprot->writeFieldBegin("parquet_plain_page_size", ::apache::thrift::protocol::T_I64, 8);
    xfer += oprot->writeI64(this->parquet_plain_page_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parquet_dict_page_size) {
    xfer += oprot->writeFieldBegin("parquet_dict_page_size", ::apache::thrift::protocol::T_I64, 9);
    xfer += oprot->writeI64(this->parquet_dict_page_size);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TTable::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;
  bool isset_tbl_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tbl_name);
          isset_tbl_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->load_status.read(iprot);
          this->__isset.load_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast274;
          xfer += iprot->readI32(ecast274);
          this->access_level = (TAccessLevel::type)ecast274;
          this->__isset.access_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size275;
            ::apache::thrift::protocol::TType _etype278;
            xfer += iprot->readListBegin(_etype278, _size275);
            this->columns.resize(_size275);
            uint32_t _i279;
            for (_i279 = 0; _i279 < _size275; ++_i279)
            {
              xfer += this->columns[_i279].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->clustering_columns.clear();
            uint32_t _size280;
            ::apache::thrift::protocol::TType _etype283;
            xfer += iprot->readListBegin(_etype283, _size280);
            this->clustering_columns.resize(_size280);
            uint32_t _i284;
            for (_i284 = 0; _i284 < _size280; ++_i284)
            {
              xfer += this->clustering_columns[_i284].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.clustering_columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table_stats.read(iprot);
          this->__isset.table_stats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast285;
          xfer += iprot->readI32(ecast285);
          this->table_type = (TTableType::type)ecast285;
          this->__isset.table_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_table.read(iprot);
          this->__isset.hdfs_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hbase_table.read(iprot);
          this->__isset.hbase_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metastore_table.read(iprot);
          this->__isset.metastore_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source_table.read(iprot);
          this->__isset.data_source_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kudu_table.read(iprot);
          this->__isset.kudu_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->storage_metadata_load_time_ns);
          this->__isset.storage_metadata_load_time_ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->iceberg_table.read(iprot);
          this->__isset.iceberg_table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tbl_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TTable::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TTable");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tbl_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->tbl_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.load_status) {
    xfer += oprot->writeFieldBegin("load_status", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->load_status.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.access_level) {
    xfer += oprot->writeFieldBegin("access_level", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->access_level);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
      std::vector<TColumn> ::const_iterator _iter286;
      for (_iter286 = this->columns.begin(); _iter286 != this->columns.end(); ++_iter286)
      {
        xfer += (*_iter286).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clustering_columns) {
    xfer += oprot->writeFieldBegin("clustering_columns", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->clustering_columns.size()));
      std::vector<TColumn> ::const_iterator _iter287;
      for (_iter287 = this->clustering_columns.begin(); _iter287 != this->clustering_columns.end(); ++_iter287)
      {
        xfer += (*_iter287).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_stats) {
    xfer += oprot->writeFieldBegin("table_stats", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->table_stats.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_type) {
    xfer += oprot->writeFieldBegin("table_type", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->table_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_table) {
    xfer += oprot->writeFieldBegin("hdfs_table", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->hdfs_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hbase_table) {
    xfer += oprot->writeFieldBegin("hbase_table", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->hbase_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.metastore_table) {
    xfer += oprot->writeFieldBegin("metastore_table", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->metastore_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_source_table) {
    xfer += oprot->writeFieldBegin("data_source_table", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->data_source_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kudu_table) {
    xfer += oprot->writeFieldBegin("kudu_table", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->kudu_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.storage_metadata_load_time_ns) {
    xfer += oprot->writeFieldBegin("storage_metadata_load_time_ns", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->storage_metadata_load_time_ns);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.iceberg_table) {
    xfer += oprot->writeFieldBegin("iceberg_table", ::apache::thrift::protocol::T_STRUCT, 16);
    xfer += this->iceberg_table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TDatabase::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_db_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          isset_db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metastore_db.read(iprot);
          this->__isset.metastore_db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_db_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TDatabase::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TDatabase");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metastore_db) {
    xfer += oprot->writeFieldBegin("metastore_db", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->metastore_db.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPrincipal::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_principal_name = false;
  bool isset_principal_id = false;
  bool isset_principal_type = false;
  bool isset_grant_groups = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->principal_name);
          isset_principal_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->principal_id);
          isset_principal_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast296;
          xfer += iprot->readI32(ecast296);
          this->principal_type = (TPrincipalType::type)ecast296;
          isset_principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grant_groups.clear();
            uint32_t _size297;
            ::apache::thrift::protocol::TType _etype300;
            xfer += iprot->readListBegin(_etype300, _size297);
            this->grant_groups.resize(_size297);
            uint32_t _i301;
            for (_i301 = 0; _i301 < _size297; ++_i301)
            {
              xfer += iprot->readString(this->grant_groups[_i301]);
            }
            xfer += iprot->readListEnd();
          }
          isset_grant_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_principal_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_principal_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_grant_groups)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPrincipal::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPrincipal");

  xfer += oprot->writeFieldBegin("principal_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->principal_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->principal_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->principal_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grant_groups", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->grant_groups.size()));
    std::vector<std::string> ::const_iterator _iter302;
    for (_iter302 = this->grant_groups.begin(); _iter302 != this->grant_groups.end(); ++_iter302)
    {
      xfer += oprot->writeString((*_iter302));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TPrivilege::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_privilege_level = false;
  bool isset_scope = false;
  bool isset_has_grant_opt = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast307;
          xfer += iprot->readI32(ecast307);
          this->privilege_level = (TPrivilegeLevel::type)ecast307;
          isset_privilege_level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast308;
          xfer += iprot->readI32(ecast308);
          this->scope = (TPrivilegeScope::type)ecast308;
          isset_scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_grant_opt);
          isset_has_grant_opt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->principal_id);
          this->__isset.principal_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast309;
          xfer += iprot->readI32(ecast309);
          this->principal_type = (TPrincipalType::type)ecast309;
          this->__isset.principal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_name);
          this->__isset.server_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->create_time_ms);
          this->__isset.create_time_ms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_privilege_level)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scope)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_has_grant_opt)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TPrivilege::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TPrivilege");

  xfer += oprot->writeFieldBegin("privilege_level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->privilege_level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->scope);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_grant_opt", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->has_grant_opt);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.principal_id) {
    xfer += oprot->writeFieldBegin("principal_id", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->principal_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.principal_type) {
    xfer += oprot->writeFieldBegin("principal_type", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32((int32_t)this->principal_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.server_name) {
    xfer += oprot->writeFieldBegin("server_name", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->server_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db_name) {
    xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->db_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table_name) {
    xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->table_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.uri) {
    xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->uri);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.create_time_ms) {
    xfer += oprot->writeFieldBegin("create_time_ms", ::apache::thrift::protocol::T_I64, 11);
    xfer += oprot->writeI64(this->create_time_ms);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_name) {
    xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->column_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t THdfsCachePool::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pool_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pool_name);
          isset_pool_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pool_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t THdfsCachePool::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THdfsCachePool");

  xfer += oprot->writeFieldBegin("pool_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->pool_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TAuthzCacheInvalidation::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_marker_name = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->marker_name);
          isset_marker_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_marker_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TAuthzCacheInvalidation::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TAuthzCacheInvalidation");

  xfer += oprot->writeFieldBegin("marker_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->marker_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalog::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_catalog_service_id = false;
  bool isset_last_reset_catalog_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog_service_id.read(iprot);
          isset_catalog_service_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_reset_catalog_version);
          isset_last_reset_catalog_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_catalog_service_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_last_reset_catalog_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCatalog::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalog");

  xfer += oprot->writeFieldBegin("catalog_service_id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->catalog_service_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_reset_catalog_version", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->last_reset_catalog_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogObject::read(Protocol_* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_catalog_version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast326;
          xfer += iprot->readI32(ecast326);
          this->type = (TCatalogObjectType::type)ecast326;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->catalog_version);
          isset_catalog_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalog.read(iprot);
          this->__isset.catalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->db.read(iprot);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->table.read(iprot);
          this->__isset.table = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fn.read(iprot);
          this->__isset.fn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_source.read(iprot);
          this->__isset.data_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->principal.read(iprot);
          this->__isset.principal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->privilege.read(iprot);
          this->__isset.privilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cache_pool.read(iprot);
          this->__isset.cache_pool = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authz_cache_invalidation.read(iprot);
          this->__isset.authz_cache_invalidation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hdfs_partition.read(iprot);
          this->__isset.hdfs_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_catalog_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template <class Protocol_>
uint32_t TCatalogObject::write(Protocol_* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TCatalogObject");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("catalog_version", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->catalog_version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.catalog) {
    xfer += oprot->writeFieldBegin("catalog", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->catalog.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.db) {
    xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->db.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.table) {
    xfer += oprot->writeFieldBegin("table", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->table.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fn) {
    xfer += oprot->writeFieldBegin("fn", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->fn.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data_source) {
    xfer += oprot->writeFieldBegin("data_source", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->data_source.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.principal) {
    xfer += oprot->writeFieldBegin("principal", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->principal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.privilege) {
    xfer += oprot->writeFieldBegin("privilege", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->privilege.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cache_pool) {
    xfer += oprot->writeFieldBegin("cache_pool", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->cache_pool.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.authz_cache_invalidation) {
    xfer += oprot->writeFieldBegin("authz_cache_invalidation", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->authz_cache_invalidation.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hdfs_partition) {
    xfer += oprot->writeFieldBegin("hdfs_partition", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->hdfs_partition.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

} // namespace

#endif
