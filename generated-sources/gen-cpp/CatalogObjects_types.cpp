/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CatalogObjects_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace impala {

int _kTCatalogObjectTypeValues[] = {
  TCatalogObjectType::UNKNOWN,
  TCatalogObjectType::CATALOG,
  TCatalogObjectType::DATABASE,
  TCatalogObjectType::TABLE,
  TCatalogObjectType::VIEW,
  TCatalogObjectType::FUNCTION,
  TCatalogObjectType::DATA_SOURCE,
  TCatalogObjectType::PRINCIPAL,
  TCatalogObjectType::PRIVILEGE,
  TCatalogObjectType::HDFS_CACHE_POOL,
  TCatalogObjectType::AUTHZ_CACHE_INVALIDATION,
  TCatalogObjectType::HDFS_PARTITION
};
const char* _kTCatalogObjectTypeNames[] = {
  "UNKNOWN",
  "CATALOG",
  "DATABASE",
  "TABLE",
  "VIEW",
  "FUNCTION",
  "DATA_SOURCE",
  "PRINCIPAL",
  "PRIVILEGE",
  "HDFS_CACHE_POOL",
  "AUTHZ_CACHE_INVALIDATION",
  "HDFS_PARTITION"
};
const std::map<int, const char*> _TCatalogObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kTCatalogObjectTypeValues, _kTCatalogObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TCatalogObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _TCatalogObjectType_VALUES_TO_NAMES.find(val);
  if (it != _TCatalogObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTTableTypeValues[] = {
  TTableType::HDFS_TABLE,
  TTableType::HBASE_TABLE,
  TTableType::VIEW,
  TTableType::DATA_SOURCE_TABLE,
  TTableType::KUDU_TABLE,
  TTableType::ICEBERG_TABLE
};
const char* _kTTableTypeNames[] = {
  "HDFS_TABLE",
  "HBASE_TABLE",
  "VIEW",
  "DATA_SOURCE_TABLE",
  "KUDU_TABLE",
  "ICEBERG_TABLE"
};
const std::map<int, const char*> _TTableType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTTableTypeValues, _kTTableTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TTableType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTableType_VALUES_TO_NAMES.find(val);
  if (it != _TTableType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTHdfsFileFormatValues[] = {
  THdfsFileFormat::TEXT,
  THdfsFileFormat::RC_FILE,
  THdfsFileFormat::SEQUENCE_FILE,
  THdfsFileFormat::AVRO,
  THdfsFileFormat::PARQUET,
  THdfsFileFormat::KUDU,
  THdfsFileFormat::ORC,
  THdfsFileFormat::HUDI_PARQUET,
  THdfsFileFormat::ICEBERG,
  THdfsFileFormat::JSON
};
const char* _kTHdfsFileFormatNames[] = {
  "TEXT",
  "RC_FILE",
  "SEQUENCE_FILE",
  "AVRO",
  "PARQUET",
  "KUDU",
  "ORC",
  "HUDI_PARQUET",
  "ICEBERG",
  "JSON"
};
const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kTHdfsFileFormatValues, _kTHdfsFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const THdfsFileFormat::type& val) {
  std::map<int, const char*>::const_iterator it = _THdfsFileFormat_VALUES_TO_NAMES.find(val);
  if (it != _THdfsFileFormat_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTHdfsCompressionValues[] = {
  THdfsCompression::NONE,
  THdfsCompression::DEFAULT,
  THdfsCompression::GZIP,
  THdfsCompression::DEFLATE,
  THdfsCompression::BZIP2,
  THdfsCompression::SNAPPY,
  THdfsCompression::SNAPPY_BLOCKED,
  THdfsCompression::LZO,
  THdfsCompression::LZ4,
  THdfsCompression::ZLIB,
  THdfsCompression::ZSTD,
  THdfsCompression::BROTLI,
  THdfsCompression::LZ4_BLOCKED
};
const char* _kTHdfsCompressionNames[] = {
  "NONE",
  "DEFAULT",
  "GZIP",
  "DEFLATE",
  "BZIP2",
  "SNAPPY",
  "SNAPPY_BLOCKED",
  "LZO",
  "LZ4",
  "ZLIB",
  "ZSTD",
  "BROTLI",
  "LZ4_BLOCKED"
};
const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(13, _kTHdfsCompressionValues, _kTHdfsCompressionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const THdfsCompression::type& val) {
  std::map<int, const char*>::const_iterator it = _THdfsCompression_VALUES_TO_NAMES.find(val);
  if (it != _THdfsCompression_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTIcebergFileFormatValues[] = {
  TIcebergFileFormat::PARQUET,
  TIcebergFileFormat::ORC
};
const char* _kTIcebergFileFormatNames[] = {
  "PARQUET",
  "ORC"
};
const std::map<int, const char*> _TIcebergFileFormat_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTIcebergFileFormatValues, _kTIcebergFileFormatNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TIcebergFileFormat::type& val) {
  std::map<int, const char*>::const_iterator it = _TIcebergFileFormat_VALUES_TO_NAMES.find(val);
  if (it != _TIcebergFileFormat_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTIcebergCatalogValues[] = {
  TIcebergCatalog::HADOOP_TABLES,
  TIcebergCatalog::HADOOP_CATALOG,
  TIcebergCatalog::HIVE_CATALOG,
  TIcebergCatalog::CATALOGS
};
const char* _kTIcebergCatalogNames[] = {
  "HADOOP_TABLES",
  "HADOOP_CATALOG",
  "HIVE_CATALOG",
  "CATALOGS"
};
const std::map<int, const char*> _TIcebergCatalog_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTIcebergCatalogValues, _kTIcebergCatalogNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TIcebergCatalog::type& val) {
  std::map<int, const char*>::const_iterator it = _TIcebergCatalog_VALUES_TO_NAMES.find(val);
  if (it != _TIcebergCatalog_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTColumnEncodingValues[] = {
  TColumnEncoding::AUTO,
  TColumnEncoding::PLAIN,
  TColumnEncoding::PREFIX,
  TColumnEncoding::GROUP_VARINT,
  TColumnEncoding::RLE,
  TColumnEncoding::DICTIONARY,
  TColumnEncoding::BIT_SHUFFLE
};
const char* _kTColumnEncodingNames[] = {
  "AUTO",
  "PLAIN",
  "PREFIX",
  "GROUP_VARINT",
  "RLE",
  "DICTIONARY",
  "BIT_SHUFFLE"
};
const std::map<int, const char*> _TColumnEncoding_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kTColumnEncodingValues, _kTColumnEncodingNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TColumnEncoding::type& val) {
  std::map<int, const char*>::const_iterator it = _TColumnEncoding_VALUES_TO_NAMES.find(val);
  if (it != _TColumnEncoding_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTHdfsSeqCompressionModeValues[] = {
  THdfsSeqCompressionMode::RECORD,
  THdfsSeqCompressionMode::BLOCK
};
const char* _kTHdfsSeqCompressionModeNames[] = {
  "RECORD",
  "BLOCK"
};
const std::map<int, const char*> _THdfsSeqCompressionMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTHdfsSeqCompressionModeValues, _kTHdfsSeqCompressionModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const THdfsSeqCompressionMode::type& val) {
  std::map<int, const char*>::const_iterator it = _THdfsSeqCompressionMode_VALUES_TO_NAMES.find(val);
  if (it != _THdfsSeqCompressionMode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTTablePropertyTypeValues[] = {
  TTablePropertyType::TBL_PROPERTY,
  TTablePropertyType::SERDE_PROPERTY
};
const char* _kTTablePropertyTypeNames[] = {
  "TBL_PROPERTY",
  "SERDE_PROPERTY"
};
const std::map<int, const char*> _TTablePropertyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTTablePropertyTypeValues, _kTTablePropertyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TTablePropertyType::type& val) {
  std::map<int, const char*>::const_iterator it = _TTablePropertyType_VALUES_TO_NAMES.find(val);
  if (it != _TTablePropertyType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTAccessLevelValues[] = {
  TAccessLevel::NONE,
  TAccessLevel::READ_WRITE,
  TAccessLevel::READ_ONLY,
  TAccessLevel::WRITE_ONLY
};
const char* _kTAccessLevelNames[] = {
  "NONE",
  "READ_WRITE",
  "READ_ONLY",
  "WRITE_ONLY"
};
const std::map<int, const char*> _TAccessLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTAccessLevelValues, _kTAccessLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TAccessLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _TAccessLevel_VALUES_TO_NAMES.find(val);
  if (it != _TAccessLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTIcebergPartitionTransformTypeValues[] = {
  TIcebergPartitionTransformType::IDENTITY,
  TIcebergPartitionTransformType::HOUR,
  TIcebergPartitionTransformType::DAY,
  TIcebergPartitionTransformType::MONTH,
  TIcebergPartitionTransformType::YEAR,
  TIcebergPartitionTransformType::BUCKET,
  TIcebergPartitionTransformType::TRUNCATE,
  TIcebergPartitionTransformType::VOID
};
const char* _kTIcebergPartitionTransformTypeNames[] = {
  "IDENTITY",
  "HOUR",
  "DAY",
  "MONTH",
  "YEAR",
  "BUCKET",
  "TRUNCATE",
  "VOID"
};
const std::map<int, const char*> _TIcebergPartitionTransformType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTIcebergPartitionTransformTypeValues, _kTIcebergPartitionTransformTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TIcebergPartitionTransformType::type& val) {
  std::map<int, const char*>::const_iterator it = _TIcebergPartitionTransformType_VALUES_TO_NAMES.find(val);
  if (it != _TIcebergPartitionTransformType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPrincipalTypeValues[] = {
  TPrincipalType::ROLE,
  TPrincipalType::USER,
  TPrincipalType::GROUP
};
const char* _kTPrincipalTypeNames[] = {
  "ROLE",
  "USER",
  "GROUP"
};
const std::map<int, const char*> _TPrincipalType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTPrincipalTypeValues, _kTPrincipalTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPrincipalType::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrincipalType_VALUES_TO_NAMES.find(val);
  if (it != _TPrincipalType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPrivilegeScopeValues[] = {
  TPrivilegeScope::SERVER,
  TPrivilegeScope::URI,
  TPrivilegeScope::DATABASE,
  TPrivilegeScope::TABLE,
  TPrivilegeScope::COLUMN
};
const char* _kTPrivilegeScopeNames[] = {
  "SERVER",
  "URI",
  "DATABASE",
  "TABLE",
  "COLUMN"
};
const std::map<int, const char*> _TPrivilegeScope_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTPrivilegeScopeValues, _kTPrivilegeScopeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPrivilegeScope::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrivilegeScope_VALUES_TO_NAMES.find(val);
  if (it != _TPrivilegeScope_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTPrivilegeLevelValues[] = {
  TPrivilegeLevel::ALL,
  TPrivilegeLevel::INSERT,
  TPrivilegeLevel::SELECT,
  TPrivilegeLevel::REFRESH,
  TPrivilegeLevel::CREATE,
  TPrivilegeLevel::ALTER,
  TPrivilegeLevel::DROP,
  TPrivilegeLevel::OWNER
};
const char* _kTPrivilegeLevelNames[] = {
  "ALL",
  "INSERT",
  "SELECT",
  "REFRESH",
  "CREATE",
  "ALTER",
  "DROP",
  "OWNER"
};
const std::map<int, const char*> _TPrivilegeLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTPrivilegeLevelValues, _kTPrivilegeLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TPrivilegeLevel::type& val) {
  std::map<int, const char*>::const_iterator it = _TPrivilegeLevel_VALUES_TO_NAMES.find(val);
  if (it != _TPrivilegeLevel_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


TCompressionCodec::~TCompressionCodec() throw() {
}


void TCompressionCodec::__set_codec(const THdfsCompression::type val) {
  this->codec = val;
}

void TCompressionCodec::__set_compression_level(const int32_t val) {
  this->compression_level = val;
__isset.compression_level = true;
}
std::ostream& operator<<(std::ostream& out, const TCompressionCodec& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCompressionCodec &a, TCompressionCodec &b) {
  using ::std::swap;
  swap(a.codec, b.codec);
  swap(a.compression_level, b.compression_level);
  swap(a.__isset, b.__isset);
}

TCompressionCodec::TCompressionCodec(const TCompressionCodec& other1) {
  codec = other1.codec;
  compression_level = other1.compression_level;
  __isset = other1.__isset;
}
TCompressionCodec::TCompressionCodec( TCompressionCodec&& other2) {
  codec = std::move(other2.codec);
  compression_level = std::move(other2.compression_level);
  __isset = std::move(other2.__isset);
}
TCompressionCodec& TCompressionCodec::operator=(const TCompressionCodec& other3) {
  codec = other3.codec;
  compression_level = other3.compression_level;
  __isset = other3.__isset;
  return *this;
}
TCompressionCodec& TCompressionCodec::operator=(TCompressionCodec&& other4) {
  codec = std::move(other4.codec);
  compression_level = std::move(other4.compression_level);
  __isset = std::move(other4.__isset);
  return *this;
}
void TCompressionCodec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCompressionCodec(";
  out << "codec=" << to_string(codec);
  out << ", " << "compression_level="; (__isset.compression_level ? (out << to_string(compression_level)) : (out << "<null>"));
  out << ")";
}


TPartitionKeyValue::~TPartitionKeyValue() throw() {
}


void TPartitionKeyValue::__set_name(const std::string& val) {
  this->name = val;
}

void TPartitionKeyValue::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const TPartitionKeyValue& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPartitionKeyValue &a, TPartitionKeyValue &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
}

TPartitionKeyValue::TPartitionKeyValue(const TPartitionKeyValue& other5) {
  name = other5.name;
  value = other5.value;
}
TPartitionKeyValue::TPartitionKeyValue( TPartitionKeyValue&& other6) {
  name = std::move(other6.name);
  value = std::move(other6.value);
}
TPartitionKeyValue& TPartitionKeyValue::operator=(const TPartitionKeyValue& other7) {
  name = other7.name;
  value = other7.value;
  return *this;
}
TPartitionKeyValue& TPartitionKeyValue::operator=(TPartitionKeyValue&& other8) {
  name = std::move(other8.name);
  value = std::move(other8.value);
  return *this;
}
void TPartitionKeyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPartitionKeyValue(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


TTableName::~TTableName() throw() {
}


void TTableName::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TTableName::__set_table_name(const std::string& val) {
  this->table_name = val;
}
std::ostream& operator<<(std::ostream& out, const TTableName& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTableName &a, TTableName &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
}

TTableName::TTableName(const TTableName& other9) {
  db_name = other9.db_name;
  table_name = other9.table_name;
}
TTableName::TTableName( TTableName&& other10) {
  db_name = std::move(other10.db_name);
  table_name = std::move(other10.table_name);
}
TTableName& TTableName::operator=(const TTableName& other11) {
  db_name = other11.db_name;
  table_name = other11.table_name;
  return *this;
}
TTableName& TTableName::operator=(TTableName&& other12) {
  db_name = std::move(other12.db_name);
  table_name = std::move(other12.table_name);
  return *this;
}
void TTableName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableName(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ")";
}


TTableStats::~TTableStats() throw() {
}


void TTableStats::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void TTableStats::__set_total_file_bytes(const int64_t val) {
  this->total_file_bytes = val;
__isset.total_file_bytes = true;
}
std::ostream& operator<<(std::ostream& out, const TTableStats& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTableStats &a, TTableStats &b) {
  using ::std::swap;
  swap(a.num_rows, b.num_rows);
  swap(a.total_file_bytes, b.total_file_bytes);
  swap(a.__isset, b.__isset);
}

TTableStats::TTableStats(const TTableStats& other13) {
  num_rows = other13.num_rows;
  total_file_bytes = other13.total_file_bytes;
  __isset = other13.__isset;
}
TTableStats::TTableStats( TTableStats&& other14) {
  num_rows = std::move(other14.num_rows);
  total_file_bytes = std::move(other14.total_file_bytes);
  __isset = std::move(other14.__isset);
}
TTableStats& TTableStats::operator=(const TTableStats& other15) {
  num_rows = other15.num_rows;
  total_file_bytes = other15.total_file_bytes;
  __isset = other15.__isset;
  return *this;
}
TTableStats& TTableStats::operator=(TTableStats&& other16) {
  num_rows = std::move(other16.num_rows);
  total_file_bytes = std::move(other16.total_file_bytes);
  __isset = std::move(other16.__isset);
  return *this;
}
void TTableStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTableStats(";
  out << "num_rows=" << to_string(num_rows);
  out << ", " << "total_file_bytes="; (__isset.total_file_bytes ? (out << to_string(total_file_bytes)) : (out << "<null>"));
  out << ")";
}


TColumnStats::~TColumnStats() throw() {
}


void TColumnStats::__set_avg_size(const double val) {
  this->avg_size = val;
}

void TColumnStats::__set_max_size(const int64_t val) {
  this->max_size = val;
}

void TColumnStats::__set_num_distinct_values(const int64_t val) {
  this->num_distinct_values = val;
}

void TColumnStats::__set_num_nulls(const int64_t val) {
  this->num_nulls = val;
}

void TColumnStats::__set_num_trues(const int64_t val) {
  this->num_trues = val;
}

void TColumnStats::__set_num_falses(const int64_t val) {
  this->num_falses = val;
}

void TColumnStats::__set_low_value(const  ::impala::TColumnValue& val) {
  this->low_value = val;
__isset.low_value = true;
}

void TColumnStats::__set_high_value(const  ::impala::TColumnValue& val) {
  this->high_value = val;
__isset.high_value = true;
}
std::ostream& operator<<(std::ostream& out, const TColumnStats& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TColumnStats &a, TColumnStats &b) {
  using ::std::swap;
  swap(a.avg_size, b.avg_size);
  swap(a.max_size, b.max_size);
  swap(a.num_distinct_values, b.num_distinct_values);
  swap(a.num_nulls, b.num_nulls);
  swap(a.num_trues, b.num_trues);
  swap(a.num_falses, b.num_falses);
  swap(a.low_value, b.low_value);
  swap(a.high_value, b.high_value);
  swap(a.__isset, b.__isset);
}

TColumnStats::TColumnStats(const TColumnStats& other17) {
  avg_size = other17.avg_size;
  max_size = other17.max_size;
  num_distinct_values = other17.num_distinct_values;
  num_nulls = other17.num_nulls;
  num_trues = other17.num_trues;
  num_falses = other17.num_falses;
  low_value = other17.low_value;
  high_value = other17.high_value;
  __isset = other17.__isset;
}
TColumnStats::TColumnStats( TColumnStats&& other18) {
  avg_size = std::move(other18.avg_size);
  max_size = std::move(other18.max_size);
  num_distinct_values = std::move(other18.num_distinct_values);
  num_nulls = std::move(other18.num_nulls);
  num_trues = std::move(other18.num_trues);
  num_falses = std::move(other18.num_falses);
  low_value = std::move(other18.low_value);
  high_value = std::move(other18.high_value);
  __isset = std::move(other18.__isset);
}
TColumnStats& TColumnStats::operator=(const TColumnStats& other19) {
  avg_size = other19.avg_size;
  max_size = other19.max_size;
  num_distinct_values = other19.num_distinct_values;
  num_nulls = other19.num_nulls;
  num_trues = other19.num_trues;
  num_falses = other19.num_falses;
  low_value = other19.low_value;
  high_value = other19.high_value;
  __isset = other19.__isset;
  return *this;
}
TColumnStats& TColumnStats::operator=(TColumnStats&& other20) {
  avg_size = std::move(other20.avg_size);
  max_size = std::move(other20.max_size);
  num_distinct_values = std::move(other20.num_distinct_values);
  num_nulls = std::move(other20.num_nulls);
  num_trues = std::move(other20.num_trues);
  num_falses = std::move(other20.num_falses);
  low_value = std::move(other20.low_value);
  high_value = std::move(other20.high_value);
  __isset = std::move(other20.__isset);
  return *this;
}
void TColumnStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumnStats(";
  out << "avg_size=" << to_string(avg_size);
  out << ", " << "max_size=" << to_string(max_size);
  out << ", " << "num_distinct_values=" << to_string(num_distinct_values);
  out << ", " << "num_nulls=" << to_string(num_nulls);
  out << ", " << "num_trues=" << to_string(num_trues);
  out << ", " << "num_falses=" << to_string(num_falses);
  out << ", " << "low_value="; (__isset.low_value ? (out << to_string(low_value)) : (out << "<null>"));
  out << ", " << "high_value="; (__isset.high_value ? (out << to_string(high_value)) : (out << "<null>"));
  out << ")";
}


TIntermediateColumnStats::~TIntermediateColumnStats() throw() {
}


void TIntermediateColumnStats::__set_intermediate_ndv(const std::string& val) {
  this->intermediate_ndv = val;
__isset.intermediate_ndv = true;
}

void TIntermediateColumnStats::__set_is_ndv_encoded(const bool val) {
  this->is_ndv_encoded = val;
__isset.is_ndv_encoded = true;
}

void TIntermediateColumnStats::__set_num_nulls(const int64_t val) {
  this->num_nulls = val;
__isset.num_nulls = true;
}

void TIntermediateColumnStats::__set_max_width(const int32_t val) {
  this->max_width = val;
__isset.max_width = true;
}

void TIntermediateColumnStats::__set_avg_width(const double val) {
  this->avg_width = val;
__isset.avg_width = true;
}

void TIntermediateColumnStats::__set_num_rows(const int64_t val) {
  this->num_rows = val;
__isset.num_rows = true;
}

void TIntermediateColumnStats::__set_num_trues(const int64_t val) {
  this->num_trues = val;
}

void TIntermediateColumnStats::__set_num_falses(const int64_t val) {
  this->num_falses = val;
}

void TIntermediateColumnStats::__set_low_value(const  ::impala::TColumnValue& val) {
  this->low_value = val;
__isset.low_value = true;
}

void TIntermediateColumnStats::__set_high_value(const  ::impala::TColumnValue& val) {
  this->high_value = val;
__isset.high_value = true;
}
std::ostream& operator<<(std::ostream& out, const TIntermediateColumnStats& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIntermediateColumnStats &a, TIntermediateColumnStats &b) {
  using ::std::swap;
  swap(a.intermediate_ndv, b.intermediate_ndv);
  swap(a.is_ndv_encoded, b.is_ndv_encoded);
  swap(a.num_nulls, b.num_nulls);
  swap(a.max_width, b.max_width);
  swap(a.avg_width, b.avg_width);
  swap(a.num_rows, b.num_rows);
  swap(a.num_trues, b.num_trues);
  swap(a.num_falses, b.num_falses);
  swap(a.low_value, b.low_value);
  swap(a.high_value, b.high_value);
  swap(a.__isset, b.__isset);
}

TIntermediateColumnStats::TIntermediateColumnStats(const TIntermediateColumnStats& other21) {
  intermediate_ndv = other21.intermediate_ndv;
  is_ndv_encoded = other21.is_ndv_encoded;
  num_nulls = other21.num_nulls;
  max_width = other21.max_width;
  avg_width = other21.avg_width;
  num_rows = other21.num_rows;
  num_trues = other21.num_trues;
  num_falses = other21.num_falses;
  low_value = other21.low_value;
  high_value = other21.high_value;
  __isset = other21.__isset;
}
TIntermediateColumnStats::TIntermediateColumnStats( TIntermediateColumnStats&& other22) {
  intermediate_ndv = std::move(other22.intermediate_ndv);
  is_ndv_encoded = std::move(other22.is_ndv_encoded);
  num_nulls = std::move(other22.num_nulls);
  max_width = std::move(other22.max_width);
  avg_width = std::move(other22.avg_width);
  num_rows = std::move(other22.num_rows);
  num_trues = std::move(other22.num_trues);
  num_falses = std::move(other22.num_falses);
  low_value = std::move(other22.low_value);
  high_value = std::move(other22.high_value);
  __isset = std::move(other22.__isset);
}
TIntermediateColumnStats& TIntermediateColumnStats::operator=(const TIntermediateColumnStats& other23) {
  intermediate_ndv = other23.intermediate_ndv;
  is_ndv_encoded = other23.is_ndv_encoded;
  num_nulls = other23.num_nulls;
  max_width = other23.max_width;
  avg_width = other23.avg_width;
  num_rows = other23.num_rows;
  num_trues = other23.num_trues;
  num_falses = other23.num_falses;
  low_value = other23.low_value;
  high_value = other23.high_value;
  __isset = other23.__isset;
  return *this;
}
TIntermediateColumnStats& TIntermediateColumnStats::operator=(TIntermediateColumnStats&& other24) {
  intermediate_ndv = std::move(other24.intermediate_ndv);
  is_ndv_encoded = std::move(other24.is_ndv_encoded);
  num_nulls = std::move(other24.num_nulls);
  max_width = std::move(other24.max_width);
  avg_width = std::move(other24.avg_width);
  num_rows = std::move(other24.num_rows);
  num_trues = std::move(other24.num_trues);
  num_falses = std::move(other24.num_falses);
  low_value = std::move(other24.low_value);
  high_value = std::move(other24.high_value);
  __isset = std::move(other24.__isset);
  return *this;
}
void TIntermediateColumnStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIntermediateColumnStats(";
  out << "intermediate_ndv="; (__isset.intermediate_ndv ? (out << to_string(intermediate_ndv)) : (out << "<null>"));
  out << ", " << "is_ndv_encoded="; (__isset.is_ndv_encoded ? (out << to_string(is_ndv_encoded)) : (out << "<null>"));
  out << ", " << "num_nulls="; (__isset.num_nulls ? (out << to_string(num_nulls)) : (out << "<null>"));
  out << ", " << "max_width="; (__isset.max_width ? (out << to_string(max_width)) : (out << "<null>"));
  out << ", " << "avg_width="; (__isset.avg_width ? (out << to_string(avg_width)) : (out << "<null>"));
  out << ", " << "num_rows="; (__isset.num_rows ? (out << to_string(num_rows)) : (out << "<null>"));
  out << ", " << "num_trues=" << to_string(num_trues);
  out << ", " << "num_falses=" << to_string(num_falses);
  out << ", " << "low_value="; (__isset.low_value ? (out << to_string(low_value)) : (out << "<null>"));
  out << ", " << "high_value="; (__isset.high_value ? (out << to_string(high_value)) : (out << "<null>"));
  out << ")";
}


TPartitionStats::~TPartitionStats() throw() {
}


void TPartitionStats::__set_stats(const TTableStats& val) {
  this->stats = val;
}

void TPartitionStats::__set_intermediate_col_stats(const std::map<std::string, TIntermediateColumnStats> & val) {
  this->intermediate_col_stats = val;
__isset.intermediate_col_stats = true;
}
std::ostream& operator<<(std::ostream& out, const TPartitionStats& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPartitionStats &a, TPartitionStats &b) {
  using ::std::swap;
  swap(a.stats, b.stats);
  swap(a.intermediate_col_stats, b.intermediate_col_stats);
  swap(a.__isset, b.__isset);
}

TPartitionStats::TPartitionStats(const TPartitionStats& other33) {
  stats = other33.stats;
  intermediate_col_stats = other33.intermediate_col_stats;
  __isset = other33.__isset;
}
TPartitionStats::TPartitionStats( TPartitionStats&& other34) {
  stats = std::move(other34.stats);
  intermediate_col_stats = std::move(other34.intermediate_col_stats);
  __isset = std::move(other34.__isset);
}
TPartitionStats& TPartitionStats::operator=(const TPartitionStats& other35) {
  stats = other35.stats;
  intermediate_col_stats = other35.intermediate_col_stats;
  __isset = other35.__isset;
  return *this;
}
TPartitionStats& TPartitionStats::operator=(TPartitionStats&& other36) {
  stats = std::move(other36.stats);
  intermediate_col_stats = std::move(other36.intermediate_col_stats);
  __isset = std::move(other36.__isset);
  return *this;
}
void TPartitionStats::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPartitionStats(";
  out << "stats=" << to_string(stats);
  out << ", " << "intermediate_col_stats="; (__isset.intermediate_col_stats ? (out << to_string(intermediate_col_stats)) : (out << "<null>"));
  out << ")";
}


TColumn::~TColumn() throw() {
}


void TColumn::__set_columnName(const std::string& val) {
  this->columnName = val;
}

void TColumn::__set_columnType(const  ::impala::TColumnType& val) {
  this->columnType = val;
}

void TColumn::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void TColumn::__set_col_stats(const TColumnStats& val) {
  this->col_stats = val;
__isset.col_stats = true;
}

void TColumn::__set_position(const int32_t val) {
  this->position = val;
__isset.position = true;
}

void TColumn::__set_is_hbase_column(const bool val) {
  this->is_hbase_column = val;
__isset.is_hbase_column = true;
}

void TColumn::__set_column_family(const std::string& val) {
  this->column_family = val;
__isset.column_family = true;
}

void TColumn::__set_column_qualifier(const std::string& val) {
  this->column_qualifier = val;
__isset.column_qualifier = true;
}

void TColumn::__set_is_binary(const bool val) {
  this->is_binary = val;
__isset.is_binary = true;
}

void TColumn::__set_is_kudu_column(const bool val) {
  this->is_kudu_column = val;
__isset.is_kudu_column = true;
}

void TColumn::__set_is_key(const bool val) {
  this->is_key = val;
__isset.is_key = true;
}

void TColumn::__set_is_nullable(const bool val) {
  this->is_nullable = val;
__isset.is_nullable = true;
}

void TColumn::__set_encoding(const TColumnEncoding::type val) {
  this->encoding = val;
__isset.encoding = true;
}

void TColumn::__set_compression(const THdfsCompression::type val) {
  this->compression = val;
__isset.compression = true;
}

void TColumn::__set_default_value(const  ::impala::TExpr& val) {
  this->default_value = val;
__isset.default_value = true;
}

void TColumn::__set_block_size(const int32_t val) {
  this->block_size = val;
__isset.block_size = true;
}

void TColumn::__set_kudu_column_name(const std::string& val) {
  this->kudu_column_name = val;
__isset.kudu_column_name = true;
}

void TColumn::__set_is_iceberg_column(const bool val) {
  this->is_iceberg_column = val;
__isset.is_iceberg_column = true;
}

void TColumn::__set_iceberg_field_id(const int32_t val) {
  this->iceberg_field_id = val;
__isset.iceberg_field_id = true;
}

void TColumn::__set_iceberg_field_map_key_id(const int32_t val) {
  this->iceberg_field_map_key_id = val;
__isset.iceberg_field_map_key_id = true;
}

void TColumn::__set_iceberg_field_map_value_id(const int32_t val) {
  this->iceberg_field_map_value_id = val;
__isset.iceberg_field_map_value_id = true;
}
std::ostream& operator<<(std::ostream& out, const TColumn& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TColumn &a, TColumn &b) {
  using ::std::swap;
  swap(a.columnName, b.columnName);
  swap(a.columnType, b.columnType);
  swap(a.comment, b.comment);
  swap(a.col_stats, b.col_stats);
  swap(a.position, b.position);
  swap(a.is_hbase_column, b.is_hbase_column);
  swap(a.column_family, b.column_family);
  swap(a.column_qualifier, b.column_qualifier);
  swap(a.is_binary, b.is_binary);
  swap(a.is_kudu_column, b.is_kudu_column);
  swap(a.is_key, b.is_key);
  swap(a.is_nullable, b.is_nullable);
  swap(a.encoding, b.encoding);
  swap(a.compression, b.compression);
  swap(a.default_value, b.default_value);
  swap(a.block_size, b.block_size);
  swap(a.kudu_column_name, b.kudu_column_name);
  swap(a.is_iceberg_column, b.is_iceberg_column);
  swap(a.iceberg_field_id, b.iceberg_field_id);
  swap(a.iceberg_field_map_key_id, b.iceberg_field_map_key_id);
  swap(a.iceberg_field_map_value_id, b.iceberg_field_map_value_id);
  swap(a.__isset, b.__isset);
}

TColumn::TColumn(const TColumn& other39) {
  columnName = other39.columnName;
  columnType = other39.columnType;
  comment = other39.comment;
  col_stats = other39.col_stats;
  position = other39.position;
  is_hbase_column = other39.is_hbase_column;
  column_family = other39.column_family;
  column_qualifier = other39.column_qualifier;
  is_binary = other39.is_binary;
  is_kudu_column = other39.is_kudu_column;
  is_key = other39.is_key;
  is_nullable = other39.is_nullable;
  encoding = other39.encoding;
  compression = other39.compression;
  default_value = other39.default_value;
  block_size = other39.block_size;
  kudu_column_name = other39.kudu_column_name;
  is_iceberg_column = other39.is_iceberg_column;
  iceberg_field_id = other39.iceberg_field_id;
  iceberg_field_map_key_id = other39.iceberg_field_map_key_id;
  iceberg_field_map_value_id = other39.iceberg_field_map_value_id;
  __isset = other39.__isset;
}
TColumn::TColumn( TColumn&& other40) {
  columnName = std::move(other40.columnName);
  columnType = std::move(other40.columnType);
  comment = std::move(other40.comment);
  col_stats = std::move(other40.col_stats);
  position = std::move(other40.position);
  is_hbase_column = std::move(other40.is_hbase_column);
  column_family = std::move(other40.column_family);
  column_qualifier = std::move(other40.column_qualifier);
  is_binary = std::move(other40.is_binary);
  is_kudu_column = std::move(other40.is_kudu_column);
  is_key = std::move(other40.is_key);
  is_nullable = std::move(other40.is_nullable);
  encoding = std::move(other40.encoding);
  compression = std::move(other40.compression);
  default_value = std::move(other40.default_value);
  block_size = std::move(other40.block_size);
  kudu_column_name = std::move(other40.kudu_column_name);
  is_iceberg_column = std::move(other40.is_iceberg_column);
  iceberg_field_id = std::move(other40.iceberg_field_id);
  iceberg_field_map_key_id = std::move(other40.iceberg_field_map_key_id);
  iceberg_field_map_value_id = std::move(other40.iceberg_field_map_value_id);
  __isset = std::move(other40.__isset);
}
TColumn& TColumn::operator=(const TColumn& other41) {
  columnName = other41.columnName;
  columnType = other41.columnType;
  comment = other41.comment;
  col_stats = other41.col_stats;
  position = other41.position;
  is_hbase_column = other41.is_hbase_column;
  column_family = other41.column_family;
  column_qualifier = other41.column_qualifier;
  is_binary = other41.is_binary;
  is_kudu_column = other41.is_kudu_column;
  is_key = other41.is_key;
  is_nullable = other41.is_nullable;
  encoding = other41.encoding;
  compression = other41.compression;
  default_value = other41.default_value;
  block_size = other41.block_size;
  kudu_column_name = other41.kudu_column_name;
  is_iceberg_column = other41.is_iceberg_column;
  iceberg_field_id = other41.iceberg_field_id;
  iceberg_field_map_key_id = other41.iceberg_field_map_key_id;
  iceberg_field_map_value_id = other41.iceberg_field_map_value_id;
  __isset = other41.__isset;
  return *this;
}
TColumn& TColumn::operator=(TColumn&& other42) {
  columnName = std::move(other42.columnName);
  columnType = std::move(other42.columnType);
  comment = std::move(other42.comment);
  col_stats = std::move(other42.col_stats);
  position = std::move(other42.position);
  is_hbase_column = std::move(other42.is_hbase_column);
  column_family = std::move(other42.column_family);
  column_qualifier = std::move(other42.column_qualifier);
  is_binary = std::move(other42.is_binary);
  is_kudu_column = std::move(other42.is_kudu_column);
  is_key = std::move(other42.is_key);
  is_nullable = std::move(other42.is_nullable);
  encoding = std::move(other42.encoding);
  compression = std::move(other42.compression);
  default_value = std::move(other42.default_value);
  block_size = std::move(other42.block_size);
  kudu_column_name = std::move(other42.kudu_column_name);
  is_iceberg_column = std::move(other42.is_iceberg_column);
  iceberg_field_id = std::move(other42.iceberg_field_id);
  iceberg_field_map_key_id = std::move(other42.iceberg_field_map_key_id);
  iceberg_field_map_value_id = std::move(other42.iceberg_field_map_value_id);
  __isset = std::move(other42.__isset);
  return *this;
}
void TColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TColumn(";
  out << "columnName=" << to_string(columnName);
  out << ", " << "columnType=" << to_string(columnType);
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "col_stats="; (__isset.col_stats ? (out << to_string(col_stats)) : (out << "<null>"));
  out << ", " << "position="; (__isset.position ? (out << to_string(position)) : (out << "<null>"));
  out << ", " << "is_hbase_column="; (__isset.is_hbase_column ? (out << to_string(is_hbase_column)) : (out << "<null>"));
  out << ", " << "column_family="; (__isset.column_family ? (out << to_string(column_family)) : (out << "<null>"));
  out << ", " << "column_qualifier="; (__isset.column_qualifier ? (out << to_string(column_qualifier)) : (out << "<null>"));
  out << ", " << "is_binary="; (__isset.is_binary ? (out << to_string(is_binary)) : (out << "<null>"));
  out << ", " << "is_kudu_column="; (__isset.is_kudu_column ? (out << to_string(is_kudu_column)) : (out << "<null>"));
  out << ", " << "is_key="; (__isset.is_key ? (out << to_string(is_key)) : (out << "<null>"));
  out << ", " << "is_nullable="; (__isset.is_nullable ? (out << to_string(is_nullable)) : (out << "<null>"));
  out << ", " << "encoding="; (__isset.encoding ? (out << to_string(encoding)) : (out << "<null>"));
  out << ", " << "compression="; (__isset.compression ? (out << to_string(compression)) : (out << "<null>"));
  out << ", " << "default_value="; (__isset.default_value ? (out << to_string(default_value)) : (out << "<null>"));
  out << ", " << "block_size="; (__isset.block_size ? (out << to_string(block_size)) : (out << "<null>"));
  out << ", " << "kudu_column_name="; (__isset.kudu_column_name ? (out << to_string(kudu_column_name)) : (out << "<null>"));
  out << ", " << "is_iceberg_column="; (__isset.is_iceberg_column ? (out << to_string(is_iceberg_column)) : (out << "<null>"));
  out << ", " << "iceberg_field_id="; (__isset.iceberg_field_id ? (out << to_string(iceberg_field_id)) : (out << "<null>"));
  out << ", " << "iceberg_field_map_key_id="; (__isset.iceberg_field_map_key_id ? (out << to_string(iceberg_field_map_key_id)) : (out << "<null>"));
  out << ", " << "iceberg_field_map_value_id="; (__isset.iceberg_field_map_value_id ? (out << to_string(iceberg_field_map_value_id)) : (out << "<null>"));
  out << ")";
}


THdfsFileDesc::~THdfsFileDesc() throw() {
}


void THdfsFileDesc::__set_file_desc_data(const std::string& val) {
  this->file_desc_data = val;
}

void THdfsFileDesc::__set_file_metadata(const std::string& val) {
  this->file_metadata = val;
__isset.file_metadata = true;
}
std::ostream& operator<<(std::ostream& out, const THdfsFileDesc& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsFileDesc &a, THdfsFileDesc &b) {
  using ::std::swap;
  swap(a.file_desc_data, b.file_desc_data);
  swap(a.file_metadata, b.file_metadata);
  swap(a.__isset, b.__isset);
}

THdfsFileDesc::THdfsFileDesc(const THdfsFileDesc& other43) {
  file_desc_data = other43.file_desc_data;
  file_metadata = other43.file_metadata;
  __isset = other43.__isset;
}
THdfsFileDesc::THdfsFileDesc( THdfsFileDesc&& other44) {
  file_desc_data = std::move(other44.file_desc_data);
  file_metadata = std::move(other44.file_metadata);
  __isset = std::move(other44.__isset);
}
THdfsFileDesc& THdfsFileDesc::operator=(const THdfsFileDesc& other45) {
  file_desc_data = other45.file_desc_data;
  file_metadata = other45.file_metadata;
  __isset = other45.__isset;
  return *this;
}
THdfsFileDesc& THdfsFileDesc::operator=(THdfsFileDesc&& other46) {
  file_desc_data = std::move(other46.file_desc_data);
  file_metadata = std::move(other46.file_metadata);
  __isset = std::move(other46.__isset);
  return *this;
}
void THdfsFileDesc::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsFileDesc(";
  out << "file_desc_data=" << to_string(file_desc_data);
  out << ", " << "file_metadata="; (__isset.file_metadata ? (out << to_string(file_metadata)) : (out << "<null>"));
  out << ")";
}


THdfsPartitionLocation::~THdfsPartitionLocation() throw() {
}


void THdfsPartitionLocation::__set_prefix_index(const int32_t val) {
  this->prefix_index = val;
}

void THdfsPartitionLocation::__set_suffix(const std::string& val) {
  this->suffix = val;
}
std::ostream& operator<<(std::ostream& out, const THdfsPartitionLocation& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsPartitionLocation &a, THdfsPartitionLocation &b) {
  using ::std::swap;
  swap(a.prefix_index, b.prefix_index);
  swap(a.suffix, b.suffix);
}

THdfsPartitionLocation::THdfsPartitionLocation(const THdfsPartitionLocation& other47) {
  prefix_index = other47.prefix_index;
  suffix = other47.suffix;
}
THdfsPartitionLocation::THdfsPartitionLocation( THdfsPartitionLocation&& other48) {
  prefix_index = std::move(other48.prefix_index);
  suffix = std::move(other48.suffix);
}
THdfsPartitionLocation& THdfsPartitionLocation::operator=(const THdfsPartitionLocation& other49) {
  prefix_index = other49.prefix_index;
  suffix = other49.suffix;
  return *this;
}
THdfsPartitionLocation& THdfsPartitionLocation::operator=(THdfsPartitionLocation&& other50) {
  prefix_index = std::move(other50.prefix_index);
  suffix = std::move(other50.suffix);
  return *this;
}
void THdfsPartitionLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsPartitionLocation(";
  out << "prefix_index=" << to_string(prefix_index);
  out << ", " << "suffix=" << to_string(suffix);
  out << ")";
}


THdfsStorageDescriptor::~THdfsStorageDescriptor() throw() {
}


void THdfsStorageDescriptor::__set_lineDelim(const int8_t val) {
  this->lineDelim = val;
}

void THdfsStorageDescriptor::__set_fieldDelim(const int8_t val) {
  this->fieldDelim = val;
}

void THdfsStorageDescriptor::__set_collectionDelim(const int8_t val) {
  this->collectionDelim = val;
}

void THdfsStorageDescriptor::__set_mapKeyDelim(const int8_t val) {
  this->mapKeyDelim = val;
}

void THdfsStorageDescriptor::__set_escapeChar(const int8_t val) {
  this->escapeChar = val;
}

void THdfsStorageDescriptor::__set_quoteChar(const int8_t val) {
  this->quoteChar = val;
}

void THdfsStorageDescriptor::__set_fileFormat(const THdfsFileFormat::type val) {
  this->fileFormat = val;
}

void THdfsStorageDescriptor::__set_blockSize(const int32_t val) {
  this->blockSize = val;
}
std::ostream& operator<<(std::ostream& out, const THdfsStorageDescriptor& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsStorageDescriptor &a, THdfsStorageDescriptor &b) {
  using ::std::swap;
  swap(a.lineDelim, b.lineDelim);
  swap(a.fieldDelim, b.fieldDelim);
  swap(a.collectionDelim, b.collectionDelim);
  swap(a.mapKeyDelim, b.mapKeyDelim);
  swap(a.escapeChar, b.escapeChar);
  swap(a.quoteChar, b.quoteChar);
  swap(a.fileFormat, b.fileFormat);
  swap(a.blockSize, b.blockSize);
}

THdfsStorageDescriptor::THdfsStorageDescriptor(const THdfsStorageDescriptor& other52) {
  lineDelim = other52.lineDelim;
  fieldDelim = other52.fieldDelim;
  collectionDelim = other52.collectionDelim;
  mapKeyDelim = other52.mapKeyDelim;
  escapeChar = other52.escapeChar;
  quoteChar = other52.quoteChar;
  fileFormat = other52.fileFormat;
  blockSize = other52.blockSize;
}
THdfsStorageDescriptor::THdfsStorageDescriptor( THdfsStorageDescriptor&& other53) {
  lineDelim = std::move(other53.lineDelim);
  fieldDelim = std::move(other53.fieldDelim);
  collectionDelim = std::move(other53.collectionDelim);
  mapKeyDelim = std::move(other53.mapKeyDelim);
  escapeChar = std::move(other53.escapeChar);
  quoteChar = std::move(other53.quoteChar);
  fileFormat = std::move(other53.fileFormat);
  blockSize = std::move(other53.blockSize);
}
THdfsStorageDescriptor& THdfsStorageDescriptor::operator=(const THdfsStorageDescriptor& other54) {
  lineDelim = other54.lineDelim;
  fieldDelim = other54.fieldDelim;
  collectionDelim = other54.collectionDelim;
  mapKeyDelim = other54.mapKeyDelim;
  escapeChar = other54.escapeChar;
  quoteChar = other54.quoteChar;
  fileFormat = other54.fileFormat;
  blockSize = other54.blockSize;
  return *this;
}
THdfsStorageDescriptor& THdfsStorageDescriptor::operator=(THdfsStorageDescriptor&& other55) {
  lineDelim = std::move(other55.lineDelim);
  fieldDelim = std::move(other55.fieldDelim);
  collectionDelim = std::move(other55.collectionDelim);
  mapKeyDelim = std::move(other55.mapKeyDelim);
  escapeChar = std::move(other55.escapeChar);
  quoteChar = std::move(other55.quoteChar);
  fileFormat = std::move(other55.fileFormat);
  blockSize = std::move(other55.blockSize);
  return *this;
}
void THdfsStorageDescriptor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsStorageDescriptor(";
  out << "lineDelim=" << to_string(lineDelim);
  out << ", " << "fieldDelim=" << to_string(fieldDelim);
  out << ", " << "collectionDelim=" << to_string(collectionDelim);
  out << ", " << "mapKeyDelim=" << to_string(mapKeyDelim);
  out << ", " << "escapeChar=" << to_string(escapeChar);
  out << ", " << "quoteChar=" << to_string(quoteChar);
  out << ", " << "fileFormat=" << to_string(fileFormat);
  out << ", " << "blockSize=" << to_string(blockSize);
  out << ")";
}


THdfsPartition::~THdfsPartition() throw() {
}


void THdfsPartition::__set_partitionKeyExprs(const std::vector< ::impala::TExpr> & val) {
  this->partitionKeyExprs = val;
}

void THdfsPartition::__set_location(const THdfsPartitionLocation& val) {
  this->location = val;
__isset.location = true;
}

void THdfsPartition::__set_id(const int64_t val) {
  this->id = val;
__isset.id = true;
}

void THdfsPartition::__set_prev_id(const int64_t val) {
  this->prev_id = val;
__isset.prev_id = true;
}

void THdfsPartition::__set_file_desc(const std::vector<THdfsFileDesc> & val) {
  this->file_desc = val;
__isset.file_desc = true;
}

void THdfsPartition::__set_insert_file_desc(const std::vector<THdfsFileDesc> & val) {
  this->insert_file_desc = val;
__isset.insert_file_desc = true;
}

void THdfsPartition::__set_delete_file_desc(const std::vector<THdfsFileDesc> & val) {
  this->delete_file_desc = val;
__isset.delete_file_desc = true;
}

void THdfsPartition::__set_access_level(const TAccessLevel::type val) {
  this->access_level = val;
__isset.access_level = true;
}

void THdfsPartition::__set_stats(const TTableStats& val) {
  this->stats = val;
__isset.stats = true;
}

void THdfsPartition::__set_is_marked_cached(const bool val) {
  this->is_marked_cached = val;
__isset.is_marked_cached = true;
}

void THdfsPartition::__set_hms_parameters(const std::map<std::string, std::string> & val) {
  this->hms_parameters = val;
__isset.hms_parameters = true;
}

void THdfsPartition::__set_num_blocks(const int64_t val) {
  this->num_blocks = val;
__isset.num_blocks = true;
}

void THdfsPartition::__set_total_file_size_bytes(const int64_t val) {
  this->total_file_size_bytes = val;
__isset.total_file_size_bytes = true;
}

void THdfsPartition::__set_partition_stats(const std::string& val) {
  this->partition_stats = val;
__isset.partition_stats = true;
}

void THdfsPartition::__set_has_incremental_stats(const bool val) {
  this->has_incremental_stats = val;
__isset.has_incremental_stats = true;
}

void THdfsPartition::__set_write_id(const int64_t val) {
  this->write_id = val;
__isset.write_id = true;
}

void THdfsPartition::__set_db_name(const std::string& val) {
  this->db_name = val;
__isset.db_name = true;
}

void THdfsPartition::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
__isset.tbl_name = true;
}

void THdfsPartition::__set_partition_name(const std::string& val) {
  this->partition_name = val;
__isset.partition_name = true;
}

void THdfsPartition::__set_hdfs_storage_descriptor(const THdfsStorageDescriptor& val) {
  this->hdfs_storage_descriptor = val;
__isset.hdfs_storage_descriptor = true;
}
std::ostream& operator<<(std::ostream& out, const THdfsPartition& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsPartition &a, THdfsPartition &b) {
  using ::std::swap;
  swap(a.partitionKeyExprs, b.partitionKeyExprs);
  swap(a.location, b.location);
  swap(a.id, b.id);
  swap(a.prev_id, b.prev_id);
  swap(a.file_desc, b.file_desc);
  swap(a.insert_file_desc, b.insert_file_desc);
  swap(a.delete_file_desc, b.delete_file_desc);
  swap(a.access_level, b.access_level);
  swap(a.stats, b.stats);
  swap(a.is_marked_cached, b.is_marked_cached);
  swap(a.hms_parameters, b.hms_parameters);
  swap(a.num_blocks, b.num_blocks);
  swap(a.total_file_size_bytes, b.total_file_size_bytes);
  swap(a.partition_stats, b.partition_stats);
  swap(a.has_incremental_stats, b.has_incremental_stats);
  swap(a.write_id, b.write_id);
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.partition_name, b.partition_name);
  swap(a.hdfs_storage_descriptor, b.hdfs_storage_descriptor);
  swap(a.__isset, b.__isset);
}

THdfsPartition::THdfsPartition(const THdfsPartition& other89) {
  partitionKeyExprs = other89.partitionKeyExprs;
  location = other89.location;
  id = other89.id;
  prev_id = other89.prev_id;
  file_desc = other89.file_desc;
  insert_file_desc = other89.insert_file_desc;
  delete_file_desc = other89.delete_file_desc;
  access_level = other89.access_level;
  stats = other89.stats;
  is_marked_cached = other89.is_marked_cached;
  hms_parameters = other89.hms_parameters;
  num_blocks = other89.num_blocks;
  total_file_size_bytes = other89.total_file_size_bytes;
  partition_stats = other89.partition_stats;
  has_incremental_stats = other89.has_incremental_stats;
  write_id = other89.write_id;
  db_name = other89.db_name;
  tbl_name = other89.tbl_name;
  partition_name = other89.partition_name;
  hdfs_storage_descriptor = other89.hdfs_storage_descriptor;
  __isset = other89.__isset;
}
THdfsPartition::THdfsPartition( THdfsPartition&& other90) {
  partitionKeyExprs = std::move(other90.partitionKeyExprs);
  location = std::move(other90.location);
  id = std::move(other90.id);
  prev_id = std::move(other90.prev_id);
  file_desc = std::move(other90.file_desc);
  insert_file_desc = std::move(other90.insert_file_desc);
  delete_file_desc = std::move(other90.delete_file_desc);
  access_level = std::move(other90.access_level);
  stats = std::move(other90.stats);
  is_marked_cached = std::move(other90.is_marked_cached);
  hms_parameters = std::move(other90.hms_parameters);
  num_blocks = std::move(other90.num_blocks);
  total_file_size_bytes = std::move(other90.total_file_size_bytes);
  partition_stats = std::move(other90.partition_stats);
  has_incremental_stats = std::move(other90.has_incremental_stats);
  write_id = std::move(other90.write_id);
  db_name = std::move(other90.db_name);
  tbl_name = std::move(other90.tbl_name);
  partition_name = std::move(other90.partition_name);
  hdfs_storage_descriptor = std::move(other90.hdfs_storage_descriptor);
  __isset = std::move(other90.__isset);
}
THdfsPartition& THdfsPartition::operator=(const THdfsPartition& other91) {
  partitionKeyExprs = other91.partitionKeyExprs;
  location = other91.location;
  id = other91.id;
  prev_id = other91.prev_id;
  file_desc = other91.file_desc;
  insert_file_desc = other91.insert_file_desc;
  delete_file_desc = other91.delete_file_desc;
  access_level = other91.access_level;
  stats = other91.stats;
  is_marked_cached = other91.is_marked_cached;
  hms_parameters = other91.hms_parameters;
  num_blocks = other91.num_blocks;
  total_file_size_bytes = other91.total_file_size_bytes;
  partition_stats = other91.partition_stats;
  has_incremental_stats = other91.has_incremental_stats;
  write_id = other91.write_id;
  db_name = other91.db_name;
  tbl_name = other91.tbl_name;
  partition_name = other91.partition_name;
  hdfs_storage_descriptor = other91.hdfs_storage_descriptor;
  __isset = other91.__isset;
  return *this;
}
THdfsPartition& THdfsPartition::operator=(THdfsPartition&& other92) {
  partitionKeyExprs = std::move(other92.partitionKeyExprs);
  location = std::move(other92.location);
  id = std::move(other92.id);
  prev_id = std::move(other92.prev_id);
  file_desc = std::move(other92.file_desc);
  insert_file_desc = std::move(other92.insert_file_desc);
  delete_file_desc = std::move(other92.delete_file_desc);
  access_level = std::move(other92.access_level);
  stats = std::move(other92.stats);
  is_marked_cached = std::move(other92.is_marked_cached);
  hms_parameters = std::move(other92.hms_parameters);
  num_blocks = std::move(other92.num_blocks);
  total_file_size_bytes = std::move(other92.total_file_size_bytes);
  partition_stats = std::move(other92.partition_stats);
  has_incremental_stats = std::move(other92.has_incremental_stats);
  write_id = std::move(other92.write_id);
  db_name = std::move(other92.db_name);
  tbl_name = std::move(other92.tbl_name);
  partition_name = std::move(other92.partition_name);
  hdfs_storage_descriptor = std::move(other92.hdfs_storage_descriptor);
  __isset = std::move(other92.__isset);
  return *this;
}
void THdfsPartition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsPartition(";
  out << "partitionKeyExprs=" << to_string(partitionKeyExprs);
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "prev_id="; (__isset.prev_id ? (out << to_string(prev_id)) : (out << "<null>"));
  out << ", " << "file_desc="; (__isset.file_desc ? (out << to_string(file_desc)) : (out << "<null>"));
  out << ", " << "insert_file_desc="; (__isset.insert_file_desc ? (out << to_string(insert_file_desc)) : (out << "<null>"));
  out << ", " << "delete_file_desc="; (__isset.delete_file_desc ? (out << to_string(delete_file_desc)) : (out << "<null>"));
  out << ", " << "access_level="; (__isset.access_level ? (out << to_string(access_level)) : (out << "<null>"));
  out << ", " << "stats="; (__isset.stats ? (out << to_string(stats)) : (out << "<null>"));
  out << ", " << "is_marked_cached="; (__isset.is_marked_cached ? (out << to_string(is_marked_cached)) : (out << "<null>"));
  out << ", " << "hms_parameters="; (__isset.hms_parameters ? (out << to_string(hms_parameters)) : (out << "<null>"));
  out << ", " << "num_blocks="; (__isset.num_blocks ? (out << to_string(num_blocks)) : (out << "<null>"));
  out << ", " << "total_file_size_bytes="; (__isset.total_file_size_bytes ? (out << to_string(total_file_size_bytes)) : (out << "<null>"));
  out << ", " << "partition_stats="; (__isset.partition_stats ? (out << to_string(partition_stats)) : (out << "<null>"));
  out << ", " << "has_incremental_stats="; (__isset.has_incremental_stats ? (out << to_string(has_incremental_stats)) : (out << "<null>"));
  out << ", " << "write_id="; (__isset.write_id ? (out << to_string(write_id)) : (out << "<null>"));
  out << ", " << "db_name="; (__isset.db_name ? (out << to_string(db_name)) : (out << "<null>"));
  out << ", " << "tbl_name="; (__isset.tbl_name ? (out << to_string(tbl_name)) : (out << "<null>"));
  out << ", " << "partition_name="; (__isset.partition_name ? (out << to_string(partition_name)) : (out << "<null>"));
  out << ", " << "hdfs_storage_descriptor="; (__isset.hdfs_storage_descriptor ? (out << to_string(hdfs_storage_descriptor)) : (out << "<null>"));
  out << ")";
}


TValidWriteIdList::~TValidWriteIdList() throw() {
}


void TValidWriteIdList::__set_high_watermark(const int64_t val) {
  this->high_watermark = val;
__isset.high_watermark = true;
}

void TValidWriteIdList::__set_min_open_write_id(const int64_t val) {
  this->min_open_write_id = val;
__isset.min_open_write_id = true;
}

void TValidWriteIdList::__set_invalid_write_ids(const std::vector<int64_t> & val) {
  this->invalid_write_ids = val;
__isset.invalid_write_ids = true;
}

void TValidWriteIdList::__set_aborted_indexes(const std::vector<int32_t> & val) {
  this->aborted_indexes = val;
__isset.aborted_indexes = true;
}
std::ostream& operator<<(std::ostream& out, const TValidWriteIdList& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TValidWriteIdList &a, TValidWriteIdList &b) {
  using ::std::swap;
  swap(a.high_watermark, b.high_watermark);
  swap(a.min_open_write_id, b.min_open_write_id);
  swap(a.invalid_write_ids, b.invalid_write_ids);
  swap(a.aborted_indexes, b.aborted_indexes);
  swap(a.__isset, b.__isset);
}

TValidWriteIdList::TValidWriteIdList(const TValidWriteIdList& other105) {
  high_watermark = other105.high_watermark;
  min_open_write_id = other105.min_open_write_id;
  invalid_write_ids = other105.invalid_write_ids;
  aborted_indexes = other105.aborted_indexes;
  __isset = other105.__isset;
}
TValidWriteIdList::TValidWriteIdList( TValidWriteIdList&& other106) {
  high_watermark = std::move(other106.high_watermark);
  min_open_write_id = std::move(other106.min_open_write_id);
  invalid_write_ids = std::move(other106.invalid_write_ids);
  aborted_indexes = std::move(other106.aborted_indexes);
  __isset = std::move(other106.__isset);
}
TValidWriteIdList& TValidWriteIdList::operator=(const TValidWriteIdList& other107) {
  high_watermark = other107.high_watermark;
  min_open_write_id = other107.min_open_write_id;
  invalid_write_ids = other107.invalid_write_ids;
  aborted_indexes = other107.aborted_indexes;
  __isset = other107.__isset;
  return *this;
}
TValidWriteIdList& TValidWriteIdList::operator=(TValidWriteIdList&& other108) {
  high_watermark = std::move(other108.high_watermark);
  min_open_write_id = std::move(other108.min_open_write_id);
  invalid_write_ids = std::move(other108.invalid_write_ids);
  aborted_indexes = std::move(other108.aborted_indexes);
  __isset = std::move(other108.__isset);
  return *this;
}
void TValidWriteIdList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TValidWriteIdList(";
  out << "high_watermark="; (__isset.high_watermark ? (out << to_string(high_watermark)) : (out << "<null>"));
  out << ", " << "min_open_write_id="; (__isset.min_open_write_id ? (out << to_string(min_open_write_id)) : (out << "<null>"));
  out << ", " << "invalid_write_ids="; (__isset.invalid_write_ids ? (out << to_string(invalid_write_ids)) : (out << "<null>"));
  out << ", " << "aborted_indexes="; (__isset.aborted_indexes ? (out << to_string(aborted_indexes)) : (out << "<null>"));
  out << ")";
}


THdfsTable::~THdfsTable() throw() {
}


void THdfsTable::__set_hdfsBaseDir(const std::string& val) {
  this->hdfsBaseDir = val;
}

void THdfsTable::__set_colNames(const std::vector<std::string> & val) {
  this->colNames = val;
}

void THdfsTable::__set_nullPartitionKeyValue(const std::string& val) {
  this->nullPartitionKeyValue = val;
}

void THdfsTable::__set_nullColumnValue(const std::string& val) {
  this->nullColumnValue = val;
}

void THdfsTable::__set_avroSchema(const std::string& val) {
  this->avroSchema = val;
__isset.avroSchema = true;
}

void THdfsTable::__set_partitions(const std::map<int64_t, THdfsPartition> & val) {
  this->partitions = val;
}

void THdfsTable::__set_has_full_partitions(const bool val) {
  this->has_full_partitions = val;
__isset.has_full_partitions = true;
}

void THdfsTable::__set_has_partition_names(const bool val) {
  this->has_partition_names = val;
__isset.has_partition_names = true;
}

void THdfsTable::__set_prototype_partition(const THdfsPartition& val) {
  this->prototype_partition = val;
}

void THdfsTable::__set_partition_prefixes(const std::vector<std::string> & val) {
  this->partition_prefixes = val;
__isset.partition_prefixes = true;
}

void THdfsTable::__set_network_addresses(const std::vector< ::impala::TNetworkAddress> & val) {
  this->network_addresses = val;
__isset.network_addresses = true;
}

void THdfsTable::__set_sql_constraints(const  ::impala::TSqlConstraints& val) {
  this->sql_constraints = val;
__isset.sql_constraints = true;
}

void THdfsTable::__set_is_full_acid(const bool val) {
  this->is_full_acid = val;
__isset.is_full_acid = true;
}

void THdfsTable::__set_valid_write_ids(const TValidWriteIdList& val) {
  this->valid_write_ids = val;
__isset.valid_write_ids = true;
}
std::ostream& operator<<(std::ostream& out, const THdfsTable& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsTable &a, THdfsTable &b) {
  using ::std::swap;
  swap(a.hdfsBaseDir, b.hdfsBaseDir);
  swap(a.colNames, b.colNames);
  swap(a.nullPartitionKeyValue, b.nullPartitionKeyValue);
  swap(a.nullColumnValue, b.nullColumnValue);
  swap(a.avroSchema, b.avroSchema);
  swap(a.partitions, b.partitions);
  swap(a.has_full_partitions, b.has_full_partitions);
  swap(a.has_partition_names, b.has_partition_names);
  swap(a.prototype_partition, b.prototype_partition);
  swap(a.partition_prefixes, b.partition_prefixes);
  swap(a.network_addresses, b.network_addresses);
  swap(a.sql_constraints, b.sql_constraints);
  swap(a.is_full_acid, b.is_full_acid);
  swap(a.valid_write_ids, b.valid_write_ids);
  swap(a.__isset, b.__isset);
}

THdfsTable::THdfsTable(const THdfsTable& other135) {
  hdfsBaseDir = other135.hdfsBaseDir;
  colNames = other135.colNames;
  nullPartitionKeyValue = other135.nullPartitionKeyValue;
  nullColumnValue = other135.nullColumnValue;
  avroSchema = other135.avroSchema;
  partitions = other135.partitions;
  has_full_partitions = other135.has_full_partitions;
  has_partition_names = other135.has_partition_names;
  prototype_partition = other135.prototype_partition;
  partition_prefixes = other135.partition_prefixes;
  network_addresses = other135.network_addresses;
  sql_constraints = other135.sql_constraints;
  is_full_acid = other135.is_full_acid;
  valid_write_ids = other135.valid_write_ids;
  __isset = other135.__isset;
}
THdfsTable::THdfsTable( THdfsTable&& other136) {
  hdfsBaseDir = std::move(other136.hdfsBaseDir);
  colNames = std::move(other136.colNames);
  nullPartitionKeyValue = std::move(other136.nullPartitionKeyValue);
  nullColumnValue = std::move(other136.nullColumnValue);
  avroSchema = std::move(other136.avroSchema);
  partitions = std::move(other136.partitions);
  has_full_partitions = std::move(other136.has_full_partitions);
  has_partition_names = std::move(other136.has_partition_names);
  prototype_partition = std::move(other136.prototype_partition);
  partition_prefixes = std::move(other136.partition_prefixes);
  network_addresses = std::move(other136.network_addresses);
  sql_constraints = std::move(other136.sql_constraints);
  is_full_acid = std::move(other136.is_full_acid);
  valid_write_ids = std::move(other136.valid_write_ids);
  __isset = std::move(other136.__isset);
}
THdfsTable& THdfsTable::operator=(const THdfsTable& other137) {
  hdfsBaseDir = other137.hdfsBaseDir;
  colNames = other137.colNames;
  nullPartitionKeyValue = other137.nullPartitionKeyValue;
  nullColumnValue = other137.nullColumnValue;
  avroSchema = other137.avroSchema;
  partitions = other137.partitions;
  has_full_partitions = other137.has_full_partitions;
  has_partition_names = other137.has_partition_names;
  prototype_partition = other137.prototype_partition;
  partition_prefixes = other137.partition_prefixes;
  network_addresses = other137.network_addresses;
  sql_constraints = other137.sql_constraints;
  is_full_acid = other137.is_full_acid;
  valid_write_ids = other137.valid_write_ids;
  __isset = other137.__isset;
  return *this;
}
THdfsTable& THdfsTable::operator=(THdfsTable&& other138) {
  hdfsBaseDir = std::move(other138.hdfsBaseDir);
  colNames = std::move(other138.colNames);
  nullPartitionKeyValue = std::move(other138.nullPartitionKeyValue);
  nullColumnValue = std::move(other138.nullColumnValue);
  avroSchema = std::move(other138.avroSchema);
  partitions = std::move(other138.partitions);
  has_full_partitions = std::move(other138.has_full_partitions);
  has_partition_names = std::move(other138.has_partition_names);
  prototype_partition = std::move(other138.prototype_partition);
  partition_prefixes = std::move(other138.partition_prefixes);
  network_addresses = std::move(other138.network_addresses);
  sql_constraints = std::move(other138.sql_constraints);
  is_full_acid = std::move(other138.is_full_acid);
  valid_write_ids = std::move(other138.valid_write_ids);
  __isset = std::move(other138.__isset);
  return *this;
}
void THdfsTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsTable(";
  out << "hdfsBaseDir=" << to_string(hdfsBaseDir);
  out << ", " << "colNames=" << to_string(colNames);
  out << ", " << "nullPartitionKeyValue=" << to_string(nullPartitionKeyValue);
  out << ", " << "nullColumnValue=" << to_string(nullColumnValue);
  out << ", " << "avroSchema="; (__isset.avroSchema ? (out << to_string(avroSchema)) : (out << "<null>"));
  out << ", " << "partitions=" << to_string(partitions);
  out << ", " << "has_full_partitions="; (__isset.has_full_partitions ? (out << to_string(has_full_partitions)) : (out << "<null>"));
  out << ", " << "has_partition_names="; (__isset.has_partition_names ? (out << to_string(has_partition_names)) : (out << "<null>"));
  out << ", " << "prototype_partition=" << to_string(prototype_partition);
  out << ", " << "partition_prefixes="; (__isset.partition_prefixes ? (out << to_string(partition_prefixes)) : (out << "<null>"));
  out << ", " << "network_addresses="; (__isset.network_addresses ? (out << to_string(network_addresses)) : (out << "<null>"));
  out << ", " << "sql_constraints="; (__isset.sql_constraints ? (out << to_string(sql_constraints)) : (out << "<null>"));
  out << ", " << "is_full_acid="; (__isset.is_full_acid ? (out << to_string(is_full_acid)) : (out << "<null>"));
  out << ", " << "valid_write_ids="; (__isset.valid_write_ids ? (out << to_string(valid_write_ids)) : (out << "<null>"));
  out << ")";
}


THBaseTable::~THBaseTable() throw() {
}


void THBaseTable::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void THBaseTable::__set_families(const std::vector<std::string> & val) {
  this->families = val;
}

void THBaseTable::__set_qualifiers(const std::vector<std::string> & val) {
  this->qualifiers = val;
}

void THBaseTable::__set_binary_encoded(const std::vector<bool> & val) {
  this->binary_encoded = val;
__isset.binary_encoded = true;
}
std::ostream& operator<<(std::ostream& out, const THBaseTable& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THBaseTable &a, THBaseTable &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.families, b.families);
  swap(a.qualifiers, b.qualifiers);
  swap(a.binary_encoded, b.binary_encoded);
  swap(a.__isset, b.__isset);
}

THBaseTable::THBaseTable(const THBaseTable& other157) {
  tableName = other157.tableName;
  families = other157.families;
  qualifiers = other157.qualifiers;
  binary_encoded = other157.binary_encoded;
  __isset = other157.__isset;
}
THBaseTable::THBaseTable( THBaseTable&& other158) {
  tableName = std::move(other158.tableName);
  families = std::move(other158.families);
  qualifiers = std::move(other158.qualifiers);
  binary_encoded = std::move(other158.binary_encoded);
  __isset = std::move(other158.__isset);
}
THBaseTable& THBaseTable::operator=(const THBaseTable& other159) {
  tableName = other159.tableName;
  families = other159.families;
  qualifiers = other159.qualifiers;
  binary_encoded = other159.binary_encoded;
  __isset = other159.__isset;
  return *this;
}
THBaseTable& THBaseTable::operator=(THBaseTable&& other160) {
  tableName = std::move(other160.tableName);
  families = std::move(other160.families);
  qualifiers = std::move(other160.qualifiers);
  binary_encoded = std::move(other160.binary_encoded);
  __isset = std::move(other160.__isset);
  return *this;
}
void THBaseTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THBaseTable(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "families=" << to_string(families);
  out << ", " << "qualifiers=" << to_string(qualifiers);
  out << ", " << "binary_encoded="; (__isset.binary_encoded ? (out << to_string(binary_encoded)) : (out << "<null>"));
  out << ")";
}


TDataSource::~TDataSource() throw() {
}


void TDataSource::__set_name(const std::string& val) {
  this->name = val;
}

void TDataSource::__set_hdfs_location(const std::string& val) {
  this->hdfs_location = val;
}

void TDataSource::__set_class_name(const std::string& val) {
  this->class_name = val;
}

void TDataSource::__set_api_version(const std::string& val) {
  this->api_version = val;
}
std::ostream& operator<<(std::ostream& out, const TDataSource& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDataSource &a, TDataSource &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.hdfs_location, b.hdfs_location);
  swap(a.class_name, b.class_name);
  swap(a.api_version, b.api_version);
}

TDataSource::TDataSource(const TDataSource& other161) {
  name = other161.name;
  hdfs_location = other161.hdfs_location;
  class_name = other161.class_name;
  api_version = other161.api_version;
}
TDataSource::TDataSource( TDataSource&& other162) {
  name = std::move(other162.name);
  hdfs_location = std::move(other162.hdfs_location);
  class_name = std::move(other162.class_name);
  api_version = std::move(other162.api_version);
}
TDataSource& TDataSource::operator=(const TDataSource& other163) {
  name = other163.name;
  hdfs_location = other163.hdfs_location;
  class_name = other163.class_name;
  api_version = other163.api_version;
  return *this;
}
TDataSource& TDataSource::operator=(TDataSource&& other164) {
  name = std::move(other164.name);
  hdfs_location = std::move(other164.hdfs_location);
  class_name = std::move(other164.class_name);
  api_version = std::move(other164.api_version);
  return *this;
}
void TDataSource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataSource(";
  out << "name=" << to_string(name);
  out << ", " << "hdfs_location=" << to_string(hdfs_location);
  out << ", " << "class_name=" << to_string(class_name);
  out << ", " << "api_version=" << to_string(api_version);
  out << ")";
}


TDataSourceTable::~TDataSourceTable() throw() {
}


void TDataSourceTable::__set_data_source(const TDataSource& val) {
  this->data_source = val;
}

void TDataSourceTable::__set_init_string(const std::string& val) {
  this->init_string = val;
}
std::ostream& operator<<(std::ostream& out, const TDataSourceTable& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDataSourceTable &a, TDataSourceTable &b) {
  using ::std::swap;
  swap(a.data_source, b.data_source);
  swap(a.init_string, b.init_string);
}

TDataSourceTable::TDataSourceTable(const TDataSourceTable& other165) {
  data_source = other165.data_source;
  init_string = other165.init_string;
}
TDataSourceTable::TDataSourceTable( TDataSourceTable&& other166) {
  data_source = std::move(other166.data_source);
  init_string = std::move(other166.init_string);
}
TDataSourceTable& TDataSourceTable::operator=(const TDataSourceTable& other167) {
  data_source = other167.data_source;
  init_string = other167.init_string;
  return *this;
}
TDataSourceTable& TDataSourceTable::operator=(TDataSourceTable&& other168) {
  data_source = std::move(other168.data_source);
  init_string = std::move(other168.init_string);
  return *this;
}
void TDataSourceTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDataSourceTable(";
  out << "data_source=" << to_string(data_source);
  out << ", " << "init_string=" << to_string(init_string);
  out << ")";
}


TKuduPartitionByHashParam::~TKuduPartitionByHashParam() throw() {
}


void TKuduPartitionByHashParam::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
}

void TKuduPartitionByHashParam::__set_num_partitions(const int32_t val) {
  this->num_partitions = val;
}
std::ostream& operator<<(std::ostream& out, const TKuduPartitionByHashParam& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TKuduPartitionByHashParam &a, TKuduPartitionByHashParam &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.num_partitions, b.num_partitions);
}

TKuduPartitionByHashParam::TKuduPartitionByHashParam(const TKuduPartitionByHashParam& other175) {
  columns = other175.columns;
  num_partitions = other175.num_partitions;
}
TKuduPartitionByHashParam::TKuduPartitionByHashParam( TKuduPartitionByHashParam&& other176) {
  columns = std::move(other176.columns);
  num_partitions = std::move(other176.num_partitions);
}
TKuduPartitionByHashParam& TKuduPartitionByHashParam::operator=(const TKuduPartitionByHashParam& other177) {
  columns = other177.columns;
  num_partitions = other177.num_partitions;
  return *this;
}
TKuduPartitionByHashParam& TKuduPartitionByHashParam::operator=(TKuduPartitionByHashParam&& other178) {
  columns = std::move(other178.columns);
  num_partitions = std::move(other178.num_partitions);
  return *this;
}
void TKuduPartitionByHashParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionByHashParam(";
  out << "columns=" << to_string(columns);
  out << ", " << "num_partitions=" << to_string(num_partitions);
  out << ")";
}


TRangePartition::~TRangePartition() throw() {
}


void TRangePartition::__set_lower_bound_values(const std::vector< ::impala::TExpr> & val) {
  this->lower_bound_values = val;
__isset.lower_bound_values = true;
}

void TRangePartition::__set_is_lower_bound_inclusive(const bool val) {
  this->is_lower_bound_inclusive = val;
__isset.is_lower_bound_inclusive = true;
}

void TRangePartition::__set_upper_bound_values(const std::vector< ::impala::TExpr> & val) {
  this->upper_bound_values = val;
__isset.upper_bound_values = true;
}

void TRangePartition::__set_is_upper_bound_inclusive(const bool val) {
  this->is_upper_bound_inclusive = val;
__isset.is_upper_bound_inclusive = true;
}
std::ostream& operator<<(std::ostream& out, const TRangePartition& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TRangePartition &a, TRangePartition &b) {
  using ::std::swap;
  swap(a.lower_bound_values, b.lower_bound_values);
  swap(a.is_lower_bound_inclusive, b.is_lower_bound_inclusive);
  swap(a.upper_bound_values, b.upper_bound_values);
  swap(a.is_upper_bound_inclusive, b.is_upper_bound_inclusive);
  swap(a.__isset, b.__isset);
}

TRangePartition::TRangePartition(const TRangePartition& other191) {
  lower_bound_values = other191.lower_bound_values;
  is_lower_bound_inclusive = other191.is_lower_bound_inclusive;
  upper_bound_values = other191.upper_bound_values;
  is_upper_bound_inclusive = other191.is_upper_bound_inclusive;
  __isset = other191.__isset;
}
TRangePartition::TRangePartition( TRangePartition&& other192) {
  lower_bound_values = std::move(other192.lower_bound_values);
  is_lower_bound_inclusive = std::move(other192.is_lower_bound_inclusive);
  upper_bound_values = std::move(other192.upper_bound_values);
  is_upper_bound_inclusive = std::move(other192.is_upper_bound_inclusive);
  __isset = std::move(other192.__isset);
}
TRangePartition& TRangePartition::operator=(const TRangePartition& other193) {
  lower_bound_values = other193.lower_bound_values;
  is_lower_bound_inclusive = other193.is_lower_bound_inclusive;
  upper_bound_values = other193.upper_bound_values;
  is_upper_bound_inclusive = other193.is_upper_bound_inclusive;
  __isset = other193.__isset;
  return *this;
}
TRangePartition& TRangePartition::operator=(TRangePartition&& other194) {
  lower_bound_values = std::move(other194.lower_bound_values);
  is_lower_bound_inclusive = std::move(other194.is_lower_bound_inclusive);
  upper_bound_values = std::move(other194.upper_bound_values);
  is_upper_bound_inclusive = std::move(other194.is_upper_bound_inclusive);
  __isset = std::move(other194.__isset);
  return *this;
}
void TRangePartition::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TRangePartition(";
  out << "lower_bound_values="; (__isset.lower_bound_values ? (out << to_string(lower_bound_values)) : (out << "<null>"));
  out << ", " << "is_lower_bound_inclusive="; (__isset.is_lower_bound_inclusive ? (out << to_string(is_lower_bound_inclusive)) : (out << "<null>"));
  out << ", " << "upper_bound_values="; (__isset.upper_bound_values ? (out << to_string(upper_bound_values)) : (out << "<null>"));
  out << ", " << "is_upper_bound_inclusive="; (__isset.is_upper_bound_inclusive ? (out << to_string(is_upper_bound_inclusive)) : (out << "<null>"));
  out << ")";
}


TKuduPartitionByRangeParam::~TKuduPartitionByRangeParam() throw() {
}


void TKuduPartitionByRangeParam::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
}

void TKuduPartitionByRangeParam::__set_range_partitions(const std::vector<TRangePartition> & val) {
  this->range_partitions = val;
__isset.range_partitions = true;
}
std::ostream& operator<<(std::ostream& out, const TKuduPartitionByRangeParam& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TKuduPartitionByRangeParam &a, TKuduPartitionByRangeParam &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.range_partitions, b.range_partitions);
  swap(a.__isset, b.__isset);
}

TKuduPartitionByRangeParam::TKuduPartitionByRangeParam(const TKuduPartitionByRangeParam& other207) {
  columns = other207.columns;
  range_partitions = other207.range_partitions;
  __isset = other207.__isset;
}
TKuduPartitionByRangeParam::TKuduPartitionByRangeParam( TKuduPartitionByRangeParam&& other208) {
  columns = std::move(other208.columns);
  range_partitions = std::move(other208.range_partitions);
  __isset = std::move(other208.__isset);
}
TKuduPartitionByRangeParam& TKuduPartitionByRangeParam::operator=(const TKuduPartitionByRangeParam& other209) {
  columns = other209.columns;
  range_partitions = other209.range_partitions;
  __isset = other209.__isset;
  return *this;
}
TKuduPartitionByRangeParam& TKuduPartitionByRangeParam::operator=(TKuduPartitionByRangeParam&& other210) {
  columns = std::move(other210.columns);
  range_partitions = std::move(other210.range_partitions);
  __isset = std::move(other210.__isset);
  return *this;
}
void TKuduPartitionByRangeParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionByRangeParam(";
  out << "columns=" << to_string(columns);
  out << ", " << "range_partitions="; (__isset.range_partitions ? (out << to_string(range_partitions)) : (out << "<null>"));
  out << ")";
}


TKuduPartitionParam::~TKuduPartitionParam() throw() {
}


void TKuduPartitionParam::__set_by_hash_param(const TKuduPartitionByHashParam& val) {
  this->by_hash_param = val;
__isset.by_hash_param = true;
}

void TKuduPartitionParam::__set_by_range_param(const TKuduPartitionByRangeParam& val) {
  this->by_range_param = val;
__isset.by_range_param = true;
}
std::ostream& operator<<(std::ostream& out, const TKuduPartitionParam& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TKuduPartitionParam &a, TKuduPartitionParam &b) {
  using ::std::swap;
  swap(a.by_hash_param, b.by_hash_param);
  swap(a.by_range_param, b.by_range_param);
  swap(a.__isset, b.__isset);
}

TKuduPartitionParam::TKuduPartitionParam(const TKuduPartitionParam& other211) {
  by_hash_param = other211.by_hash_param;
  by_range_param = other211.by_range_param;
  __isset = other211.__isset;
}
TKuduPartitionParam::TKuduPartitionParam( TKuduPartitionParam&& other212) {
  by_hash_param = std::move(other212.by_hash_param);
  by_range_param = std::move(other212.by_range_param);
  __isset = std::move(other212.__isset);
}
TKuduPartitionParam& TKuduPartitionParam::operator=(const TKuduPartitionParam& other213) {
  by_hash_param = other213.by_hash_param;
  by_range_param = other213.by_range_param;
  __isset = other213.__isset;
  return *this;
}
TKuduPartitionParam& TKuduPartitionParam::operator=(TKuduPartitionParam&& other214) {
  by_hash_param = std::move(other214.by_hash_param);
  by_range_param = std::move(other214.by_range_param);
  __isset = std::move(other214.__isset);
  return *this;
}
void TKuduPartitionParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduPartitionParam(";
  out << "by_hash_param="; (__isset.by_hash_param ? (out << to_string(by_hash_param)) : (out << "<null>"));
  out << ", " << "by_range_param="; (__isset.by_range_param ? (out << to_string(by_range_param)) : (out << "<null>"));
  out << ")";
}


TKuduTable::~TKuduTable() throw() {
}


void TKuduTable::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TKuduTable::__set_master_addresses(const std::vector<std::string> & val) {
  this->master_addresses = val;
}

void TKuduTable::__set_key_columns(const std::vector<std::string> & val) {
  this->key_columns = val;
}

void TKuduTable::__set_partition_by(const std::vector<TKuduPartitionParam> & val) {
  this->partition_by = val;
}
std::ostream& operator<<(std::ostream& out, const TKuduTable& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TKuduTable &a, TKuduTable &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.master_addresses, b.master_addresses);
  swap(a.key_columns, b.key_columns);
  swap(a.partition_by, b.partition_by);
}

TKuduTable::TKuduTable(const TKuduTable& other233) {
  table_name = other233.table_name;
  master_addresses = other233.master_addresses;
  key_columns = other233.key_columns;
  partition_by = other233.partition_by;
}
TKuduTable::TKuduTable( TKuduTable&& other234) {
  table_name = std::move(other234.table_name);
  master_addresses = std::move(other234.master_addresses);
  key_columns = std::move(other234.key_columns);
  partition_by = std::move(other234.partition_by);
}
TKuduTable& TKuduTable::operator=(const TKuduTable& other235) {
  table_name = other235.table_name;
  master_addresses = other235.master_addresses;
  key_columns = other235.key_columns;
  partition_by = other235.partition_by;
  return *this;
}
TKuduTable& TKuduTable::operator=(TKuduTable&& other236) {
  table_name = std::move(other236.table_name);
  master_addresses = std::move(other236.master_addresses);
  key_columns = std::move(other236.key_columns);
  partition_by = std::move(other236.partition_by);
  return *this;
}
void TKuduTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TKuduTable(";
  out << "table_name=" << to_string(table_name);
  out << ", " << "master_addresses=" << to_string(master_addresses);
  out << ", " << "key_columns=" << to_string(key_columns);
  out << ", " << "partition_by=" << to_string(partition_by);
  out << ")";
}


TIcebergPartitionTransform::~TIcebergPartitionTransform() throw() {
}


void TIcebergPartitionTransform::__set_transform_type(const TIcebergPartitionTransformType::type val) {
  this->transform_type = val;
}

void TIcebergPartitionTransform::__set_transform_param(const int32_t val) {
  this->transform_param = val;
__isset.transform_param = true;
}
std::ostream& operator<<(std::ostream& out, const TIcebergPartitionTransform& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIcebergPartitionTransform &a, TIcebergPartitionTransform &b) {
  using ::std::swap;
  swap(a.transform_type, b.transform_type);
  swap(a.transform_param, b.transform_param);
  swap(a.__isset, b.__isset);
}

TIcebergPartitionTransform::TIcebergPartitionTransform(const TIcebergPartitionTransform& other238) {
  transform_type = other238.transform_type;
  transform_param = other238.transform_param;
  __isset = other238.__isset;
}
TIcebergPartitionTransform::TIcebergPartitionTransform( TIcebergPartitionTransform&& other239) {
  transform_type = std::move(other239.transform_type);
  transform_param = std::move(other239.transform_param);
  __isset = std::move(other239.__isset);
}
TIcebergPartitionTransform& TIcebergPartitionTransform::operator=(const TIcebergPartitionTransform& other240) {
  transform_type = other240.transform_type;
  transform_param = other240.transform_param;
  __isset = other240.__isset;
  return *this;
}
TIcebergPartitionTransform& TIcebergPartitionTransform::operator=(TIcebergPartitionTransform&& other241) {
  transform_type = std::move(other241.transform_type);
  transform_param = std::move(other241.transform_param);
  __isset = std::move(other241.__isset);
  return *this;
}
void TIcebergPartitionTransform::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIcebergPartitionTransform(";
  out << "transform_type=" << to_string(transform_type);
  out << ", " << "transform_param="; (__isset.transform_param ? (out << to_string(transform_param)) : (out << "<null>"));
  out << ")";
}


TIcebergPartitionField::~TIcebergPartitionField() throw() {
}


void TIcebergPartitionField::__set_source_id(const int32_t val) {
  this->source_id = val;
}

void TIcebergPartitionField::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void TIcebergPartitionField::__set_orig_field_name(const std::string& val) {
  this->orig_field_name = val;
}

void TIcebergPartitionField::__set_field_name(const std::string& val) {
  this->field_name = val;
}

void TIcebergPartitionField::__set_transform(const TIcebergPartitionTransform& val) {
  this->transform = val;
}
std::ostream& operator<<(std::ostream& out, const TIcebergPartitionField& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIcebergPartitionField &a, TIcebergPartitionField &b) {
  using ::std::swap;
  swap(a.source_id, b.source_id);
  swap(a.field_id, b.field_id);
  swap(a.orig_field_name, b.orig_field_name);
  swap(a.field_name, b.field_name);
  swap(a.transform, b.transform);
}

TIcebergPartitionField::TIcebergPartitionField(const TIcebergPartitionField& other242) {
  source_id = other242.source_id;
  field_id = other242.field_id;
  orig_field_name = other242.orig_field_name;
  field_name = other242.field_name;
  transform = other242.transform;
}
TIcebergPartitionField::TIcebergPartitionField( TIcebergPartitionField&& other243) {
  source_id = std::move(other243.source_id);
  field_id = std::move(other243.field_id);
  orig_field_name = std::move(other243.orig_field_name);
  field_name = std::move(other243.field_name);
  transform = std::move(other243.transform);
}
TIcebergPartitionField& TIcebergPartitionField::operator=(const TIcebergPartitionField& other244) {
  source_id = other244.source_id;
  field_id = other244.field_id;
  orig_field_name = other244.orig_field_name;
  field_name = other244.field_name;
  transform = other244.transform;
  return *this;
}
TIcebergPartitionField& TIcebergPartitionField::operator=(TIcebergPartitionField&& other245) {
  source_id = std::move(other245.source_id);
  field_id = std::move(other245.field_id);
  orig_field_name = std::move(other245.orig_field_name);
  field_name = std::move(other245.field_name);
  transform = std::move(other245.transform);
  return *this;
}
void TIcebergPartitionField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIcebergPartitionField(";
  out << "source_id=" << to_string(source_id);
  out << ", " << "field_id=" << to_string(field_id);
  out << ", " << "orig_field_name=" << to_string(orig_field_name);
  out << ", " << "field_name=" << to_string(field_name);
  out << ", " << "transform=" << to_string(transform);
  out << ")";
}


TIcebergPartitionSpec::~TIcebergPartitionSpec() throw() {
}


void TIcebergPartitionSpec::__set_partition_id(const int32_t val) {
  this->partition_id = val;
}

void TIcebergPartitionSpec::__set_partition_fields(const std::vector<TIcebergPartitionField> & val) {
  this->partition_fields = val;
__isset.partition_fields = true;
}
std::ostream& operator<<(std::ostream& out, const TIcebergPartitionSpec& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIcebergPartitionSpec &a, TIcebergPartitionSpec &b) {
  using ::std::swap;
  swap(a.partition_id, b.partition_id);
  swap(a.partition_fields, b.partition_fields);
  swap(a.__isset, b.__isset);
}

TIcebergPartitionSpec::TIcebergPartitionSpec(const TIcebergPartitionSpec& other252) {
  partition_id = other252.partition_id;
  partition_fields = other252.partition_fields;
  __isset = other252.__isset;
}
TIcebergPartitionSpec::TIcebergPartitionSpec( TIcebergPartitionSpec&& other253) {
  partition_id = std::move(other253.partition_id);
  partition_fields = std::move(other253.partition_fields);
  __isset = std::move(other253.__isset);
}
TIcebergPartitionSpec& TIcebergPartitionSpec::operator=(const TIcebergPartitionSpec& other254) {
  partition_id = other254.partition_id;
  partition_fields = other254.partition_fields;
  __isset = other254.__isset;
  return *this;
}
TIcebergPartitionSpec& TIcebergPartitionSpec::operator=(TIcebergPartitionSpec&& other255) {
  partition_id = std::move(other255.partition_id);
  partition_fields = std::move(other255.partition_fields);
  __isset = std::move(other255.__isset);
  return *this;
}
void TIcebergPartitionSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIcebergPartitionSpec(";
  out << "partition_id=" << to_string(partition_id);
  out << ", " << "partition_fields="; (__isset.partition_fields ? (out << to_string(partition_fields)) : (out << "<null>"));
  out << ")";
}


TIcebergTable::~TIcebergTable() throw() {
}


void TIcebergTable::__set_table_location(const std::string& val) {
  this->table_location = val;
}

void TIcebergTable::__set_partition_spec(const std::vector<TIcebergPartitionSpec> & val) {
  this->partition_spec = val;
}

void TIcebergTable::__set_default_partition_spec_id(const int32_t val) {
  this->default_partition_spec_id = val;
}

void TIcebergTable::__set_path_hash_to_file_descriptor(const std::map<std::string, THdfsFileDesc> & val) {
  this->path_hash_to_file_descriptor = val;
__isset.path_hash_to_file_descriptor = true;
}

void TIcebergTable::__set_snapshot_id(const int64_t val) {
  this->snapshot_id = val;
__isset.snapshot_id = true;
}

void TIcebergTable::__set_parquet_compression_codec(const TCompressionCodec& val) {
  this->parquet_compression_codec = val;
__isset.parquet_compression_codec = true;
}

void TIcebergTable::__set_parquet_row_group_size(const int64_t val) {
  this->parquet_row_group_size = val;
__isset.parquet_row_group_size = true;
}

void TIcebergTable::__set_parquet_plain_page_size(const int64_t val) {
  this->parquet_plain_page_size = val;
__isset.parquet_plain_page_size = true;
}

void TIcebergTable::__set_parquet_dict_page_size(const int64_t val) {
  this->parquet_dict_page_size = val;
__isset.parquet_dict_page_size = true;
}
std::ostream& operator<<(std::ostream& out, const TIcebergTable& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TIcebergTable &a, TIcebergTable &b) {
  using ::std::swap;
  swap(a.table_location, b.table_location);
  swap(a.partition_spec, b.partition_spec);
  swap(a.default_partition_spec_id, b.default_partition_spec_id);
  swap(a.path_hash_to_file_descriptor, b.path_hash_to_file_descriptor);
  swap(a.snapshot_id, b.snapshot_id);
  swap(a.parquet_compression_codec, b.parquet_compression_codec);
  swap(a.parquet_row_group_size, b.parquet_row_group_size);
  swap(a.parquet_plain_page_size, b.parquet_plain_page_size);
  swap(a.parquet_dict_page_size, b.parquet_dict_page_size);
  swap(a.__isset, b.__isset);
}

TIcebergTable::TIcebergTable(const TIcebergTable& other270) {
  table_location = other270.table_location;
  partition_spec = other270.partition_spec;
  default_partition_spec_id = other270.default_partition_spec_id;
  path_hash_to_file_descriptor = other270.path_hash_to_file_descriptor;
  snapshot_id = other270.snapshot_id;
  parquet_compression_codec = other270.parquet_compression_codec;
  parquet_row_group_size = other270.parquet_row_group_size;
  parquet_plain_page_size = other270.parquet_plain_page_size;
  parquet_dict_page_size = other270.parquet_dict_page_size;
  __isset = other270.__isset;
}
TIcebergTable::TIcebergTable( TIcebergTable&& other271) {
  table_location = std::move(other271.table_location);
  partition_spec = std::move(other271.partition_spec);
  default_partition_spec_id = std::move(other271.default_partition_spec_id);
  path_hash_to_file_descriptor = std::move(other271.path_hash_to_file_descriptor);
  snapshot_id = std::move(other271.snapshot_id);
  parquet_compression_codec = std::move(other271.parquet_compression_codec);
  parquet_row_group_size = std::move(other271.parquet_row_group_size);
  parquet_plain_page_size = std::move(other271.parquet_plain_page_size);
  parquet_dict_page_size = std::move(other271.parquet_dict_page_size);
  __isset = std::move(other271.__isset);
}
TIcebergTable& TIcebergTable::operator=(const TIcebergTable& other272) {
  table_location = other272.table_location;
  partition_spec = other272.partition_spec;
  default_partition_spec_id = other272.default_partition_spec_id;
  path_hash_to_file_descriptor = other272.path_hash_to_file_descriptor;
  snapshot_id = other272.snapshot_id;
  parquet_compression_codec = other272.parquet_compression_codec;
  parquet_row_group_size = other272.parquet_row_group_size;
  parquet_plain_page_size = other272.parquet_plain_page_size;
  parquet_dict_page_size = other272.parquet_dict_page_size;
  __isset = other272.__isset;
  return *this;
}
TIcebergTable& TIcebergTable::operator=(TIcebergTable&& other273) {
  table_location = std::move(other273.table_location);
  partition_spec = std::move(other273.partition_spec);
  default_partition_spec_id = std::move(other273.default_partition_spec_id);
  path_hash_to_file_descriptor = std::move(other273.path_hash_to_file_descriptor);
  snapshot_id = std::move(other273.snapshot_id);
  parquet_compression_codec = std::move(other273.parquet_compression_codec);
  parquet_row_group_size = std::move(other273.parquet_row_group_size);
  parquet_plain_page_size = std::move(other273.parquet_plain_page_size);
  parquet_dict_page_size = std::move(other273.parquet_dict_page_size);
  __isset = std::move(other273.__isset);
  return *this;
}
void TIcebergTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TIcebergTable(";
  out << "table_location=" << to_string(table_location);
  out << ", " << "partition_spec=" << to_string(partition_spec);
  out << ", " << "default_partition_spec_id=" << to_string(default_partition_spec_id);
  out << ", " << "path_hash_to_file_descriptor="; (__isset.path_hash_to_file_descriptor ? (out << to_string(path_hash_to_file_descriptor)) : (out << "<null>"));
  out << ", " << "snapshot_id="; (__isset.snapshot_id ? (out << to_string(snapshot_id)) : (out << "<null>"));
  out << ", " << "parquet_compression_codec="; (__isset.parquet_compression_codec ? (out << to_string(parquet_compression_codec)) : (out << "<null>"));
  out << ", " << "parquet_row_group_size="; (__isset.parquet_row_group_size ? (out << to_string(parquet_row_group_size)) : (out << "<null>"));
  out << ", " << "parquet_plain_page_size="; (__isset.parquet_plain_page_size ? (out << to_string(parquet_plain_page_size)) : (out << "<null>"));
  out << ", " << "parquet_dict_page_size="; (__isset.parquet_dict_page_size ? (out << to_string(parquet_dict_page_size)) : (out << "<null>"));
  out << ")";
}


TTable::~TTable() throw() {
}


void TTable::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TTable::__set_tbl_name(const std::string& val) {
  this->tbl_name = val;
}

void TTable::__set_load_status(const  ::impala::TStatus& val) {
  this->load_status = val;
__isset.load_status = true;
}

void TTable::__set_access_level(const TAccessLevel::type val) {
  this->access_level = val;
__isset.access_level = true;
}

void TTable::__set_columns(const std::vector<TColumn> & val) {
  this->columns = val;
__isset.columns = true;
}

void TTable::__set_clustering_columns(const std::vector<TColumn> & val) {
  this->clustering_columns = val;
__isset.clustering_columns = true;
}

void TTable::__set_table_stats(const TTableStats& val) {
  this->table_stats = val;
__isset.table_stats = true;
}

void TTable::__set_table_type(const TTableType::type val) {
  this->table_type = val;
__isset.table_type = true;
}

void TTable::__set_hdfs_table(const THdfsTable& val) {
  this->hdfs_table = val;
__isset.hdfs_table = true;
}

void TTable::__set_hbase_table(const THBaseTable& val) {
  this->hbase_table = val;
__isset.hbase_table = true;
}

void TTable::__set_metastore_table(const  ::Apache::Hadoop::Hive::Table& val) {
  this->metastore_table = val;
__isset.metastore_table = true;
}

void TTable::__set_data_source_table(const TDataSourceTable& val) {
  this->data_source_table = val;
__isset.data_source_table = true;
}

void TTable::__set_kudu_table(const TKuduTable& val) {
  this->kudu_table = val;
__isset.kudu_table = true;
}

void TTable::__set_storage_metadata_load_time_ns(const int64_t val) {
  this->storage_metadata_load_time_ns = val;
__isset.storage_metadata_load_time_ns = true;
}

void TTable::__set_iceberg_table(const TIcebergTable& val) {
  this->iceberg_table = val;
__isset.iceberg_table = true;
}
std::ostream& operator<<(std::ostream& out, const TTable& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TTable &a, TTable &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.tbl_name, b.tbl_name);
  swap(a.load_status, b.load_status);
  swap(a.access_level, b.access_level);
  swap(a.columns, b.columns);
  swap(a.clustering_columns, b.clustering_columns);
  swap(a.table_stats, b.table_stats);
  swap(a.table_type, b.table_type);
  swap(a.hdfs_table, b.hdfs_table);
  swap(a.hbase_table, b.hbase_table);
  swap(a.metastore_table, b.metastore_table);
  swap(a.data_source_table, b.data_source_table);
  swap(a.kudu_table, b.kudu_table);
  swap(a.storage_metadata_load_time_ns, b.storage_metadata_load_time_ns);
  swap(a.iceberg_table, b.iceberg_table);
  swap(a.__isset, b.__isset);
}

TTable::TTable(const TTable& other288) {
  db_name = other288.db_name;
  tbl_name = other288.tbl_name;
  load_status = other288.load_status;
  access_level = other288.access_level;
  columns = other288.columns;
  clustering_columns = other288.clustering_columns;
  table_stats = other288.table_stats;
  table_type = other288.table_type;
  hdfs_table = other288.hdfs_table;
  hbase_table = other288.hbase_table;
  metastore_table = other288.metastore_table;
  data_source_table = other288.data_source_table;
  kudu_table = other288.kudu_table;
  storage_metadata_load_time_ns = other288.storage_metadata_load_time_ns;
  iceberg_table = other288.iceberg_table;
  __isset = other288.__isset;
}
TTable::TTable( TTable&& other289) {
  db_name = std::move(other289.db_name);
  tbl_name = std::move(other289.tbl_name);
  load_status = std::move(other289.load_status);
  access_level = std::move(other289.access_level);
  columns = std::move(other289.columns);
  clustering_columns = std::move(other289.clustering_columns);
  table_stats = std::move(other289.table_stats);
  table_type = std::move(other289.table_type);
  hdfs_table = std::move(other289.hdfs_table);
  hbase_table = std::move(other289.hbase_table);
  metastore_table = std::move(other289.metastore_table);
  data_source_table = std::move(other289.data_source_table);
  kudu_table = std::move(other289.kudu_table);
  storage_metadata_load_time_ns = std::move(other289.storage_metadata_load_time_ns);
  iceberg_table = std::move(other289.iceberg_table);
  __isset = std::move(other289.__isset);
}
TTable& TTable::operator=(const TTable& other290) {
  db_name = other290.db_name;
  tbl_name = other290.tbl_name;
  load_status = other290.load_status;
  access_level = other290.access_level;
  columns = other290.columns;
  clustering_columns = other290.clustering_columns;
  table_stats = other290.table_stats;
  table_type = other290.table_type;
  hdfs_table = other290.hdfs_table;
  hbase_table = other290.hbase_table;
  metastore_table = other290.metastore_table;
  data_source_table = other290.data_source_table;
  kudu_table = other290.kudu_table;
  storage_metadata_load_time_ns = other290.storage_metadata_load_time_ns;
  iceberg_table = other290.iceberg_table;
  __isset = other290.__isset;
  return *this;
}
TTable& TTable::operator=(TTable&& other291) {
  db_name = std::move(other291.db_name);
  tbl_name = std::move(other291.tbl_name);
  load_status = std::move(other291.load_status);
  access_level = std::move(other291.access_level);
  columns = std::move(other291.columns);
  clustering_columns = std::move(other291.clustering_columns);
  table_stats = std::move(other291.table_stats);
  table_type = std::move(other291.table_type);
  hdfs_table = std::move(other291.hdfs_table);
  hbase_table = std::move(other291.hbase_table);
  metastore_table = std::move(other291.metastore_table);
  data_source_table = std::move(other291.data_source_table);
  kudu_table = std::move(other291.kudu_table);
  storage_metadata_load_time_ns = std::move(other291.storage_metadata_load_time_ns);
  iceberg_table = std::move(other291.iceberg_table);
  __isset = std::move(other291.__isset);
  return *this;
}
void TTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TTable(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "tbl_name=" << to_string(tbl_name);
  out << ", " << "load_status="; (__isset.load_status ? (out << to_string(load_status)) : (out << "<null>"));
  out << ", " << "access_level="; (__isset.access_level ? (out << to_string(access_level)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "clustering_columns="; (__isset.clustering_columns ? (out << to_string(clustering_columns)) : (out << "<null>"));
  out << ", " << "table_stats="; (__isset.table_stats ? (out << to_string(table_stats)) : (out << "<null>"));
  out << ", " << "table_type="; (__isset.table_type ? (out << to_string(table_type)) : (out << "<null>"));
  out << ", " << "hdfs_table="; (__isset.hdfs_table ? (out << to_string(hdfs_table)) : (out << "<null>"));
  out << ", " << "hbase_table="; (__isset.hbase_table ? (out << to_string(hbase_table)) : (out << "<null>"));
  out << ", " << "metastore_table="; (__isset.metastore_table ? (out << to_string(metastore_table)) : (out << "<null>"));
  out << ", " << "data_source_table="; (__isset.data_source_table ? (out << to_string(data_source_table)) : (out << "<null>"));
  out << ", " << "kudu_table="; (__isset.kudu_table ? (out << to_string(kudu_table)) : (out << "<null>"));
  out << ", " << "storage_metadata_load_time_ns="; (__isset.storage_metadata_load_time_ns ? (out << to_string(storage_metadata_load_time_ns)) : (out << "<null>"));
  out << ", " << "iceberg_table="; (__isset.iceberg_table ? (out << to_string(iceberg_table)) : (out << "<null>"));
  out << ")";
}


TDatabase::~TDatabase() throw() {
}


void TDatabase::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void TDatabase::__set_metastore_db(const  ::Apache::Hadoop::Hive::Database& val) {
  this->metastore_db = val;
__isset.metastore_db = true;
}
std::ostream& operator<<(std::ostream& out, const TDatabase& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TDatabase &a, TDatabase &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.metastore_db, b.metastore_db);
  swap(a.__isset, b.__isset);
}

TDatabase::TDatabase(const TDatabase& other292) {
  db_name = other292.db_name;
  metastore_db = other292.metastore_db;
  __isset = other292.__isset;
}
TDatabase::TDatabase( TDatabase&& other293) {
  db_name = std::move(other293.db_name);
  metastore_db = std::move(other293.metastore_db);
  __isset = std::move(other293.__isset);
}
TDatabase& TDatabase::operator=(const TDatabase& other294) {
  db_name = other294.db_name;
  metastore_db = other294.metastore_db;
  __isset = other294.__isset;
  return *this;
}
TDatabase& TDatabase::operator=(TDatabase&& other295) {
  db_name = std::move(other295.db_name);
  metastore_db = std::move(other295.metastore_db);
  __isset = std::move(other295.__isset);
  return *this;
}
void TDatabase::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TDatabase(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "metastore_db="; (__isset.metastore_db ? (out << to_string(metastore_db)) : (out << "<null>"));
  out << ")";
}


TPrincipal::~TPrincipal() throw() {
}


void TPrincipal::__set_principal_name(const std::string& val) {
  this->principal_name = val;
}

void TPrincipal::__set_principal_id(const int32_t val) {
  this->principal_id = val;
}

void TPrincipal::__set_principal_type(const TPrincipalType::type val) {
  this->principal_type = val;
}

void TPrincipal::__set_grant_groups(const std::vector<std::string> & val) {
  this->grant_groups = val;
}
std::ostream& operator<<(std::ostream& out, const TPrincipal& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPrincipal &a, TPrincipal &b) {
  using ::std::swap;
  swap(a.principal_name, b.principal_name);
  swap(a.principal_id, b.principal_id);
  swap(a.principal_type, b.principal_type);
  swap(a.grant_groups, b.grant_groups);
}

TPrincipal::TPrincipal(const TPrincipal& other303) {
  principal_name = other303.principal_name;
  principal_id = other303.principal_id;
  principal_type = other303.principal_type;
  grant_groups = other303.grant_groups;
}
TPrincipal::TPrincipal( TPrincipal&& other304) {
  principal_name = std::move(other304.principal_name);
  principal_id = std::move(other304.principal_id);
  principal_type = std::move(other304.principal_type);
  grant_groups = std::move(other304.grant_groups);
}
TPrincipal& TPrincipal::operator=(const TPrincipal& other305) {
  principal_name = other305.principal_name;
  principal_id = other305.principal_id;
  principal_type = other305.principal_type;
  grant_groups = other305.grant_groups;
  return *this;
}
TPrincipal& TPrincipal::operator=(TPrincipal&& other306) {
  principal_name = std::move(other306.principal_name);
  principal_id = std::move(other306.principal_id);
  principal_type = std::move(other306.principal_type);
  grant_groups = std::move(other306.grant_groups);
  return *this;
}
void TPrincipal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPrincipal(";
  out << "principal_name=" << to_string(principal_name);
  out << ", " << "principal_id=" << to_string(principal_id);
  out << ", " << "principal_type=" << to_string(principal_type);
  out << ", " << "grant_groups=" << to_string(grant_groups);
  out << ")";
}


TPrivilege::~TPrivilege() throw() {
}


void TPrivilege::__set_privilege_level(const TPrivilegeLevel::type val) {
  this->privilege_level = val;
}

void TPrivilege::__set_scope(const TPrivilegeScope::type val) {
  this->scope = val;
}

void TPrivilege::__set_has_grant_opt(const bool val) {
  this->has_grant_opt = val;
}

void TPrivilege::__set_principal_id(const int32_t val) {
  this->principal_id = val;
__isset.principal_id = true;
}

void TPrivilege::__set_principal_type(const TPrincipalType::type val) {
  this->principal_type = val;
__isset.principal_type = true;
}

void TPrivilege::__set_server_name(const std::string& val) {
  this->server_name = val;
__isset.server_name = true;
}

void TPrivilege::__set_db_name(const std::string& val) {
  this->db_name = val;
__isset.db_name = true;
}

void TPrivilege::__set_table_name(const std::string& val) {
  this->table_name = val;
__isset.table_name = true;
}

void TPrivilege::__set_uri(const std::string& val) {
  this->uri = val;
__isset.uri = true;
}

void TPrivilege::__set_create_time_ms(const int64_t val) {
  this->create_time_ms = val;
__isset.create_time_ms = true;
}

void TPrivilege::__set_column_name(const std::string& val) {
  this->column_name = val;
__isset.column_name = true;
}
std::ostream& operator<<(std::ostream& out, const TPrivilege& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TPrivilege &a, TPrivilege &b) {
  using ::std::swap;
  swap(a.privilege_level, b.privilege_level);
  swap(a.scope, b.scope);
  swap(a.has_grant_opt, b.has_grant_opt);
  swap(a.principal_id, b.principal_id);
  swap(a.principal_type, b.principal_type);
  swap(a.server_name, b.server_name);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.uri, b.uri);
  swap(a.create_time_ms, b.create_time_ms);
  swap(a.column_name, b.column_name);
  swap(a.__isset, b.__isset);
}

TPrivilege::TPrivilege(const TPrivilege& other310) {
  privilege_level = other310.privilege_level;
  scope = other310.scope;
  has_grant_opt = other310.has_grant_opt;
  principal_id = other310.principal_id;
  principal_type = other310.principal_type;
  server_name = other310.server_name;
  db_name = other310.db_name;
  table_name = other310.table_name;
  uri = other310.uri;
  create_time_ms = other310.create_time_ms;
  column_name = other310.column_name;
  __isset = other310.__isset;
}
TPrivilege::TPrivilege( TPrivilege&& other311) {
  privilege_level = std::move(other311.privilege_level);
  scope = std::move(other311.scope);
  has_grant_opt = std::move(other311.has_grant_opt);
  principal_id = std::move(other311.principal_id);
  principal_type = std::move(other311.principal_type);
  server_name = std::move(other311.server_name);
  db_name = std::move(other311.db_name);
  table_name = std::move(other311.table_name);
  uri = std::move(other311.uri);
  create_time_ms = std::move(other311.create_time_ms);
  column_name = std::move(other311.column_name);
  __isset = std::move(other311.__isset);
}
TPrivilege& TPrivilege::operator=(const TPrivilege& other312) {
  privilege_level = other312.privilege_level;
  scope = other312.scope;
  has_grant_opt = other312.has_grant_opt;
  principal_id = other312.principal_id;
  principal_type = other312.principal_type;
  server_name = other312.server_name;
  db_name = other312.db_name;
  table_name = other312.table_name;
  uri = other312.uri;
  create_time_ms = other312.create_time_ms;
  column_name = other312.column_name;
  __isset = other312.__isset;
  return *this;
}
TPrivilege& TPrivilege::operator=(TPrivilege&& other313) {
  privilege_level = std::move(other313.privilege_level);
  scope = std::move(other313.scope);
  has_grant_opt = std::move(other313.has_grant_opt);
  principal_id = std::move(other313.principal_id);
  principal_type = std::move(other313.principal_type);
  server_name = std::move(other313.server_name);
  db_name = std::move(other313.db_name);
  table_name = std::move(other313.table_name);
  uri = std::move(other313.uri);
  create_time_ms = std::move(other313.create_time_ms);
  column_name = std::move(other313.column_name);
  __isset = std::move(other313.__isset);
  return *this;
}
void TPrivilege::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TPrivilege(";
  out << "privilege_level=" << to_string(privilege_level);
  out << ", " << "scope=" << to_string(scope);
  out << ", " << "has_grant_opt=" << to_string(has_grant_opt);
  out << ", " << "principal_id="; (__isset.principal_id ? (out << to_string(principal_id)) : (out << "<null>"));
  out << ", " << "principal_type="; (__isset.principal_type ? (out << to_string(principal_type)) : (out << "<null>"));
  out << ", " << "server_name="; (__isset.server_name ? (out << to_string(server_name)) : (out << "<null>"));
  out << ", " << "db_name="; (__isset.db_name ? (out << to_string(db_name)) : (out << "<null>"));
  out << ", " << "table_name="; (__isset.table_name ? (out << to_string(table_name)) : (out << "<null>"));
  out << ", " << "uri="; (__isset.uri ? (out << to_string(uri)) : (out << "<null>"));
  out << ", " << "create_time_ms="; (__isset.create_time_ms ? (out << to_string(create_time_ms)) : (out << "<null>"));
  out << ", " << "column_name="; (__isset.column_name ? (out << to_string(column_name)) : (out << "<null>"));
  out << ")";
}


THdfsCachePool::~THdfsCachePool() throw() {
}


void THdfsCachePool::__set_pool_name(const std::string& val) {
  this->pool_name = val;
}
std::ostream& operator<<(std::ostream& out, const THdfsCachePool& obj)
{
  obj.printTo(out);
  return out;
}


void swap(THdfsCachePool &a, THdfsCachePool &b) {
  using ::std::swap;
  swap(a.pool_name, b.pool_name);
}

THdfsCachePool::THdfsCachePool(const THdfsCachePool& other314) {
  pool_name = other314.pool_name;
}
THdfsCachePool::THdfsCachePool( THdfsCachePool&& other315) {
  pool_name = std::move(other315.pool_name);
}
THdfsCachePool& THdfsCachePool::operator=(const THdfsCachePool& other316) {
  pool_name = other316.pool_name;
  return *this;
}
THdfsCachePool& THdfsCachePool::operator=(THdfsCachePool&& other317) {
  pool_name = std::move(other317.pool_name);
  return *this;
}
void THdfsCachePool::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THdfsCachePool(";
  out << "pool_name=" << to_string(pool_name);
  out << ")";
}


TAuthzCacheInvalidation::~TAuthzCacheInvalidation() throw() {
}


void TAuthzCacheInvalidation::__set_marker_name(const std::string& val) {
  this->marker_name = val;
}
std::ostream& operator<<(std::ostream& out, const TAuthzCacheInvalidation& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TAuthzCacheInvalidation &a, TAuthzCacheInvalidation &b) {
  using ::std::swap;
  swap(a.marker_name, b.marker_name);
}

TAuthzCacheInvalidation::TAuthzCacheInvalidation(const TAuthzCacheInvalidation& other318) {
  marker_name = other318.marker_name;
}
TAuthzCacheInvalidation::TAuthzCacheInvalidation( TAuthzCacheInvalidation&& other319) {
  marker_name = std::move(other319.marker_name);
}
TAuthzCacheInvalidation& TAuthzCacheInvalidation::operator=(const TAuthzCacheInvalidation& other320) {
  marker_name = other320.marker_name;
  return *this;
}
TAuthzCacheInvalidation& TAuthzCacheInvalidation::operator=(TAuthzCacheInvalidation&& other321) {
  marker_name = std::move(other321.marker_name);
  return *this;
}
void TAuthzCacheInvalidation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TAuthzCacheInvalidation(";
  out << "marker_name=" << to_string(marker_name);
  out << ")";
}


TCatalog::~TCatalog() throw() {
}


void TCatalog::__set_catalog_service_id(const  ::impala::TUniqueId& val) {
  this->catalog_service_id = val;
}

void TCatalog::__set_last_reset_catalog_version(const int64_t val) {
  this->last_reset_catalog_version = val;
}
std::ostream& operator<<(std::ostream& out, const TCatalog& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCatalog &a, TCatalog &b) {
  using ::std::swap;
  swap(a.catalog_service_id, b.catalog_service_id);
  swap(a.last_reset_catalog_version, b.last_reset_catalog_version);
}

TCatalog::TCatalog(const TCatalog& other322) {
  catalog_service_id = other322.catalog_service_id;
  last_reset_catalog_version = other322.last_reset_catalog_version;
}
TCatalog::TCatalog( TCatalog&& other323) {
  catalog_service_id = std::move(other323.catalog_service_id);
  last_reset_catalog_version = std::move(other323.last_reset_catalog_version);
}
TCatalog& TCatalog::operator=(const TCatalog& other324) {
  catalog_service_id = other324.catalog_service_id;
  last_reset_catalog_version = other324.last_reset_catalog_version;
  return *this;
}
TCatalog& TCatalog::operator=(TCatalog&& other325) {
  catalog_service_id = std::move(other325.catalog_service_id);
  last_reset_catalog_version = std::move(other325.last_reset_catalog_version);
  return *this;
}
void TCatalog::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCatalog(";
  out << "catalog_service_id=" << to_string(catalog_service_id);
  out << ", " << "last_reset_catalog_version=" << to_string(last_reset_catalog_version);
  out << ")";
}


TCatalogObject::~TCatalogObject() throw() {
}


void TCatalogObject::__set_type(const TCatalogObjectType::type val) {
  this->type = val;
}

void TCatalogObject::__set_catalog_version(const int64_t val) {
  this->catalog_version = val;
}

void TCatalogObject::__set_catalog(const TCatalog& val) {
  this->catalog = val;
__isset.catalog = true;
}

void TCatalogObject::__set_db(const TDatabase& val) {
  this->db = val;
__isset.db = true;
}

void TCatalogObject::__set_table(const TTable& val) {
  this->table = val;
__isset.table = true;
}

void TCatalogObject::__set_fn(const  ::impala::TFunction& val) {
  this->fn = val;
__isset.fn = true;
}

void TCatalogObject::__set_data_source(const TDataSource& val) {
  this->data_source = val;
__isset.data_source = true;
}

void TCatalogObject::__set_principal(const TPrincipal& val) {
  this->principal = val;
__isset.principal = true;
}

void TCatalogObject::__set_privilege(const TPrivilege& val) {
  this->privilege = val;
__isset.privilege = true;
}

void TCatalogObject::__set_cache_pool(const THdfsCachePool& val) {
  this->cache_pool = val;
__isset.cache_pool = true;
}

void TCatalogObject::__set_authz_cache_invalidation(const TAuthzCacheInvalidation& val) {
  this->authz_cache_invalidation = val;
__isset.authz_cache_invalidation = true;
}

void TCatalogObject::__set_hdfs_partition(const THdfsPartition& val) {
  this->hdfs_partition = val;
__isset.hdfs_partition = true;
}
std::ostream& operator<<(std::ostream& out, const TCatalogObject& obj)
{
  obj.printTo(out);
  return out;
}


void swap(TCatalogObject &a, TCatalogObject &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.catalog_version, b.catalog_version);
  swap(a.catalog, b.catalog);
  swap(a.db, b.db);
  swap(a.table, b.table);
  swap(a.fn, b.fn);
  swap(a.data_source, b.data_source);
  swap(a.principal, b.principal);
  swap(a.privilege, b.privilege);
  swap(a.cache_pool, b.cache_pool);
  swap(a.authz_cache_invalidation, b.authz_cache_invalidation);
  swap(a.hdfs_partition, b.hdfs_partition);
  swap(a.__isset, b.__isset);
}

TCatalogObject::TCatalogObject(const TCatalogObject& other327) {
  type = other327.type;
  catalog_version = other327.catalog_version;
  catalog = other327.catalog;
  db = other327.db;
  table = other327.table;
  fn = other327.fn;
  data_source = other327.data_source;
  principal = other327.principal;
  privilege = other327.privilege;
  cache_pool = other327.cache_pool;
  authz_cache_invalidation = other327.authz_cache_invalidation;
  hdfs_partition = other327.hdfs_partition;
  __isset = other327.__isset;
}
TCatalogObject::TCatalogObject( TCatalogObject&& other328) {
  type = std::move(other328.type);
  catalog_version = std::move(other328.catalog_version);
  catalog = std::move(other328.catalog);
  db = std::move(other328.db);
  table = std::move(other328.table);
  fn = std::move(other328.fn);
  data_source = std::move(other328.data_source);
  principal = std::move(other328.principal);
  privilege = std::move(other328.privilege);
  cache_pool = std::move(other328.cache_pool);
  authz_cache_invalidation = std::move(other328.authz_cache_invalidation);
  hdfs_partition = std::move(other328.hdfs_partition);
  __isset = std::move(other328.__isset);
}
TCatalogObject& TCatalogObject::operator=(const TCatalogObject& other329) {
  type = other329.type;
  catalog_version = other329.catalog_version;
  catalog = other329.catalog;
  db = other329.db;
  table = other329.table;
  fn = other329.fn;
  data_source = other329.data_source;
  principal = other329.principal;
  privilege = other329.privilege;
  cache_pool = other329.cache_pool;
  authz_cache_invalidation = other329.authz_cache_invalidation;
  hdfs_partition = other329.hdfs_partition;
  __isset = other329.__isset;
  return *this;
}
TCatalogObject& TCatalogObject::operator=(TCatalogObject&& other330) {
  type = std::move(other330.type);
  catalog_version = std::move(other330.catalog_version);
  catalog = std::move(other330.catalog);
  db = std::move(other330.db);
  table = std::move(other330.table);
  fn = std::move(other330.fn);
  data_source = std::move(other330.data_source);
  principal = std::move(other330.principal);
  privilege = std::move(other330.privilege);
  cache_pool = std::move(other330.cache_pool);
  authz_cache_invalidation = std::move(other330.authz_cache_invalidation);
  hdfs_partition = std::move(other330.hdfs_partition);
  __isset = std::move(other330.__isset);
  return *this;
}
void TCatalogObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TCatalogObject(";
  out << "type=" << to_string(type);
  out << ", " << "catalog_version=" << to_string(catalog_version);
  out << ", " << "catalog="; (__isset.catalog ? (out << to_string(catalog)) : (out << "<null>"));
  out << ", " << "db="; (__isset.db ? (out << to_string(db)) : (out << "<null>"));
  out << ", " << "table="; (__isset.table ? (out << to_string(table)) : (out << "<null>"));
  out << ", " << "fn="; (__isset.fn ? (out << to_string(fn)) : (out << "<null>"));
  out << ", " << "data_source="; (__isset.data_source ? (out << to_string(data_source)) : (out << "<null>"));
  out << ", " << "principal="; (__isset.principal ? (out << to_string(principal)) : (out << "<null>"));
  out << ", " << "privilege="; (__isset.privilege ? (out << to_string(privilege)) : (out << "<null>"));
  out << ", " << "cache_pool="; (__isset.cache_pool ? (out << to_string(cache_pool)) : (out << "<null>"));
  out << ", " << "authz_cache_invalidation="; (__isset.authz_cache_invalidation ? (out << to_string(authz_cache_invalidation)) : (out << "<null>"));
  out << ", " << "hdfs_partition="; (__isset.hdfs_partition ? (out << to_string(hdfs_partition)) : (out << "<null>"));
  out << ")";
}

} // namespace
